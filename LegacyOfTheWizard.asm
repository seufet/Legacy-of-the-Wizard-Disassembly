;
; NES Legacy of the Wizard 
; Commented disassembly by Lord Tom, January 2026
; Contact: tom.seufert@gmail.com
;
;
;
; Table of Contents:
; banks 0-7: 	data for normal dungeon maps, 2 rows of 4 maps per 8k bank
; bank 8:		data for overworld map, crown boss maps
; bank 9:       data for dragon fight map, tile definitions
; banks a-b: 	data for music ID's 0-9 and the sound effects
; banks c-d:	data for music ID's a-f, data for start screen graphics, a few misc tables, code for the dragon fight
; banks e-f: 	fixed bank, a few misc tables, code for nmi/reset, sound, game engine
;
; Mapper notes: 
;   	-banks with level data (0-9) always map to $8000-9fff
;		-banks a-b and c-d are mapped in pairs to $8000-bfff
; 		-fixed banks e-f are in $c000-ffff
;
;
.setcpu "6502"

; defines mem address & constants
.INCLUDE "include\definitions.asm"

; iNES header: see https://www.nesdev.org/wiki/INES
.segment "INES"
        .byte $4E,$45,$53,$1A   ; NES & EOF
		.byte $08               ; 8x16k PRG ROM
		.byte $08               ; 8x8k CHR ROM
		.byte $40,$00           ; Mapper 4, MMC1
        .byte $00,$00,$00,$00,$00,$00,$00,$00
	
; ----------------------------------------------------------------------------
; Banks 0-9: level data
; ----------------------------------------------------------------------------

; MAP_Y = 0-3
.segment "PRG_01"
.INCLUDE "include\maps\prg0.asm"		
.INCLUDE "include\maps\prg1.asm"		

; MAP_Y = 4-7
.segment "PRG_23"
.INCLUDE "include\maps\prg2.asm"		
.INCLUDE "include\maps\prg3.asm"		

; MAP_Y = 8-x0B
.segment "PRG_45"
.INCLUDE "include\maps\prg4.asm"		
.INCLUDE "include\maps\prg5.asm"		

; MAP_Y = x0C-x0F
.segment "PRG_67"
.INCLUDE "include\maps\prg6.asm"		
.INCLUDE "include\maps\prg7.asm"		

; MAP_Y = x10-13 (overworld, inns/shops, boss levels, dragon fight stage)
.segment "PRG_89"
.INCLUDE "include\maps\prg8.asm"		
.INCLUDE "include\maps\prg9.asm"		

; ----------------------------------------------------------------------------
; Banks a-b: sound data
; ----------------------------------------------------------------------------

; Sound data
.segment "PRG_AB"
.INCLUDE "include\sound\bank-a-b-sound-data.asm"		

; ----------------------------------------------------------------------------
; Banks c-d: mixed data and code
; ----------------------------------------------------------------------------

.segment "PRG_CD"
.INCLUDE "include\sound\bank-c-d-sound-data.asm"		
.INCLUDE "include\bank-c-d-grafx-data.asm"
		
; ----------------------------------------------------------------------------
; Dragon fight!!
; Handles everything from the initial flash to when the dragon comes alive and 
; drops to the ground, then does the final flashes and sets everything up for the fight,
; include player and dragon life bars, etc.
;
; Note the game uses basically an entirely different physics and graphics engine for the Dragon
; fight vs the rest of the game. The dragon and its flame don't use any sprites - two states are written 
; to the left/right nametables at any point for swapping between, and different tile definitions are swapped
; in to 'animate' it. Finally, the PPU x and y scrolls are used to make it move around. The technique allows
; the dragon to be bigger than sprites would allow, but means the background must be blacked out (or it would
; scroll around with the dragon). 
DRAGON_FIGHT_INTRO:  ; $a2eb      
		; dragon fight!
		lda     #SOUND_CROSS                            ; A2EB A9 18                    ..
        sta     NEXT_SOUND_EFFECT                             ; A2ED 85 8F                    ..
        lda     #$00                            ; A2EF A9 00                    ..
        sta     INVULN_CTR                             ; A2F1 85 85                    ..
        jsr     DRAW_PLAYER                           ; A2F3 20 D8 C1                  ..
        ldx     #$02                            ; A2F6 A2 02                    ..
        
		; setup jump to $c540 (FLASH_EFFECT_C540)
		; flash, erase objects
		lda     #$40                            ; A2F8 A9 40                    .@
        sta     JMP_DEST_0E_LO                             ; A2FA 85 0E                    ..
        lda     #$C5                            ; A2FC A9 C5                    ..
        sta     JMP_DEST_0F_HI                             ; A2FE 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A300 20 E4 CC                  ..
        jsr     CLEAR_ALL_OBJECTS                           ; A303 20 8A D0                  ..
        jsr     DRAW_OBJECTS                           ; A306 20 B1 C2                  ..
        ldx     #$03                            ; A309 A2 03                    ..
        
		; setup jump to $c540 (FLASH_EFFECT_C540)
		; flash again, fade bg to black
		lda     #$40                            ; A30B A9 40                    .@
        sta     JMP_DEST_0E_LO                             ; A30D 85 0E                    ..
        lda     #$C5                            ; A30F A9 C5                    ..
        sta     JMP_DEST_0F_HI                             ; A311 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A313 20 E4 CC                  ..
        jsr     DRAGON_PALETTE_FADEOUT                           ; A316 20 B5 A5                  ..
        
		; dragon roars
		lda     #SOUND_DRAGON                            ; A319 A9 20                    . 
        sta     NEXT_SOUND_EFFECT                             ; A31B 85 8F                    ..
        
		; wait a second
		lda     #$3C                            ; A31D A9 3C                    .<
        sta     NMI_WAIT_CTR                             ; A31F 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; A321 20 35 C1                  5.
        
		; force map location
		lda     #MAP_Y_DRAGON_FIGHT                            ; A324 A9 13                    ..
        sta     MAP_Y                             ; A326 85 48                    .H
        lda     #MAP_X_DRAGON_FIGHT                            ; A328 A9 02                    ..
        sta     MAP_X                             ; A32A 85 47                    .G
        
		; setup jump to $c8f2 (LOAD_MAP_FULL)
		lda     #$F2                            ; A32C A9 F2                    ..
        sta     JMP_DEST_0E_LO                             ; A32E 85 0E                    ..
        lda     #$C8                            ; A330 A9 C8                    ..
        sta     JMP_DEST_0F_HI                             ; A332 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A334 20 E4 CC                  ..
        
		; clear the nametable
		jsr     WIPE_NAMETABLE                           ; A337 20 8B C3                  ..
        
		; moving sprite 0 offscreen disables the status bar / split nametable function
		lda     #OFFSCREEN_Y                            ; A33A A9 EF                    ..
        sta     SPRITE_0_Y                           ; A33C 8D 00 02                 ...
        
		; prep the scroll, which is used to "move" the dragon around
		lda     #$22                            ; A33F A9 22                    ."
        sta     PPU_SCROLL_Y                             ; A341 85 1E                    ..
        lda     #$00                            ; A343 A9 00                    ..
        sta     SCROLL_X_LO                             ; A345 85 7B                    .{
        sta     PX_LO                             ; A347 85 43                    .C
        lda     #$10                            ; A349 A9 10                    ..
        sta     SCROLL_X_HI                             ; A34B 85 7C                    .|
        
		; setup jump to LOAD_GRAPHICS_FOR_MAP_LEVEL: ; $c5cb
		lda     #$CB                            ; A34D A9 CB                    ..
        sta     JMP_DEST_0E_LO                             ; A34F 85 0E                    ..
        lda     #$C5                            ; A351 A9 C5                    ..
        sta     JMP_DEST_0F_HI                             ; A353 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A355 20 E4 CC                  ..
        
		ldx     #$04                            ; A358 A2 04                    ..
        ; setup jump to $c540 (FLASH_EFFECT_C540)
		lda     #$40                            ; A35A A9 40                    .@
        sta     JMP_DEST_0E_LO                             ; A35C 85 0E                    ..
        lda     #$C5                            ; A35E A9 C5                    ..
        sta     JMP_DEST_0F_HI                             ; A360 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A362 20 E4 CC                  ..
        
		lda     #$00                            ; A365 A9 00                    ..
        sta     SCROLL_X_HI                             ; A367 85 7C                    .|
        
		; setup jump to $c76c: UPDATE_PPU_ADDRESS_FROM_SCROLL
		lda     #$6C                            ; A369 A9 6C                    .l
        sta     JMP_DEST_0E_LO                             ; A36B 85 0E                    ..
        lda     #$C7                            ; A36D A9 C7                    ..
        sta     JMP_DEST_0F_HI                             ; A36F 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A371 20 E4 CC                  ..
        
		; changing the pattern table makes the dragon appear brighter/alive
		lda     #$3D                            ; A374 A9 3D                    .=
        sta     CHR_BANK_ENEMY_SPRITES                             ; A376 85 2D                    .-

DRAGON_DROP_TO_GROUND:
		; dragon drops to ground
		; PPU_SCROLL_Y decreases from x22 --> xC2 which slides the dragon down onscreen
        ldx     PPU_SCROLL_Y                             ; A378 A6 1E                    ..
        
		; branch if x <> 0
		bne     LA37E                           ; A37A D0 02                    ..
        
		; x=0; scroll y is now 0 and we reset to xF0 for continuity
		ldx     #$F0                            ; A37C A2 F0                    ..
LA37E:
        cpx     #$C2                            ; A37E E0 C2                    ..
        
		; branch if x=xC2
		beq     DRAGON_INTRO_ON_GROUND                           ; A380 F0 13                    ..
        
		; decrement x and save to PPU_SCROLL_Y - this will shift Dragon down on screen
		dex                                     ; A382 CA                       .
        stx     PPU_SCROLL_Y                             ; A383 86 1E                    ..
        
		; convert x to 0 or 1 every 8 loops and store to PPU_NAMETABLE_SELECT
		txa                                     ; A385 8A                       .
        
		; a = 0 or 8; then divide by 8 to get 0 or 1
		; this animates the dragon by swapping nametables back and forth
		and     #$08                            ; A386 29 08                    ).
        lsr     a                               ; A388 4A                       J
        lsr     a                               ; A389 4A                       J
        lsr     a                               ; A38A 4A                       J
        sta     PPU_NAMETABLE_SELECT                             ; A38B 85 1D                    ..
        lda     #$FF                            ; A38D A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; A38F 20 8F CC                  ..
        
		; loop
		jmp     DRAGON_DROP_TO_GROUND                           ; A392 4C 78 A3                 Lx.

; ----------------------------------------------------------------------------
; Dragon fight - ready for actual combat
; The dragon is animated when counter $FA hits 0, every 10 frames.
; Basic animation occurs via PPU_NAMETABLE_SELECT, which swaps nametables to 
; alternate between two states. 
DRAGON_INTRO_ON_GROUND:
        ; setup jump to $c540 (FLASH_EFFECT_C540)
		ldx     #$02                            ; A395 A2 02                    ..
        lda     #$40                            ; A397 A9 40                    .@
        sta     JMP_DEST_0E_LO                             ; A399 85 0E                    ..
        lda     #$C5                            ; A39B A9 C5                    ..
        sta     JMP_DEST_0F_HI                             ; A39D 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A39F 20 E4 CC                  ..
        
		; setup jump to UPDATE_PPU_SCROLL_X: $c1c7
		lda     #$C7                            ; A3A2 A9 C7                    ..
        sta     JMP_DEST_0E_LO                             ; A3A4 85 0E                    ..
        lda     #$C1                            ; A3A6 A9 C1                    ..
        sta     JMP_DEST_0F_HI                             ; A3A8 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A3AA 20 E4 CC                  ..
        
		; initialize the dragon for fighting
		lda     #$00                            ; A3AD A9 00                    ..
        sta     OBJ_X_LO                           ; A3AF 8D 0C 04                 ...
        sta     OBJ_X_HI                           ; A3B2 8D 0D 04                 ...
        sta     OBJ_MISC_CTR                           ; A3B5 8D 06 04                 ...
        sta     DRAGON_STATE_CTR                             ; A3B8 85 E9                    ..
        sta     SCROLL_X_LO                             ; A3BA 85 7B                    .{
        sta     SCROLL_X_HI                             ; A3BC 85 7C                    .|
        
		; 100 hp at start
		lda     #$64                            ; A3BE A9 64                    .d
        sta     OBJ_HP                           ; A3C0 8D 05 04                 ...
        
		; sets the sprite to use for collision checks
		lda     #$08                            ; A3C3 A9 08                    ..
        sta     DRAGON_SPRITE_0_CTR                             ; A3C5 85 3E                    .>
        
		; convert player x position to use single-screen coordinates, i.e. PX_LO 
		; is now the player's screen-x as well
		lda     PX_HI                             ; A3C7 A5 44                    .D
        asl     a                               ; A3C9 0A                       .
        asl     a                               ; A3CA 0A                       .
        asl     a                               ; A3CB 0A                       .
        asl     a                               ; A3CC 0A                       .
        ora     PX_LO                             ; A3CD 05 43                    .C
        sta     PX_LO                             ; A3CF 85 43                    .C
        jsr     DRAW_PLAYER_SINGLE_SCREEN                           ; A3D1 20 7A AD                  z.
        
		; hide player after we just drew it...then draw the life bars
		lda     #OFFSCREEN_Y                            ; A3D4 A9 EF                    ..
        sta     PLAYER_SPRITE_0                           ; A3D6 8D 10 02                 ...
        sta     PLAYER_SPRITE_1                           ; A3D9 8D 14 02                 ...
        jsr     INIT_DRAGON_LIFE_BAR                           ; A3DC 20 D2 A7                  ..
        jsr     INIT_PLAYER_LIFE_BAR                           ; A3DF 20 F0 A7                  ..
        
		; the actual fight is now ready to begin
		rts                                     ; A3E2 60                       `

; ----------------------------------------------------------------------------
; If dragon has hp, checks for damage; if not jump to DRAGON_NO_HP $a3e3
CHECK_DRAGON_DAMAGE:
        ; $a3e3 
		; set object slot to $0400 and load working object - i.e. dragon is in object slot 0
		lda     #$00                            ; A3E3 A9 00                    ..
        sta     CUR_OBJ_PTR_LO                             ; A3E5 85 E5                    ..
        lda     #$04                            ; A3E7 A9 04                    ..
        sta     CUR_OBJ_PTR_HI                             ; A3E9 85 E6                    ..
        jsr     LOAD_CUR_OBJ                           ; A3EB 20 8F E9                  ..
        
		; branch if dragon has hp
		lda     CUR_OBJ_HP                             ; A3EE A5 F2                    ..
        bne     DRAGON_CHECK_PROJECTILE_HITS                           ; A3F0 D0 03                    ..
        
		; dragon has no hp
		jmp     DRAGON_NO_HP                           ; A3F2 4C FF A7                 L..

; ----------------------------------------------------------------------------
;
; The dragon fight uses sprite 0 hit checks (sprite in the $0200 position is checked
; for a collision with the background - see https://www.nesdev.org/wiki/PPU_OAM#Sprite_0_hits).
; 
; To do this, DRAGON_SPRITE_0_CTR decrements each from, in loops from 7 to 0. The value determines
; which sprite it will check for a hit - player (6,7) or one of the projectiles. So, the left half of
; e.g. the player will get checked on frame 1, and the right half on frame 2!
;		
; The logic below, then, converts the DRAGON_SPRITE_0_CTR to an object slot if it gets a sprite 0 hit
; - that is the object that hit the dragon. If it's a projectile, and is hitting the dragon in its 
; vulnerable region, the dragon takes damage.
;
DRAGON_CHECK_PROJECTILE_HITS:
		
        ; branch if no sprite 0 hit	
		bit     PPU_STAT_COPY                             ; A3F5 24 26                    $&
        bvc     LA43C                           ; A3F7 50 43                    PC
        
		; sprite 0 hit
		; FIRST_OBJECT decrements from 7 to 0 so logic below will branch if it's 6 or 7
		ldx     DRAGON_SPRITE_0_CTR                             ; A3F9 A6 3E                    .>
        inx                                     ; A3FB E8                       .
        inx                                     ; A3FC E8                       .
        txa                                     ; A3FD 8A                       .
        and     #$06                            ; A3FE 29 06                    ).
		beq     LA43C                           ; A400 F0 3A                    .:
        
		; a = 2, 4, or 6; multiplying by 8 gets an offset to object slots 1, 2, or 3: the player projectiles
		asl     a                               ; A402 0A                       .
        asl     a                               ; A403 0A                       .
        asl     a                               ; A404 0A                       .
        tax                                     ; A405 AA                       .
        
		; branch if blank
		lda     OBJ_GENERAL_TYPE,x                         ; A406 BD 01 04                 ...
        beq     LA43C                           ; A409 F0 31                    .1
        
		; not blank - a dragon slayer projectile has hit the dragon; clear it
		lda     #OBJ_GEN_TYPE_BLANK                           ; A40B A9 00                    ..
        sta     OBJ_GENERAL_TYPE,x                         ; A40D 9D 01 04                 ...
        
		; check if the projectile damages the dragon
		; scroll x + obj x must be between xB0-xCF - so you can't score a hit on e.g. the tail
		lda     PPU_SCROLL_X                             ; A410 A5 1C                    ..
        clc                                     ; A412 18                       .
        adc     OBJ_X_LO,x                         ; A413 7D 0C 04                 }..

		; branch if too far left (face, front claws)
        cmp     #$B0                            ; A416 C9 B0                    ..
        bcc     LA437                           ; A418 90 1D                    ..
        
		; now branch if too far right (tail)
		cmp     #$D0                            ; A41A C9 D0                    ..
        bcs     LA437                           ; A41C B0 19                    ..
        
		; Hit! Apply damage and branch if dragon hp were >= 2
		lda     CUR_OBJ_HP                             ; A41E A5 F2                    ..
        sec                                     ; A420 38                       8
        sbc     #$02                            ; A421 E9 02                    ..
        bcs     LA427                           ; A423 B0 02                    ..
        
		; else set to 0 to prevent hp going negative
		lda     #$00                         ; A425 A9 00                    ..
; ----------------------------------------------------------------------------
LA427:
		; save the damage and update life bar
        sta     CUR_OBJ_HP                             ; A427 85 F2                    ..
        jsr     DRAW_DRAGON_LIFE_BAR                           ; A429 20 69 CB                  i.
        
		; dragon roars defiance
		lda     #SOUND_DRAGON                            ; A42C A9 20                    . 
        sta     NEXT_SOUND_EFFECT                             ; A42E 85 8F                    ..
        lda     #$01                            ; A430 A9 01                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; A432 85 90                    ..
        jmp     LA43C                           ; A434 4C 3C A4                 L<.

; ----------------------------------------------------------------------------
LA437:
		; we've hit the dragon but did no damage - play shield sound effect
        lda     #SOUND_SHIELD_HIT                            ; A437 A9 01                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; A439 8D 8F 00                 ...
LA43C:
		; DRAGON_ACTION_CTR is used as the dragon's frame counter; dragon will do something when it hits 0, every 10 frames
        lda     DRAGON_ACTION_CTR                             ; A43C A5 FA                    ..
        beq     DRAGON_NEXT_ACTION                           ; A43E F0 03                    ..
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A440 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
DRAGON_NEXT_ACTION:
		; branch based on the dragon state
        ldx     DRAGON_STATE                             ; A443 A6 F3                    ..
        
		; branch if state = 0 / DRAGON_STATE_TRANSITION_CHECK
		beq     LA45F                           ; A445 F0 18                    ..
        
		; state = 1/ DRAGON_STATE_WALK_1
		dex                                     ; A447 CA                       .
        beq     LA45C                           ; A448 F0 12                    ..
        
		; state = 2/ DRAGON_STATE_BREATHE
		dex                                     ; A44A CA                       .
        beq     LA459                           ; A44B F0 0C                    ..
        
		; state = 3/ DRAGON_STATE_FLY
		dex                                     ; A44D CA                       .
        beq     LA456                           ; A44E F0 06                    ..
        
		; state=5+ - same as if it was 0
		dex                                     ; A450 CA                       .
        bne     LA45F                           ; A451 D0 0C                    ..
        
		; state=4 / DRAGON_STATE_LAND
		jmp     DRAGON_LANDING_UPDATE                           ; A453 4C 49 A5                 LI.

; ----------------------------------------------------------------------------
LA456:
		; state=3
        jmp     DRAGON_FLY_BACK_UPDATE                           ; A456 4C F0 A4                 L..

; ----------------------------------------------------------------------------
LA459:
		; state=2
        jmp     DRAGON_BREATHE_FIRE_UPDATE                           ; A459 4C CF A4                 L..

; ----------------------------------------------------------------------------
LA45C:
		; state=1
        jmp     DRAGON_WALK_1_UPDATE                           ; A45C 4C A6 A4                 L..

; ----------------------------------------------------------------------------
LA45F:  ; state=0 or 5+
        jmp     DRAGON_CHECK_STATE_CHANGE                           ; A45F 4C 62 A4                 Lb.

; ----------------------------------------------------------------------------
; DRAGON_STATE_TRANSITION_CHECK - this is the base state where the dragon doesn't
; take any actions but can transition into one of the other states		
; dragon checks if it needs to transition to other states based on position
; Fly back - if player is to the right or overlapping dragon, or if dragon has walked all the way left
; Breathe - if player is just to the left of the dragon
; Walk-1 - if player is left of dragon, outside of fire range and dragon is not all the way left
DRAGON_CHECK_STATE_CHANGE:
        ; branch if player to right of dragon
		lda     PPU_SCROLL_X                             ; A462 A5 1C                    ..
        clc                                     ; A464 18                       .
        adc     PX_LO                             ; A465 65 43                    eC
        bcs     DRAGON_FLY_BACK_START                           ; A467 B0 23                    .#
        
		; branch if player overlapping dragon (feet to tail)
		cmp     #$C0                            ; A469 C9 C0                    ..
        bcs     DRAGON_FLY_BACK_START                           ; A46B B0 1F                    ..
        
		; branch if dragon all the way left
		ldx     PPU_SCROLL_X                             ; A46D A6 1C                    ..
        cpx     #$40                            ; A46F E0 40                    .@
        bcs     DRAGON_FLY_BACK_START                           ; A471 B0 19                    ..
        
		; branch if player overlapping dragon (front feet)
		cmp     #$A0                            ; A473 C9 A0                    ..
        bcs     LA47B                           ; A475 B0 04                    ..
        
		; branch (breathe) if player just in front of dragon
		cmp     #$80                            ; A477 C9 80                    ..
        bcs     DRAGON_BREATHE_FIRE_START                           ; A479 B0 1C                    ..

LA47B:
        ; branch if y scroll >= xC3 (dragon flying) - keep flying
		lda     PPU_SCROLL_Y                             ; A47B A5 1E                    ..
        cmp     #$C3                            ; A47D C9 C3                    ..
        bcs     DRAGON_FLY_BACK_START                           ; A47F B0 0B                    ..
        
		; on the ground, player to left of dragon outside of fire range - walk left
		lda     #DRAGON_STATE_WALK_1                            ; A481 A9 01                    ..
        sta     DRAGON_STATE                             ; A483 85 F3                    ..
        lda     #$04                            ; A485 A9 04                    ..
        sta     DRAGON_STATE_CTR                             ; A487 85 E9                    ..
        jmp     DRAGON_WALK_1_UPDATE                           ; A489 4C A6 A4                 L..

; ----------------------------------------------------------------------------
DRAGON_FLY_BACK_START:
        ; change states to fly back toward the right side
        lda     #DRAGON_STATE_FLY                            ; A48C A9 03                    ..
        sta     DRAGON_STATE                             ; A48E 85 F3                    ..
        lda     #$02                            ; A490 A9 02                    ..
        sta     DRAGON_STATE_CTR                             ; A492 85 E9                    ..
        jmp     DRAGON_FLY_BACK_UPDATE                           ; A494 4C F0 A4                 L..

; ----------------------------------------------------------------------------
DRAGON_BREATHE_FIRE_START:
		; change state to breathe fire
        lda     #DRAGON_STATE_BREATHE                            ; A497 A9 02                    ..
        sta     DRAGON_STATE                             ; A499 85 F3                    ..
        lda     #$08                            ; A49B A9 08                    ..
        sta     DRAGON_STATE_CTR                             ; A49D 85 E9                    ..
        
		; change tile defs to show pre-fire-breathing state
		lda     #$B3                            ; A49F A9 B3                    ..
        sta     TILE_DEFS_HI                             ; A4A1 85 7A                    .z
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A4A3 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
; dragon just moves left
DRAGON_WALK_1_UPDATE:
        ; branch (reset state and save) if DRAGON_STATE_CTR = 0
		dec     DRAGON_STATE_CTR                             ; A4A6 C6 E9                    ..
        beq     DRAGON_WALK_1_EXIT                           ; A4A8 F0 1E                    ..
        
		; else set tile defs to $b0 or $b1 depending on carry 
		lda     DRAGON_STATE_CTR                             ; A4AA A5 E9                    ..
        asl     a                               ; A4AC 0A                       .
        and     #$01                            ; A4AD 29 01                    ).
        clc                                     ; A4AF 18                       .
        adc     #$A0                            ; A4B0 69 A0                    i.
        adc     #$10                            ; A4B2 69 10                    i.
        sta     TILE_DEFS_HI                             ; A4B4 85 7A                    .z
        
		; add 4 to scroll x = dragon moves left on screen
		lda     PPU_SCROLL_X                             ; A4B6 A5 1C                    ..
        clc                                     ; A4B8 18                       .
        adc     #$04                            ; A4B9 69 04                    i.
        sta     PPU_SCROLL_X                             ; A4BB 85 1C                    ..
        
		; branch (clear state and save) if x scroll >= x40 (dragon all the way left)
		cmp     #$40                            ; A4BD C9 40                    .@
        bcs     DRAGON_WALK_1_EXIT                           ; A4BF B0 07                    ..
        
		; x scroll < x40; set y scroll (dragon on the ground)
		lda     #$C2                            ; A4C1 A9 C2                    ..
        sta     PPU_SCROLL_Y                             ; A4C3 85 1E                    ..
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A4C5 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
DRAGON_WALK_1_EXIT:
		; reset state and save
        lda     #DRAGON_STATE_TRANSITION_CHECK                            ; A4C8 A9 00                    ..
        sta     DRAGON_STATE                             ; A4CA 85 F3                    ..
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A4CC 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
DRAGON_BREATHE_FIRE_UPDATE:
        ; dec DRAGON_STATE_CTR and branch if 0 
		dec     DRAGON_STATE_CTR                             ; A4CF C6 E9                    ..
        beq     DRAGON_BREATHE_FIRE_EXIT                           ; A4D1 F0 12                    ..
        
		; set tileset for actually breathing fire
		lda     #$B4                            ; A4D3 A9 B4                    ..
        sta     TILE_DEFS_HI                             ; A4D5 85 7A                    .z
        
		; branch if scroll_y < xC3, dragon is on the ground
		lda     PPU_SCROLL_Y                             ; A4D7 A5 1E                    ..
        cmp     #$C3                            ; A4D9 C9 C3                    ..
        bcc     LA4E2                           ; A4DB 90 05                    ..
        
		; scroll is >= xC3; dragon is off the ground - descend by 4 pixels
		sec                                     ; A4DD 38                       8
        sbc     #$04                            ; A4DE E9 04                    ..
        sta     PPU_SCROLL_Y                             ; A4E0 85 1E                    ..
LA4E2:
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A4E2 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
DRAGON_BREATHE_FIRE_EXIT:
		; DRAGON_STATE_CTR is used completely differently than for normal levels!!
		; here if DRAGON_STATE_CTR was 0 - change tile defs, reset state
        lda     #$B3                            ; A4E5 A9 B3                    ..
        sta     TILE_DEFS_HI                             ; A4E7 85 7A                    .z
        lda     #DRAGON_STATE_TRANSITION_CHECK                       ; A4E9 A9 00                    ..
        sta     DRAGON_STATE                             ; A4EB 85 F3                    ..
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A4ED 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
DRAGON_FLY_BACK_UPDATE:
        ; dec DRAGON_STATE_CTR and branch if 0 
		dec     DRAGON_STATE_CTR                             ; A4F0 C6 E9                    ..
        beq     DRAGON_FLY_BACK_EXIT                           ; A4F2 F0 3D                    .=
        
		; ctr <> 0; tile defs --> xB2 to show flight
		lda     #$B2                            ; A4F4 A9 B2                    ..
        sta     TILE_DEFS_HI                             ; A4F6 85 7A                    .z
        
		; branch if x scroll = 0 (all the way right)
		lda     PPU_SCROLL_X                             ; A4F8 A5 1C                    ..
        beq     LA509                           ; A4FA F0 0D                    ..
        
		; else subtract 4 (dragon moves right) and if still >= 0 branch
		sec                                     ; A4FC 38                       8
        sbc     #$04                            ; A4FD E9 04                    ..
        bcs     LA503                           ; A4FF B0 02                    ..
        
		; else, set to 0
		lda     #$00                            ; A501 A9 00                    ..
LA503:
        sta     PPU_SCROLL_X                             ; A503 85 1C                    ..
        
		; branch if x scroll >= x11 - dragon >1 block from right of screen
		cmp     #$11                            ; A505 C9 11                    ..
        bcs     LA517                           ; A507 B0 0E                    ..
LA509:
		; dragon is <17px from right edge of screen; start descending
		; branch if scroll y < xc3 (dragon on ground)
        lda     PPU_SCROLL_Y                             ; A509 A5 1E                    ..
        cmp     #$C3                            ; A50B C9 C3                    ..
        bcc     LA52E                           ; A50D 90 1F                    ..
        
		; subtract from y scroll - dragon falls
		sec                                     ; A50F 38                       8
        sbc     #$04                            ; A510 E9 04                    ..
        sta     PPU_SCROLL_Y                             ; A512 85 1E                    ..
        jmp     LA52E                           ; A514 4C 2E A5                 L..

; ----------------------------------------------------------------------------
LA517:
		; dragon is >= 17 px from right side; can still ascend
		; branch if y scroll < xD2 - not yet at top of arc
        lda     PPU_SCROLL_Y                             ; A517 A5 1E                    ..
        cmp     #$D2                            ; A519 C9 D2                    ..
        bcc     LA529                           ; A51B 90 0C                    ..
        
		; at top of arc; branch (no movement) if at right edge of screen
		lda     PPU_SCROLL_X                             ; A51D A5 1C                    ..
        beq     LA52E                           ; A51F F0 0D                    ..
        
		; otherwise, subtract from scroll x (dragon moves right)
		sec                                     ; A521 38                       8
        sbc     #$04                            ; A522 E9 04                    ..
        sta     PPU_SCROLL_X                             ; A524 85 1C                    ..
        jmp     LA52E                           ; A526 4C 2E A5                 L..

; ----------------------------------------------------------------------------
LA529:
		; add to scroll y (dragon rises)
        clc                                     ; A529 18                       .
        adc     #$04                            ; A52A 69 04                    i.
        sta     PPU_SCROLL_Y                             ; A52C 85 1E                    ..
LA52E:
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A52E 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
DRAGON_FLY_BACK_EXIT:
		; here if DRAGON_STATE_CTR was 0; inc dragon state (to DRAGON_STATE_LAND) if dragon all the way right
        lda     PPU_SCROLL_X                             ; A531 A5 1C                    ..
        beq     DRAGON_LANDING_START                           ; A533 F0 07                    ..
        
		; else reset state and save
		lda     #DRAGON_STATE_TRANSITION_CHECK                            ; A535 A9 00                    ..
        sta     DRAGON_STATE                             ; A537 85 F3                    ..
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A539 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
DRAGON_LANDING_START:
		; tile defs --> B0 (landing pose)
        lda     #$B0                            ; A53C A9 B0                    ..
        sta     TILE_DEFS_HI                             ; A53E 85 7A                    .z
        
		; advance dragon state --> DRAGON_STATE_LAND
		inc     DRAGON_STATE                             ; A540 E6 F3                    ..
        lda     #$04                            ; A542 A9 04                    ..
        sta     DRAGON_STATE_CTR                             ; A544 85 E9                    ..
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A546 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
; we jump down here when the dragon is landing at the right side of the screen
; it just does a little animation and roars
DRAGON_LANDING_UPDATE:
        ; dec DRAGON_STATE_CTR and branch if it's now 0
		dec     DRAGON_STATE_CTR                             ; A549 C6 E9                    ..
        beq     DRAGON_LANDING_EXIT                           ; A54B F0 15                    ..
        
		; now branch if it <> 4
		lda     DRAGON_STATE_CTR                             ; A54D A5 E9                    ..
        cmp     #$04                            ; A54F C9 04                    ..
        bne     LA557                           ; A551 D0 04                    ..
        
		; DRAGON_STATE_CTR = 4; make some noise...
		lda     #SOUND_DRAGON                            ; A553 A9 20                    . 
        sta     NEXT_SOUND_EFFECT                             ; A555 85 8F                    ..
LA557:
		; animate landing, set scroll y so we're on the ground
        lda     #$B5                            ; A557 A9 B5                    ..
        sta     TILE_DEFS_HI                             ; A559 85 7A                    .z
        lda     #$C2                            ; A55B A9 C2                    ..
        sta     PPU_SCROLL_Y                             ; A55D 85 1E                    ..
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A55F 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------
DRAGON_LANDING_EXIT:
		; swap to tile def xB3 to animate the dragon, and reset its DRAGON_STATE
        lda     #$B3                            ; A562 A9 B3                    ..
        sta     TILE_DEFS_HI                             ; A564 85 7A                    .z
        lda     #DRAGON_STATE_TRANSITION_CHECK                            ; A566 A9 00                    ..
        sta     DRAGON_STATE                             ; A568 85 F3                    ..
        jmp     DRAGON_UPDATE_GRAPHICS_AND_SAVE                           ; A56A 4C 6D A5                 Lm.

; ----------------------------------------------------------------------------

; dragon final update and save
DRAGON_UPDATE_GRAPHICS_AND_SAVE:
        jsr     DRAGON_UPDATE_GRAPHICS                           ; A56D 20 74 A5                  t.
        jsr     SAVE_CUR_OBJ                           ; A570 20 9A E9                  ..
        rts                                     ; A573 60                       `

; ----------------------------------------------------------------------------

DRAGON_UPDATE_GRAPHICS:
        ; branch if DRAGON_ACTION_CTR <> 0
		lda     DRAGON_ACTION_CTR                             ; A574 A5 FA                    ..
        bne     LA59D                           ; A576 D0 25                    .%
        
		; DRAGON_ACTION_CTR = 0; set PPU addr to $200E (nametable 0)
		lda     #$0E                            ; A578 A9 0E                    ..
        sta     PPU_WRITE_LO                             ; A57A 85 16                    ..
        lda     #$20                            ; A57C A9 20                    . 
        sta     PPU_WRITE_HI                             ; A57E 85 17                    ..
        
		; flip the toggle, mult by 4 and so maybe set bit 2, so PPU_WRITE_HI will
		; be x20 or x24, basically swapping nametable
		lda     PPU_NAMETABLE_SELECT                             ; A580 A5 1D                    ..
        eor     #$01                            ; A582 49 01                    I.
        asl     a                               ; A584 0A                       .
        asl     a                               ; A585 0A                       .
        ora     PPU_WRITE_HI                             ; A586 05 17                    ..
        sta     PPU_WRITE_HI                             ; A588 85 17                    ..
        
		; flip toggle, mult by 16, add 7, and ORA with SCROLL_X_HI --> CUR_OBJ_NEXT_X
		lda     PPU_NAMETABLE_SELECT                             ; A58A A5 1D                    ..
        eor     #$01                            ; A58C 49 01                    I.
        asl     a                               ; A58E 0A                       .
        asl     a                               ; A58F 0A                       .
        asl     a                               ; A590 0A                       .
        asl     a                               ; A591 0A                       .
        clc                                     ; A592 18                       .
        adc     #$07                            ; A593 69 07                    i.
        ora     SCROLL_X_HI                             ; A595 05 7C                    .|
        sta     CUR_OBJ_NEXT_X                             ; A597 85 F9                    ..
        
		; set DRAGON_ACTION_CTR --> 9
		lda     #$09                            ; A599 A9 09                    ..
        sta     DRAGON_ACTION_CTR                             ; A59B 85 FA                    ..
LA59D:
        ; save next x to SCRATCH_0C (is it ever read?)
		lda     CUR_OBJ_NEXT_X                             ; A59D A5 F9                    ..
        sta     SCRATCH_0C                             ; A59F 85 0C                    ..
        
		; write the new graphics, dec DRAGON_ACTION_CTR; if 0 flip toggle
		jsr     UPDATE_MAP_DATA_FROM_SCROLL                           ; A5A1 20 33 C8                  3.
        inc     PPU_WRITE_LO                             ; A5A4 E6 16                    ..
        inc     PPU_WRITE_LO                             ; A5A6 E6 16                    ..
        inc     CUR_OBJ_NEXT_X                             ; A5A8 E6 F9                    ..
        dec     DRAGON_ACTION_CTR                             ; A5AA C6 FA                    ..
        bne     LA5B4                           ; A5AC D0 06                    ..
        
		; DRAGON_ACTION_CTR = 0; flip the PPU toggle
		lda     PPU_NAMETABLE_SELECT                             ; A5AE A5 1D                    ..
        eor     #$01                            ; A5B0 49 01                    I.
        sta     PPU_NAMETABLE_SELECT                             ; A5B2 85 1D                    ..
LA5B4:
        rts                                     ; A5B4 60                       `

; ----------------------------------------------------------------------------
; 4 step palette fade-out, 5 frame wait between each
; only used for dragon fight
DRAGON_PALETTE_FADEOUT:
	; updates values from DATA_BUFFER_0180 0-c
		; y=4, push it onto stack
        ldy     #$04                            ; A5B5 A0 04                    ..
LA5B7:
        tya                                     ; A5B7 98                       .
        pha                                     ; A5B8 48                       H
        
		; wait 5 frames between each step in the fade
		lda     #$05                            ; A5B9 A9 05                    ..
        sta     NMI_WAIT_CTR                             ; A5BB 85 36                    .6
        ldx     #$0C                            ; A5BD A2 0C                    ..
LA5BF:
        lda     DATA_BUFFER_0180,x                         ; A5BF BD 80 01                 ...
        and     #$0F                            ; A5C2 29 0F                    ).
        sta     SCRATCH_08                             ; A5C4 85 08                    ..
        lda     DATA_BUFFER_0180,x                         ; A5C6 BD 80 01                 ...
        and     #$F0                            ; A5C9 29 F0                    ).
        sec                                     ; A5CB 38                       8
        sbc     #$10                            ; A5CC E9 10                    ..
        
		; branch if upper nibble DATA_BUFFER_0180,x >= 10; will ORA SCRATCH_08
		bcs     LA5D5                           ; A5CE B0 05                    ..
        
		; else a --> xF and jump
		lda     #$0F                            ; A5D0 A9 0F                    ..
        jmp     LA5D7                           ; A5D2 4C D7 A5                 L..

; ----------------------------------------------------------------------------
LA5D5:
        ora     SCRATCH_08                             ; A5D5 05 08                    ..
LA5D7:
		; store new value
        sta     DATA_BUFFER_0180,x                         ; A5D7 9D 80 01                 ...
        dex                                     ; A5DA CA                       .
        
		; loop while x >= 0
		bpl     LA5BF                           ; A5DB 10 E2                    ..
        
		; now, the NMI will update the palette and we'll wait 5 frames
		jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; A5DD 20 35 C1                  5.
        
		; restore our y counter from stack (initially 4)
		pla                                     ; A5E0 68                       h
        tay                                     ; A5E1 A8                       .
        dey                                     ; A5E2 88                       .
        
		; loop until y=0
		bne     LA5B7                           ; A5E3 D0 D2                    ..
        rts                                     ; A5E5 60                       `

; ----------------------------------------------------------------------------
; $a5e6 - indirect jump here only from START_DRAGON_FIGHT
; during dragon fight, handles input for firing projectiles as
; well as placing and moving them. Projectiles can be in 
; object slots 1-4
DRAGONSLAYER_FIRE_AND_UPDATE: ; $a5e6

        ; set CUR_OBJ_SLOT_NUM
		lda     #$01                            ; A5E6 A9 01                    ..
        sta     CUR_OBJ_SLOT_NUM                             ; A5E8 85 E3                    ..
        
		; object is at $0410
		lda     #$10                            ; A5EA A9 10                    ..
        sta     CUR_OBJ_PTR_LO                             ; A5EC 85 E5                    ..
        lda     #$04                            ; A5EE A9 04                    ..
        sta     CUR_OBJ_PTR_HI                             ; A5F0 85 E6                    ..
LA5F2:
        ; acess OBJ_GEN_TYPE for slot; branch if slot not empty
		ldy     #$01                            ; A5F2 A0 01                    ..
        lda     (CUR_OBJ_PTR_LO),y                         ; A5F4 B1 E5                    ..
        bne     LA606                           ; A5F6 D0 0E                    ..
        
		; slot is empty; branch if B is not pressed (0x40)
		bit     JOYPAD_INPUT                             ; A5F8 24 20                    $ 
        bvc     LA609                           ; A5FA 50 0D                    P.
        
		; B is pressed; branch if it was also pressed previously
		bit     JOYPAD_INPUT_REFERENCE                             ; A5FC 24 FD                    $.
        bvs     LA609                           ; A5FE 70 09                    p.
        
		; B is newly pressed - fire dragon slayer
		jsr     FIRE_DRAGON_SLAYER                           ; A600 20 22 A6                  ".
        jmp     LA609                           ; A603 4C 09 A6                 L..

; ----------------------------------------------------------------------------
LA606:
        jsr     DRAGON_FIGHT_UPDATE_CURRENT_OBJECT                           ; A606 20 57 A6                  W.
LA609:
		; advance to the next slot in the object array
        inc     CUR_OBJ_SLOT_NUM                             ; A609 E6 E3                    ..
        clc                                     ; A60B 18                       .
        lda     #$10                            ; A60C A9 10                    ..
        adc     CUR_OBJ_PTR_LO                             ; A60E 65 E5                    e.
        sta     CUR_OBJ_PTR_LO                             ; A610 85 E5                    ..
        lda     #$00                            ; A612 A9 00                    ..
        adc     CUR_OBJ_PTR_HI                             ; A614 65 E6                    e.
        sta     CUR_OBJ_PTR_HI                             ; A616 85 E6                    ..
        
		; loop if CUR_OBJ_SLOT_NUM < 4
		lda     CUR_OBJ_SLOT_NUM                             ; A618 A5 E3                    ..
        cmp     #$04                            ; A61A C9 04                    ..
        bcc     LA5F2                           ; A61C 90 D4                    ..
        
		; else we're done firing new projectiles; draw them
		jsr     DRAW_DRAGONSLAYER_PROJECTILES                           ; A61E 20 E0 A6                  ..
        rts                                     ; A621 60                       `

; ----------------------------------------------------------------------------
; fires the dragon slayer - during the dragon fight
FIRE_DRAGON_SLAYER:
        ; make a copy of this slot
		jsr     LOAD_CUR_OBJ                           ; A622 20 8F E9                  ..
        
		; if B is pressed, ensure bit 6 is set in JOYPAD_INPUT_REFERENCE - prevents multiple firings
		; on a single frame or by holding down b
		lda     JOYPAD_INPUT                             ; A625 A5 20                    . 
        and     #$40                            ; A627 29 40                    )@
        ora     JOYPAD_INPUT_REFERENCE                             ; A629 05 FD                    ..
        sta     JOYPAD_INPUT_REFERENCE                             ; A62B 85 FD                    ..
        
		; calculate movement
		lda     JOYPAD_INPUT_REFERENCE                             ; A62D A5 FD                    ..
        ldy     #$02                            ; A62F A0 02                    ..
        jsr     DRAGON_FIGHT_CALC_MOVE_VECTOR                           ; A631 20 B1 A7                  ..
        jsr     CALC_DRAGON_SLAYER_PROJ_INIT_POS                           ; A634 20 83 A6                  ..
        
		; branch if player oob for firing
		jsr     CHECK_CAN_FIRE_DRAGON_SLAYER                           ; A637 20 B1 A6                  ..
        bcs     LA678                           ; A63A B0 3C                    .<
        
		; otherwise, place the projectile
		lda     TEMP_NEXT_X_LO                             ; A63C A5 0E                    ..
        sta     CUR_OBJ_NEXT_X                             ; A63E 85 F9                    ..
        lda     TEMP_NEXT_Y                             ; A640 A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; A642 85 FB                    ..
        lda     #OBJ_GEN_TYPE_PROJECTILE                            ; A644 A9 18                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; A646 85 EE                    ..
        lda     #$00                            ; A648 A9 00                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; A64A 85 EF                    ..
        lda     #$21                            ; A64C A9 21                    .!
        sta     CUR_OBJ_SPRITE                             ; A64E 85 ED                    ..
        
		; Dragon Slayer uses the same firing sound as Pochi
		lda     #SOUND_POCHI_SHOT                            ; A650 A9 19                    ..
        sta     NEXT_SOUND_EFFECT                             ; A652 85 8F                    ..
        jmp     LA678                           ; A654 4C 78 A6                 Lx.

; ----------------------------------------------------------------------------
DRAGON_FIGHT_UPDATE_CURRENT_OBJECT:
        ; load current object, decrement its GEN_TYPE, branch if now 0
		; we then just save the object, effectively erasing an enemy if there was one there
		jsr     LOAD_CUR_OBJ                           ; A657 20 8F E9                  ..
        dec     CUR_OBJ_GEN_TYPE                             ; A65A C6 EE                    ..
        beq     LA678                           ; A65C F0 1A                    ..
        
		; cur object gen type wasn't 1; have it move and check firing pos
		; branch if can't fire (clear obj)
		jsr     MOVE_DRAGON_SLAYER_PROJ                           ; A65E 20 C5 A6                  ..
		jsr     CHECK_CAN_FIRE_DRAGON_SLAYER                           ; A661 20 B1 A6                  ..
        bcs     LA669                           ; A664 B0 03                    ..
        
		; update location and animate
		jmp     LA670                           ; A666 4C 70 A6                 Lp.

; ----------------------------------------------------------------------------
LA669:
        lda     #OBJ_GEN_TYPE_BLANK                            ; A669 A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; A66B 85 EE                    ..
        jmp     LA678                           ; A66D 4C 78 A6                 Lx.

; ----------------------------------------------------------------------------
LA670:
		; update location
        lda     TEMP_NEXT_X_LO                             ; A670 A5 0E                    ..
        sta     CUR_OBJ_NEXT_X                             ; A672 85 F9                    ..
        lda     TEMP_NEXT_Y                             ; A674 A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; A676 85 FB                    ..
LA678:
        ; branch (do nothing) if blank
		lda     CUR_OBJ_GEN_TYPE                             ; A678 A5 EE                    ..
        beq     LA67F                           ; A67A F0 03                    ..
        
		; not blank - updates sprite
		jsr     ANIMATE_DRAGON_SLAYER_PROJECTILE                           ; A67C 20 A2 A6                  ..
LA67F:
        jsr     SAVE_CUR_OBJ                           ; A67F 20 9A E9                  ..
        rts                                     ; A682 60                       `

; ----------------------------------------------------------------------------
; calculates the initial position for a player projectile
; starts at the player's position, adds 4x the player's current speed
; note if player not moving, or L+R held, will start on player position as dx and dy=0
CALC_DRAGON_SLAYER_PROJ_INIT_POS:
        lda     PX_LO                             ; A683 A5 43                    .C
        sta     TEMP_NEXT_X_LO                             ; A685 85 0E                    ..
        lda     PY                             ; A687 A5 45                    .E
        sta     TEMP_NEXT_Y                             ; A689 85 0A                    ..
        
		; branch if dy <> 0
		lda     CUR_OBJ_DY                             ; A68B A5 F7                    ..
        beq     LA696                           ; A68D F0 07                    ..
        
		; otherwise, speed = 4 vertical
		asl     a                               ; A68F 0A                       .
        asl     a                               ; A690 0A                       .
        clc                                     ; A691 18                       .
        adc     TEMP_NEXT_Y                             ; A692 65 0A                    e.
        sta     TEMP_NEXT_Y                             ; A694 85 0A                    ..
LA696:
        ; branch if dx <> 0
		lda     CUR_OBJ_DX                             ; A696 A5 F5                    ..
        beq     LA6A1                           ; A698 F0 07                    ..
        
		; otherwise speed = 4 horizontal
		asl     a                               ; A69A 0A                       .
        asl     a                               ; A69B 0A                       .
        clc                                     ; A69C 18                       .
        adc     TEMP_NEXT_X_LO                             ; A69D 65 0E                    e.
        sta     TEMP_NEXT_X_LO                             ; A69F 85 0E                    ..
LA6A1:
        rts                                     ; A6A1 60                       `

; ----------------------------------------------------------------------------
; it just swaps the sprite, so think that's what this is doing?
ANIMATE_DRAGON_SLAYER_PROJECTILE:
        ; CUR_OBJ_GEN_TYPE bits 3-4 saved to SCRATCH_08
		; then applied via ORA to CUR_OBJ_SPRITE
		lda     CUR_OBJ_GEN_TYPE                             ; A6A2 A5 EE                    ..
        and     #$0C                            ; A6A4 29 0C                    ).
        sta     SCRATCH_08                             ; A6A6 85 08                    ..
        lda     CUR_OBJ_SPRITE                             ; A6A8 A5 ED                    ..
        and     #$F3                            ; A6AA 29 F3                    ).
        ora     SCRATCH_08                             ; A6AC 05 08                    ..
        sta     CUR_OBJ_SPRITE                             ; A6AE 85 ED                    ..
        rts                                     ; A6B0 60                       `

; ----------------------------------------------------------------------------
; return - carry clear if player can fire from next pos; otherwise carry set
CHECK_CAN_FIRE_DRAGON_SLAYER:
        ; branch (no fire) if firing into the floor
		lda     TEMP_NEXT_Y                             ; A6B1 A5 0A                    ..
        cmp     #$A1                            ; A6B3 C9 A1                    ..
        bcs     LA6C1                           ; A6B5 B0 0A                    ..
        
		; branch (ok to fire) if not firing off side of screen (note this covers left or right sides)
		lda     TEMP_NEXT_X_LO                             ; A6B7 A5 0E                    ..
        cmp     #$F1                            ; A6B9 C9 F1                    ..
        bcc     LA6C3                           ; A6BB 90 06                    ..
        
		; branch (ok to fire) if at the very left edge of screen
		lda     TEMP_NEXT_X_LO                             ; A6BD A5 0E                    ..
        beq     LA6C3                           ; A6BF F0 02                    ..
LA6C1:
		; oob - can't fire
        sec                                     ; A6C1 38                       8
        rts                                     ; A6C2 60                       `

; ----------------------------------------------------------------------------
LA6C3:
		; ok to fire
        clc                                     ; A6C3 18                       .
        rts                                     ; A6C4 60                       `

; ----------------------------------------------------------------------------
; applys CUR_OBJ_DX and CUR_OBJ_DY to CUR_OBJ's x/y and saves as TEMP_NEXT_Y and TEMP_NEXT_X_LO. 
MOVE_DRAGON_SLAYER_PROJ:
        lda     CUR_OBJ_NEXT_X                             ; A6C5 A5 F9                    ..
        sta     TEMP_NEXT_X_LO                             ; A6C7 85 0E                    ..
        lda     CUR_OBJ_NEXT_Y                             ; A6C9 A5 FB                    ..
        sta     TEMP_NEXT_Y                             ; A6CB 85 0A                    ..
        
		; branch if not moving vertically; else apply DY
		lda     CUR_OBJ_DY                             ; A6CD A5 F7                    ..
        beq     LA6D6                           ; A6CF F0 05                    ..
        clc                                     ; A6D1 18                       .
        adc     TEMP_NEXT_Y                             ; A6D2 65 0A                    e.
        sta     TEMP_NEXT_Y                             ; A6D4 85 0A                    ..
LA6D6:
        ; branch if not moving horizontally, else apply DX
		lda     CUR_OBJ_DX                             ; A6D6 A5 F5                    ..
        beq     LA6DF                           ; A6D8 F0 05                    ..
        clc                                     ; A6DA 18                       .
        adc     TEMP_NEXT_X_LO                             ; A6DB 65 0E                    e.
        sta     TEMP_NEXT_X_LO                             ; A6DD 85 0E                    ..
LA6DF:
        rts                                     ; A6DF 60                       `

; ----------------------------------------------------------------------------
DRAW_DRAGONSLAYER_PROJECTILES:
		; drawing slots x11-13 using sprite ram $0288+
        lda     #$88                            ; A6E0 A9 88                    ..
        sta     TEMP_SPRITE_RAM_OFFSET_X                             ; A6E2 85 0F                    ..
        lda     #$10                            ; A6E4 A9 10                    ..
        sta     TEMP_DRAW_SLOT                             ; A6E6 85 0E                    ..
        lda     #$03                            ; A6E8 A9 03                    ..
LA6EA:
		; 3 loops adding 8 to HI and x10 to LO
        pha                                     ; A6EA 48                       H
        jsr     DRAW_DRAGONSLAYER_PROJECTILE                           ; A6EB 20 03 A7                  ..
        
		; advance to next set of sprite positions, advance slot
		lda     TEMP_SPRITE_RAM_OFFSET_X                             ; A6EE A5 0F                    ..
        clc                                     ; A6F0 18                       .
        adc     #$08                            ; A6F1 69 08                    i.
        sta     TEMP_SPRITE_RAM_OFFSET_X                             ; A6F3 85 0F                    ..
        lda     TEMP_DRAW_SLOT                             ; A6F5 A5 0E                    ..
        clc                                     ; A6F7 18                       .
        adc     #$10                            ; A6F8 69 10                    i.
        sta     TEMP_DRAW_SLOT                             ; A6FA 85 0E                    ..
        
		; loop until a on stack=0
		pla                                     ; A6FC 68                       h
        sec                                     ; A6FD 38                       8
        sbc     #$01                            ; A6FE E9 01                    ..
        bne     LA6EA                           ; A700 D0 E8                    ..
        rts                                     ; A702 60                       `

; ----------------------------------------------------------------------------
DRAW_DRAGONSLAYER_PROJECTILE:
		; get our offsets to the correct sprite and object
        ldx     TEMP_SPRITE_RAM_OFFSET_X                             ; A703 A6 0F                    ..
        ldy     TEMP_DRAW_SLOT                             ; A705 A4 0E                    ..
        
		; branch (offscreen) if empty
		lda     OBJ_GENERAL_TYPE,y                         ; A707 B9 01 04                 ...
        beq     LA754                           ; A70A F0 48                    .H
        
		; not empty; branch (offscreen) if >= MAX_SCREEN_Y_POS
		lda     OBJ_Y,y                         ; A70C B9 0E 04                 ...
        cmp     #MAX_SCREEN_Y_POS                            ; A70F C9 BF                    ..
        bcs     LA754                           ; A711 B0 41                    .A
        
		; set flags
		lda     OBJ_SPRITE_FLAGS,y                         ; A713 B9 02 04                 ...
        sta     SPRITE_0_FLAGS,x                         ; A716 9D 02 02                 ...
        sta     SPRITE_0_FLAGS+4,x                         ; A719 9D 06 02                 ...
        and     #$40                            ; A71C 29 40                    )@
        
		; branch if horizontally flipped
		bne     LA72F                           ; A71E D0 0F                    ..
        
		; not horizontally flipped
		; 2nd sprite ID is first one + 2
		lda     OBJ_SPRITE,y                         ; A720 B9 00 04                 ...
        sta     SPRITE_0_ID,x                         ; A723 9D 01 02                 ...
        clc                                     ; A726 18                       .
        adc     #$02                            ; A727 69 02                    i.
        sta     SPRITE_0_ID+4,x                         ; A729 9D 05 02                 ...
        jmp     LA73B                           ; A72C 4C 3B A7                 L;.

; ----------------------------------------------------------------------------
LA72F:
		; horizontally flipped, 1st sprite ID is 2nd one + 2
        lda     OBJ_SPRITE,y                         ; A72F B9 00 04                 ...
        sta     SPRITE_0_ID+4,x                         ; A732 9D 05 02                 ...
        clc                                     ; A735 18                       .
        adc     #$02                            ; A736 69 02                    i.
        sta     SPRITE_0_ID,x                         ; A738 9D 01 02                 ...
LA73B:
		; position the 2 sprites offset by 8 horizontally
        lda     OBJ_X_LO,y                         ; A73B B9 0C 04                 ...
        sta     SPRITE_0_X,x                         ; A73E 9D 03 02                 ...
        clc                                     ; A741 18                       .
        adc     #$08                            ; A742 69 08                    i.
        sta     SPRITE_0_X+4,x                         ; A744 9D 07 02                 ...
        
		; set the y pos - same value for each
		lda     OBJ_Y,y                         ; A747 B9 0E 04                 ...
        clc                                     ; A74A 18                       .
        adc     #OBJ_SCREEN_Y_PAD                            ; A74B 69 2B                    i+
        sta     SPRITE_0_Y,x                         ; A74D 9D 00 02                 ...
        sta     SPRITE_1_Y,x                         ; A750 9D 04 02                 ...
        rts                                     ; A753 60                       `

; ----------------------------------------------------------------------------
LA754:
		; sets the sprite offscreen
        lda     #OFFSCREEN_Y                            ; A754 A9 EF                    ..
        sta     SPRITE_0_Y,x                         ; A756 9D 00 02                 ...
        sta     SPRITE_1_Y,x                         ; A759 9D 04 02                 ...
        rts                                     ; A75C 60                       `

; ----------------------------------------------------------------------------
; copies one (based on DRAGON_SPRITE_0_CTR) from either the $210 or $280 row into the 
; very first sprite slot $200-3. Used only during dragon fight.
; whichever sprite (half an object) is in the 0 slot gets collision check with dragon each frame
DRAGON_FIGHT_COPY_TO_SPRITE_0: ; $a75d
        dec     DRAGON_SPRITE_0_CTR                             ; A75D C6 3E                    .>
        bpl     LA765                           ; A75F 10 04                    ..
        lda     #$07                            ; A761 A9 07                    ..
        sta     DRAGON_SPRITE_0_CTR                             ; A763 85 3E                    .>
LA765:
        ; branch if using player (DRAGON_SPRITE_0_CTR = 0, 1)
		lda     DRAGON_SPRITE_0_CTR                             ; A765 A5 3E                    .>
        and     #$06                            ; A767 29 06                    ).
        beq     LA78E                           ; A769 F0 23                    .#
        
		; using projectile sprite (DRAGON_SPRITE_0_CTR = 2-7)
		; ctr*4 = offset to sprite we'll copy (left or right half of a projectile)
		lda     DRAGON_SPRITE_0_CTR                             ; A76B A5 3E                    .>
        asl     a                               ; A76D 0A                       .
        asl     a                               ; A76E 0A                       .
        tax                                     ; A76F AA                       .
        lda     DRAGON_SLAYER_SPRITE_Y,x                         ; A770 BD 80 02                 ...
        sta     SPRITE_0_Y                           ; A773 8D 00 02                 ...
        lda     DRAGON_SLAYER_SPRITE_Y+1,x                         ; A776 BD 81 02                 ...
        sta     SPRITE_0_ID                           ; A779 8D 01 02                 ...
        lda     DRAGON_SLAYER_SPRITE_Y+2,x                         ; A77C BD 82 02                 ...
        sta     SPRITE_0_FLAGS                           ; A77F 8D 02 02                 ...
        lda     DRAGON_SLAYER_SPRITE_Y+3,x                         ; A782 BD 83 02                 ...
        sta     SPRITE_0_X                           ; A785 8D 03 02                 ...
        
		; free the sprite we copied from
 	    lda     #OFFSCREEN_Y                            ; A788 A9 EF                    ..
        sta     $0280,x                         ; A78A 9D 80 02                 ...
        rts                                     ; A78D 60                       `

; ----------------------------------------------------------------------------
; as above, but copies to sprite 0 with offset starting at $0210
LA78E:
		; using player sprite (DRAGON_SPRITE_0_CTR = 2-7)
		; multiply by 4 to copy correct sprite (either left or right half of player)
        lda     DRAGON_SPRITE_0_CTR                             ; A78E A5 3E                    .>
        asl     a                               ; A790 0A                       .
        asl     a                               ; A791 0A                       .
        tax                                     ; A792 AA                       .
        lda     PLAYER_SPRITE_0,x                         ; A793 BD 10 02                 ...
        sta     SPRITE_0_Y                           ; A796 8D 00 02                 ...
        lda     PLAYER_SPRITE_0+1,x                         ; A799 BD 11 02                 ...
        sta     SPRITE_0_ID                           ; A79C 8D 01 02                 ...
        lda     PLAYER_SPRITE_0+2,x                         ; A79F BD 12 02                 ...
        sta     SPRITE_0_FLAGS                           ; A7A2 8D 02 02                 ...
        lda     PLAYER_SPRITE_0+3,x                         ; A7A5 BD 13 02                 ...
        sta     SPRITE_0_X                           ; A7A8 8D 03 02                 ...
        
		; free the slot we copied from
		lda     #OFFSCREEN_Y                            ; A7AB A9 EF                    ..
        sta     PLAYER_SPRITE_0,x                         ; A7AD 9D 10 02                 ...
        rts                                     ; A7B0 60                       `

; ----------------------------------------------------------------------------
; set cur obj dx and dy based on direction and speed
; input - a = dpad input
;         y = speed
DRAGON_FIGHT_CALC_MOVE_VECTOR:
        ; 2*a = index to dx/dy tables
		sty     SCRATCH_09                             ; A7B1 84 09                    ..
        and     #$0F                            ; A7B3 29 0F                    ).
        asl     a                               ; A7B5 0A                       .
        tax                                     ; A7B6 AA                       .
        
		; loop to add dx total
		lda     #$00                            ; A7B7 A9 00                    ..
LA7B9:
        clc                                     ; A7B9 18                       .
        adc     TBL_DPAD_TO_DX,x                         ; A7BA 7D 8B FE                 }..
        dey                                     ; A7BD 88                       .
        bne     LA7B9                           ; A7BE D0 F9                    ..
        sta     a:CUR_OBJ_DX                           ; A7C0 8D F5 00                 ...
        ldy     SCRATCH_09                             ; A7C3 A4 09                    ..
        
		; now, loop to add dy
		lda     #$00                            ; A7C5 A9 00                    ..
LA7C7:
        clc                                     ; A7C7 18                       .
        adc     TBL_DPAD_TO_DY,x                         ; A7C8 7D 8C FE                 }..
        dey                                     ; A7CB 88                       .
        bne     LA7C7                           ; A7CC D0 F9                    ..
        sta     a:CUR_OBJ_DY                           ; A7CE 8D F7 00                 ...
        rts                                     ; A7D1 60                       `

; ----------------------------------------------------------------------------
; used for dragon fight
; loop to load 64 bytes sprite data to BOSS_LIFE_BAR_SPRITE_Y from table
INIT_DRAGON_LIFE_BAR:
        ldx     #$3F                            ; A7D2 A2 3F                    .?
LA7D4:
        lda     TBL_DRAGON_LIFE_BAR_SPRITES,x                         ; A7D4 BD FC AA                 ...
        sta     BOSS_LIFE_BAR_SPRITE_Y,x                         ; A7D7 9D 40 02                 .@.
        dex                                     ; A7DA CA                       .
        bpl     LA7D4                           ; A7DB 10 F7                    ..
        jsr     DRAW_DRAGON_LIFE_BAR                           ; A7DD 20 69 CB                  i.
        rts                                     ; A7E0 60                       `

; ----------------------------------------------------------------------------
; use for the 4 crown bosses
; loop to load 64 bytes sprite data to BOSS_LIFE_BAR_SPRITE_Y from table
INIT_CROWN_BOSS_LIFE_BAR:
; $a7e1 INIT_CROWN_BOSS_LIFE_BAR
        ldx     #$3F                            ; A7E1 A2 3F                    .?
LA7E3:
        lda     TBL_CROWN_BOSS_LIFE_BAR_SPRITES,x                         ; A7E3 BD 3C AB                 .<.
        sta     BOSS_LIFE_BAR_SPRITE_Y,x                         ; A7E6 9D 40 02                 .@.
        dex                                     ; A7E9 CA                       .
        bpl     LA7E3                           ; A7EA 10 F7                    ..
        jsr     DRAW_CROWN_BOSS_LIFE_BAR                           ; A7EC 20 53 CB                  S.
        rts                                     ; A7EF 60                       `

; ----------------------------------------------------------------------------
; used in dragon fight
; loop to load 64 bytes sprite data to PLAYER_LIFE_BAR_SPRITE_Y from table
INIT_PLAYER_LIFE_BAR:
        ldx     #$3F                            ; A7F0 A2 3F                    .?
LA7F2:
        lda     TBL_PLAYER_LIFE_BAR_SPRITES,x                         ; A7F2 BD 7C AB                 .|.
        sta     PLAYER_LIFE_BAR_SPRITE_Y,x                         ; A7F5 9D C0 02                 ...
        dex                                     ; A7F8 CA                       .
        bpl     LA7F2                           ; A7F9 10 F7                    ..
        jsr     DRAW_PLAYER_LIFE_BAR                           ; A7FB 20 7F CB                  ..
        rts                                     ; A7FE 60                       `

; ----------------------------------------------------------------------------
DRAGON_NO_HP:
        jsr     DRAW_DRAGON_LIFE_BAR                           ; A7FF 20 69 CB                  i.
        
		; clear any projectiles
		lda     #$00                            ; A802 A9 00                    ..
        sta     OBJ_1_GEN_TYPE                           ; A804 8D 11 04                 ...
        sta     OBJ_2_GEN_TYPE                           ; A807 8D 21 04                 .!.
        sta     OBJ_3_GEN_TYPE                           ; A80A 8D 31 04                 .1.
        sta     DRAGON_ACTION_CTR                             ; A80D 85 FA                    ..
        sta     INVULN_CTR                             ; A80F 85 85                    ..
        sta     CTR_SPEED_SCROLL_1                             ; A811 85 88                    ..
        jsr     DRAW_PLAYER_SINGLE_SCREEN                           ; A813 20 7A AD                  z.
        jsr     DRAW_DRAGONSLAYER_PROJECTILES                           ; A816 20 E0 A6                  ..
        lda     #OFFSCREEN_Y                            ; A819 A9 EF                    ..
        sta     SPRITE_0_Y                           ; A81B 8D 00 02                 ...
DRAGON_DEATH_FORCE_PLAYER_TO_GROUND:
		; branch if player on the ground
        lda     PY                             ; A81E A5 45                    .E
        cmp     #$A0                            ; A820 C9 A0                    ..
        bcs     DRAGON_START_BURN                           ; A822 B0 10                    ..
        
		; player is not on ground; loop and force player down 1 px/frame
		inc     PY                             ; A824 E6 45                    .E
        jsr     DRAW_PLAYER_SINGLE_SCREEN                           ; A826 20 7A AD                  z.
        lda     #$01                            ; A829 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; A82B 85 36                    .6
LA82D:
		; loop here until NMI_WAIT_CTR cleared
        lda     NMI_WAIT_CTR                             ; A82D A5 36                    .6
        bne     LA82D                           ; A82F D0 FC                    ..
        jmp     DRAGON_DEATH_FORCE_PLAYER_TO_GROUND                           ; A831 4C 1E A8                 L..

; ----------------------------------------------------------------------------
; dragon has been killed, Roas is on the ground, now start the burning animation
DRAGON_START_BURN:
		; clear jump variables
        lda     #$00                            ; A834 A9 00                    ..
        sta     CTR_PLAYER_DESCENT                             ; A836 85 4E                    .N
        sta     JUMP_FRAMES_REMAINING                             ; A838 85 4F                    .O
        
		; update the player
		jsr     DRAGON_CALC_PLAYER_FRAME                           ; A83A 20 E0 AC                  ..
        jsr     DRAW_PLAYER_SINGLE_SCREEN                           ; A83D 20 7A AD                  z.
        
		; update some visuals/sound stuff
		lda     #$20                            ; A840 A9 20                    . 
		sta     SCROLL_X_HI                             ; A842 85 7C                    .|
        lda     #$01                            ; A844 A9 01                    ..
        sta     PPU_NAMETABLE_SELECT                             ; A846 85 1D                    ..
        lda     #SOUND_DRAGON                            ; A848 A9 20                    . 
        sta     NEXT_SOUND_EFFECT                             ; A84A 85 8F                    ..
		lda     #$80                            ; A84C A9 80                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; A84E 85 90                    ..
        
		; set tile defs for first phase of dragon burning, when flames appear on
		; parts of body but most still visible
		lda     #$B6                            ; A850 A9 B6                    ..
        sta     TILE_DEFS_HI                             ; A852 85 7A                    .z
LA854:
        jsr     DRAGON_UPDATE_GRAPHICS                           ; A854 20 74 A5                  t.
        lda     DRAGON_ACTION_CTR                             ; A857 A5 FA                    ..
        bne     LA854                           ; A859 D0 F9                    ..
LA85B:
        jsr     DRAGON_UPDATE_GRAPHICS                           ; A85B 20 74 A5                  t.
        lda     DRAGON_ACTION_CTR                             ; A85E A5 FA                    ..
        bne     LA85B                           ; A860 D0 F9                    ..
        
		; another roar
		lda     #SOUND_DRAGON                            ; A862 A9 20                    . 
        sta     NEXT_SOUND_EFFECT                             ; A864 85 8F                    ..
        lda     #$80                            ; A866 A9 80                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; A868 85 90                    ..
        
		; set tile defs for 2nd phase of dragon burning, when it gets totally consumed
		lda     #$B7                            ; A86A A9 B7                    ..
        sta     TILE_DEFS_HI                             ; A86C 85 7A                    .z
LA86E:
        ; loop with DRAGON_ACTION_CTR <> 0
		jsr     DRAGON_UPDATE_GRAPHICS                           ; A86E 20 74 A5                  t.
        lda     DRAGON_ACTION_CTR                             ; A871 A5 FA                    ..
        bne     LA86E                           ; A873 D0 F9                    ..
LA875:
		; again, loop with DRAGON_ACTION_CTR <> 0
        jsr     DRAGON_UPDATE_GRAPHICS                           ; A875 20 74 A5                  t.
        lda     DRAGON_ACTION_CTR                             ; A878 A5 FA                    ..
        bne     LA875                           ; A87A D0 F9                    ..
        
		; clear DRAGON_BURN_CTR
		lda     #$00                            ; A87C A9 00                    ..
        sta     DRAGON_BURN_CTR                             ; A87E 85 10                    ..

; dragon is now just a pile of bones with some flames on top
DRAGON_FINAL_BURN_LOOP:
        ; branch unless FRAME_CTR%8=0; animate dragon every 8th frame
		lda     FRAME_CTR                             ; A880 A5 84                    ..
        and     #$07                            ; A882 29 07                    ).
        bne     LA894                           ; A884 D0 0E                    ..
        
		; animate the dragon pyre
		lda     PPU_NAMETABLE_SELECT                             ; A886 A5 1D                    ..
        eor     #$01                            ; A888 49 01                    I.
        sta     PPU_NAMETABLE_SELECT                             ; A88A 85 1D                    ..
        
		; play sound continuously
		lda     #SOUND_DRAGON                            ; A88C A9 20                    . 
        sta     NEXT_SOUND_EFFECT                             ; A88E 85 8F                    ..
        lda     #$80                            ; A890 A9 80                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; A892 85 90                    ..
LA894:
        ; basic nmi
		lda     #$FF                            ; A894 A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; A896 20 8F CC                  ..
        
		; branch if sprite 0 hit has not occurred - player not getting burned by dragon pyre
		bit     PPU_STAT_COPY                             ; A899 24 26                    $&
        bvc     LA8A5                           ; A89B 50 08                    P.
        
		; sprite 0 hit did occur - 5 damage for player getting burned by dying dragon!
		; given we loop here 256 times, player takes 1280hp damage, so not survivable :O
		lda     #$05                            ; A89D A9 05                    ..
        jsr     DRAGON_DAMAGE_PLAYER                           ; A89F 20 2F AE                  /.
        jsr     DRAW_PLAYER_LIFE_BAR                           ; A8A2 20 7F CB                  ..
LA8A5:
        ; if ctr is 0, set it to 2, then redraw player; this restricts collision checking
		; to the player (ctr values 0-1 after decrement)
		lda     DRAGON_SPRITE_0_CTR                             ; A8A5 A5 3E                    .>
        bne     LA8AD                           ; A8A7 D0 04                    ..
        lda     #$02                            ; A8A9 A9 02                    ..
        sta     DRAGON_SPRITE_0_CTR                             ; A8AB 85 3E                    .>
LA8AD:
        jsr     DRAW_PLAYER_SINGLE_SCREEN                           ; A8AD 20 7A AD                  z.
        jsr     DRAGON_FIGHT_COPY_TO_SPRITE_0                           ; A8B0 20 5D A7                  ].
        
		; branch (loop) if DRAGON_BURN_CTR <> 0
		; it's set to 0 above, so will look 256 times
		dec     DRAGON_BURN_CTR                             ; A8B3 C6 10                    ..
        bne     DRAGON_FINAL_BURN_LOOP                           ; A8B5 D0 C9                    ..
        
		; dragon is done burning; set PPU_TOGGLE_ID
		lda     #$01                            ; A8B7 A9 01                    ..
        sta     PPU_NAMETABLE_SELECT                             ; A8B9 85 1D                    ..
        lda     #$FF                            ; A8BB A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; A8BD 20 8F CC                  ..
        
		; branch if we've survived, else just rts (and die!)
		; one of the crueler boss-fight gotchas 
		lda     PLAYER_LIFE                             ; A8C0 A5 58                    .X
        bne     DRAGON_DEATH_PLAYER_SURVIVED                           ; A8C2 D0 01                    ..
        rts                                     ; A8C4 60                       `

; ----------------------------------------------------------------------------
; play cross sound and then fly Roas up off the screen!
DRAGON_DEATH_PLAYER_SURVIVED:
        ; disable collision checks, play cross sound
		lda     #OFFSCREEN_Y                            ; A8C5 A9 EF                    ..
        sta     SPRITE_0_Y                           ; A8C7 8D 00 02                 ...
        lda     #SOUND_CROSS                            ; A8CA A9 18                    ..
        sta     NEXT_SOUND_EFFECT                             ; A8CC 85 8F                    ..
        lda     #$FF                            ; A8CE A9 FF                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; A8D0 85 90                    ..
        
		; set Roas' initial dy upwards
		lda     #$01                            ; A8D2 A9 01                    ..
        sta     SCRATCH_08                             ; A8D4 85 08                    ..
ENDING_ROAS_FLIES_AWAY:
        
		; Roas rises...
		lda     PY                             ; A8D6 A5 45                    .E
        sec                                     ; A8D8 38                       8
        sbc     SCRATCH_08                             ; A8D9 E5 08                    ..
        sta     PY                             ; A8DB 85 45                    .E
        
		; branch if he's offscreen
		adc     #OBJ_SCREEN_Y_PAD                            ; A8DD 69 2B                    i+
        cmp     #OFFSCREEN_Y                            ; A8DF C9 EF                    ..
        bcs     ENDING_TRANSITION_TO_OVERWORLD                           ; A8E1 B0 0D                    ..
        
		; else accelerate and loop!
		jsr     DRAW_PLAYER_SINGLE_SCREEN                           ; A8E3 20 7A AD                  z.
        inc     SCRATCH_08                             ; A8E6 E6 08                    ..
        lda     #$FF                            ; A8E8 A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; A8EA 20 8F CC                  ..
        
		; loop
		jmp     ENDING_ROAS_FLIES_AWAY                           ; A8ED 4C D6 A8                 L..

; ----------------------------------------------------------------------------
; prep for triumphant Roas to ascend the overworld ladder
ENDING_TRANSITION_TO_OVERWORLD:
        ; hide player sprites
		lda     #OFFSCREEN_Y                            ; A8F0 A9 EF                    ..
        sta     PLAYER_SPRITE_0                           ; A8F2 8D 10 02                 ...
        sta     PLAYER_SPRITE_1                           ; A8F5 8D 14 02                 ...
        
		; config objects/sprites
		lda     #$00                            ; A8F8 A9 00                    ..
        sta     FIRST_OBJECT_OFFSET                             ; A8FA 85 3E                    .>
        lda     #$80                            ; A8FC A9 80                    ..
        sta     OBJECT_SPRITE_RAM_START                             ; A8FE 85 3F                    .?
        
		; clean up, fade out graphics and music
		jsr     CLEAR_ALL_OBJECTS                           ; A900 20 8A D0                  ..
        jsr     ENDING_MUSIC_FADE                           ; A903 20 9B B2                  ..
        jsr     PALETTE_FADE_OUT_LC461                           ; A906 20 61 C4                  a.
        jsr     WIPE_NAMETABLE                           ; A909 20 8B C3                  ..
        jsr     WIPE_SPRITES_EXCEPT_0                           ; A90C 20 75 C3                  u.
        
		; setup warp to overworld ladder
		lda     #MAP_Y_OVERWORLD                            ; A90F A9 10                    ..
        sta     MAP_Y                             ; A911 85 48                    .H
        lda     #MAP_X_OVERWORLD                            ; A913 A9 03                    ..
        sta     MAP_X                             ; A915 85 47                    .G
        
		; setup jump to $c8f2 (LOAD_MAP_FULL)
		lda     #$F2                            ; A917 A9 F2                    ..
        sta     JMP_DEST_0E_LO                             ; A919 85 0E                    ..
        lda     #$C8                            ; A91B A9 C8                    ..
        sta     JMP_DEST_0F_HI                             ; A91D 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A91F 20 E4 CC                  ..
        
		; set scroll and Roas' location (below ladder) and frame
		lda     #$12                            ; A922 A9 12                    ..
        sta     SCROLL_X_HI                             ; A924 85 7C                    .|
        lda     #$C0                            ; A926 A9 C0                    ..
        sta     PY                             ; A928 85 45                    .E
        lda     #$1A                            ; A92A A9 1A                    ..
        sta     PX_HI                             ; A92C 85 44                    .D
        lda     #$01                            ; A92E A9 01                    ..
        sta     PX_LO                             ; A930 85 43                    .C
        sta     SCROLL_X_LO                             ; A932 85 7B                    .{
        lda     #$09                            ; A934 A9 09                    ..
        sta     PLAYER_FRAME                             ; A936 85 56                    .V
        
		; pattern banks for ending
		lda     #$35                            ; A938 A9 35                    .5
        sta     CHR_BANK_PLAYER_SPRITES                             ; A93A 85 2C                    .,
        lda     #$34                            ; A93C A9 34                    .4
        sta     CHR_BANK_ENEMY_SPRITES                             ; A93E 85 2D                    .-
        lda     #$36                            ; A940 A9 36                    .6
        sta     CHR_BANK_SPRITES_02                             ; A942 85 2E                    ..
        lda     #$37                            ; A944 A9 37                    .7
        sta     CHR_BANK_SPRITES_03                             ; A946 85 2F                    ./
        
		; generate the family members (as enemies!)
		lda     #$01                            ; A948 A9 01                    ..
        sta     OBJ_1_GEN_TYPE                           ; A94A 8D 11 04                 ...
        sta     OBJ_2_GEN_TYPE                           ; A94D 8D 21 04                 .!.
        sta     OBJ_3_GEN_TYPE                           ; A950 8D 31 04                 .1.
        sta     OBJ_4_GEN_TYPE                           ; A953 8D 41 04                 .A.
        ; y positions - humans on the ground, pochi on the roof
		lda     #$A0                            ; A956 A9 A0                    ..
        sta     OBJ_Y+$10                           ; A958 8D 1E 04                 ...
        sta     OBJ_Y+$20                           ; A95B 8D 2E 04                 ...
        sta     OBJ_Y+$30                           ; A95E 8D 3E 04                 .>.
        lda     #$70                            ; A961 A9 70                    .p
        sta     OBJ_Y+$40                           ; A963 8D 4E 04                 .N.
       
 	    lda     #$33                            ; A966 A9 33                    .3
        sta     OBJ_4_X_HI                           ; A968 8D 4D 04                 .M.
        jsr     ENDING_FAMILY_WALK_A_STEP                           ; A96B 20 AE AA                  ..
        clc                                     ; A96E 18                       .
        
		; set the family members' sprites
		lda     #$2D                            ; A96F A9 2D                    .-
        sta     OBJ_1_SPRITE                           ; A971 8D 10 04                 ...
        adc     #$20                            ; A974 69 20                    i 
        sta     OBJ_2_SPRITE                           ; A976 8D 20 04                 . .
        adc     #$20                            ; A979 69 20                    i 
        sta     OBJ_3_SPRITE                           ; A97B 8D 30 04                 .0.
        lda     #$81                            ; A97E A9 81                    ..
        sta     OBJ_4_SPRITE                           ; A980 8D 40 04                 .@.
        
		; horizontally flip
		lda     #$40                            ; A983 A9 40                    .@
        sta     OBJ_1_SPRITE_FLAGS                           ; A985 8D 12 04                 ...
        sta     OBJ_2_SPRITE_FLAGS                           ; A988 8D 22 04                 .".
        sta     OBJ_3_SPRITE_FLAGS                           ; A98B 8D 32 04                 .2.
        sta     OBJ_4_SPRITE_FLAGS                           ; A98E 8D 42 04                 .B.
        
		; status bar ready
		jsr     LOAD_STATUS_BAR_GRAPHICS                           ; A991 20 7A C5                  z.
        
		; jump to $c5cb / LOAD_GRAPHICS_FOR_MAP_LEVEL
		lda     #$CB                            ; A994 A9 CB                    ..
        sta     JMP_DEST_0E_LO                             ; A996 85 0E                    ..
        lda     #$C5                            ; A998 A9 C5                    ..
        sta     JMP_DEST_0F_HI                             ; A99A 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A99C 20 E4 CC                  ..
        
		; update visuals
		jsr     EVENT_PLAYER_LIFE_CHANGE                           ; A99F 20 B6 CA                  ..
        jsr     EVENT_PLAYER_MAGIC_CHANGE                           ; A9A2 20 CC CA                  ..
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; A9A5 20 F8 CA                  ..
        jsr     EVENT_PLAYER_KEY_CHANGE                           ; A9A8 20 E2 CA                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; A9AB 20 C7 C1                  ..
        jsr     HIDE_SPRITES_280_UP                           ; A9AE 20 7C D0                  |.
        jsr     DRAW_PLAYER                           ; A9B1 20 D8 C1                  ..
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; A9B4 20 34 C2                  4.
        jsr     DRAW_OBJECTS                           ; A9B7 20 B1 C2                  ..
        
		; PLAYER_ID initialized to 7 just before the ending for fancy Roas!
		; note the rest of the family are technically enemies so they don't need alternative PLAYER_ID's
		lda     #PLAYER_ENDING_ROAS                           ; A9BA A9 07                    ..
        sta     PLAYER_ID                             ; A9BC 85 40                    .@
        
		; jump to $c492 / PALETTE_FADE_IN
		lda     #$92                            ; A9BE A9 92                    ..
        sta     JMP_DEST_0E_LO                             ; A9C0 85 0E                    ..
        lda     #$C4                            ; A9C2 A9 C4                    ..
        sta     JMP_DEST_0F_HI                             ; A9C4 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; A9C6 20 E4 CC                  ..
        
		; wait 5 seconds
		lda     #$05                            ; A9C9 A9 05                    ..
        sta     CTR_WAIT_SECONDS                             ; A9CB 85 8C                    ..
LA9CD:
        ; loop while counter not zero
		jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; A9CD 20 EE AA                  ..
        lda     CTR_WAIT_SECONDS                             ; A9D0 A5 8C                    ..
        bne     LA9CD                           ; A9D2 D0 F9                    ..

ROAS_ENDING_LADDER_CLIMB:
		; branch when Roas reaches top of ladder
        lda     PY                             ; A9D4 A5 45                    .E
        cmp     #$A0                            ; A9D6 C9 A0                    ..
        beq     ENDING_FAMILY_WALKS_RIGHT                           ; A9D8 F0 25                    .%
        
		; Roas below top of ladder - move him up 1 px every 2 frames
		dec     PY                             ; A9DA C6 45                    .E
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; A9DC 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; A9DF 20 EE AA                  ..
        lda     PY                             ; A9E2 A5 45                    .E
        cmp     #$A0                            ; A9E4 C9 A0                    ..
        beq     ENDING_FAMILY_WALKS_RIGHT                           ; A9E6 F0 17                    ..
        dec     PY                             ; A9E8 C6 45                    .E
        
		; flip bit 6 (horiz flip) to animate him climbing ladder
		lda     PLAYER_SPRITE_FLAGS                             ; A9EA A5 57                    .W
        eor     #$40                            ; A9EC 49 40                    I@
        sta     PLAYER_SPRITE_FLAGS                             ; A9EE 85 57                    .W
        jsr     DRAW_PLAYER                           ; A9F0 20 D8 C1                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; A9F3 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; A9F6 20 EE AA                  ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; A9F9 20 35 C1                  5.
        
		; loop
		jmp     ROAS_ENDING_LADDER_CLIMB                           ; A9FC 4C D4 A9                 L..

; ----------------------------------------------------------------------------
ENDING_FAMILY_WALKS_RIGHT:
        ; set frame and counter
		lda     #$0D                            ; A9FF A9 0D                    ..
        sta     PLAYER_FRAME                             ; AA01 85 56                    .V
        jsr     DRAW_PLAYER                           ; AA03 20 D8 C1                  ..
        
		; wait 3 seconds
		lda     #$03                            ; AA06 A9 03                    ..
        sta     CTR_WAIT_SECONDS                             ; AA08 85 8C                    ..
LAA0A:
		; loop playing music and animating until delay over
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AA0A 20 EE AA                  ..
        lda     CTR_WAIT_SECONDS                             ; AA0D A5 8C                    ..
        bne     LAA0A                           ; AA0F D0 F9                    ..
LAA11:
        lda     #$01                            ; AA11 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; AA13 85 36                    .6
        lda     SCROLL_X_HI                             ; AA15 A5 7C                    .|
        sta     LAST_SCROLL_X_HI                             ; AA17 85 7E                    .~
        
		; pretend we're pressing right...
		lda     #BTN_RIGHT                            ; AA19 A9 01                    ..
        sta     JOYPAD_INPUT                             ; AA1B 85 20                    . 
        
		; jump to $d42b / UPDATE_PLAYER
		lda     #$2B                            ; AA1D A9 2B                    .+
        sta     JMP_DEST_0E_LO                             ; AA1F 85 0E                    ..
        lda     #$D4                            ; AA21 A9 D4                    ..
        sta     JMP_DEST_0F_HI                             ; AA23 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; AA25 20 E4 CC                  ..
        
		; jump to $c15d / CALC_HORIZ_SCROLL_VARS
		lda     #$5D                            ; AA28 A9 5D                    .]
        sta     JMP_DEST_0E_LO                             ; AA2A 85 0E                    ..
        lda     #$C1                            ; AA2C A9 C1                    ..
        sta     JMP_DEST_0F_HI                             ; AA2E 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; AA30 20 E4 CC                  ..
        
		; show everyone walking
		jsr     ENDING_FAMILY_WALK_A_STEP                           ; AA33 20 AE AA                  ..
        jsr     DRAW_PLAYER                           ; AA36 20 D8 C1                  ..
        jsr     DRAW_OBJECTS                           ; AA39 20 B1 C2                  ..
        
		; compare LAST_SCROLL_X_HI to SCROLL_X_HI - if unequal then flag an update
		lda     LAST_SCROLL_X_HI                             ; AA3C A5 7E                    .~
        cmp     SCROLL_X_HI                             ; AA3E C5 7C                    .|
        beq     LAA44                           ; AA40 F0 02                    ..
        inc     SCROLL_UPDATE_FLAG                             ; AA42 E6 3D                    .=
LAA44:
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; AA44 20 35 C1                  5.
        
		; branch (loop) if family not yet far enough right
		lda     PX_HI                             ; AA47 A5 44                    .D
        cmp     #$37                            ; AA49 C9 37                    .7
        bne     LAA11                           ; AA4B D0 C4                    ..
        
		; family has reached the far right, set their waving frames
		lda     #$19                            ; AA4D A9 19                    ..
        sta     PLAYER_FRAME                             ; AA4F 85 56                    .V
        lda     #$39                            ; AA51 A9 39                    .9
        sta     OBJ_1_SPRITE                           ; AA53 8D 10 04                 ...
        lda     #$59                            ; AA56 A9 59                    .Y
        sta     OBJ_2_SPRITE                           ; AA58 8D 20 04                 . .
        lda     #$79                            ; AA5B A9 79                    .y
        sta     OBJ_3_SPRITE                           ; AA5D 8D 30 04                 .0.
        lda     #$91                            ; AA60 A9 91                    ..
        sta     OBJ_4_SPRITE                           ; AA62 8D 40 04                 .@.
        
		; sets timer 20s
		lda     #$14                            ; AA65 A9 14                    ..
        sta     CTR_WAIT_SECONDS                             ; AA67 85 8C                    ..
ENDING_FAMILY_WAVING: 
		; animate every 8th frames, family waving, Pochi wagging tail
        lda     PLAYER_FRAME                             ; AA69 A5 56                    .V
        eor     #$04                            ; AA6B 49 04                    I.
        sta     PLAYER_FRAME                             ; AA6D 85 56                    .V
        lda     OBJ_1_SPRITE                           ; AA6F AD 10 04                 ...
        eor     #$04                            ; AA72 49 04                    I.
        sta     OBJ_1_SPRITE                           ; AA74 8D 10 04                 ...
        lda     OBJ_2_SPRITE                           ; AA77 AD 20 04                 . .
        eor     #$04                            ; AA7A 49 04                    I.
        sta     OBJ_2_SPRITE                           ; AA7C 8D 20 04                 . .
        lda     OBJ_3_SPRITE                           ; AA7F AD 30 04                 .0.
        eor     #$04                            ; AA82 49 04                    I.
        sta     OBJ_3_SPRITE                           ; AA84 8D 30 04                 .0.
        lda     OBJ_4_SPRITE                           ; AA87 AD 40 04                 .@.
        eor     #$04                            ; AA8A 49 04                    I.
        sta     OBJ_4_SPRITE                           ; AA8C 8D 40 04                 .@.
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AA8F 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AA92 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AA95 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AA98 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AA9B 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AA9E 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AAA1 20 EE AA                  ..
        jsr     ENDING_DRAW_AND_ADVANCE_FRAME                           ; AAA4 20 EE AA                  ..
        
		; loop until timer runs down
		lda     CTR_WAIT_SECONDS                             ; AAA7 A5 8C                    ..
        bne     ENDING_FAMILY_WAVING                           ; AAA9 D0 BE                    ..
        jmp     ENDING_CREDITS_ROLL                           ; AAAB 4C 3D B1                 L=.

; ----------------------------------------------------------------------------
; while family is walking toward house during ending, coordinate their movement and animation
ENDING_FAMILY_WALK_A_STEP:
		; lower 5 bits of PLAYER_FRAME applied to family frames to keep their movements in synch
		lda     PLAYER_FRAME                             ; AAAE A5 56                    .V
        and     #$1F                            ; AAB0 29 1F                    ).
        sta     SCRATCH_08                             ; AAB2 85 08                    ..
        lda     OBJ_1_SPRITE                            ; AAB4 AD 10 04                 ...
        and     #$E0                            ; AAB7 29 E0                    ).
        ora     SCRATCH_08                             ; AAB9 05 08                    ..
        sta     OBJ_1_SPRITE                           ; AABB 8D 10 04                 ...
        lda     OBJ_2_SPRITE                           ; AABE AD 20 04                 . .
        and     #$E0                            ; AAC1 29 E0                    ).
        ora     SCRATCH_08                             ; AAC3 05 08                    ..
        sta     OBJ_2_SPRITE                           ; AAC5 8D 20 04                 . .
        lda     OBJ_3_SPRITE                           ; AAC8 AD 30 04                 .0.
        and     #$E0                            ; AACB 29 E0                    ).
        ora     SCRATCH_08                             ; AACD 05 08                    ..
        sta     OBJ_3_SPRITE                           ; AACF 8D 30 04                 .0.
        
		; PX_LO kept in sync
		lda     PX_LO                             ; AAD2 A5 43                    .C
        sta     OBJ_1_X_LO                           ; AAD4 8D 1C 04                 ...
        sta     OBJ_2_X_LO                           ; AAD7 8D 2C 04                 .,.
        sta     OBJ_3_X_LO                           ; AADA 8D 3C 04                 .<.
        
		; PX_HI to set the march order
		ldx     PX_HI                             ; AADD A6 44                    .D
        inx                                     ; AADF E8                       .
        stx     OBJ_2_X_HI                           ; AAE0 8E 2D 04                 .-.
        dex                                     ; AAE3 CA                       .
        dex                                     ; AAE4 CA                       .
        dex                                     ; AAE5 CA                       .
        stx     OBJ_3_X_HI                           ; AAE6 8E 3D 04                 .=.
        dex                                     ; AAE9 CA                       .
        stx     OBJ_1_X_HI                           ; AAEA 8E 1D 04                 ...
        rts                                     ; AAED 60                       `

; ----------------------------------------------------------------------------
; draw stuff and wait a frame
ENDING_DRAW_AND_ADVANCE_FRAME:
        jsr     DRAW_PLAYER                           ; AAEE 20 D8 C1                  ..
        jsr     DRAW_OBJECTS                           ; AAF1 20 B1 C2                  ..
        lda     #$01                            ; AAF4 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; AAF6 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; AAF8 20 35 C1                  5.
        rts                                     ; AAFB 60                       `

.INCLUDE "include\bankc-d-life-bar-sprites.asm"

; ----------------------------------------------------------------------------
; $ABBC
; dragon fight only - handles moving, jumping, pressing select - but firing is handled elsewhere
DRAGON_FIGHT_CHECK_JOYPAD: 
		lda     JOYPAD_INPUT                             ; ABBC A5 20                    . 
        and     #BTN_START                            ; ABBE 29 10                    ).
        
		; branch if start not pressed
		beq     LABC5                           ; ABC0 F0 03                    ..
        
		; start pressed
		jmp     DRAGON_FIGHT_START_PRESSED                           ; ABC2 4C 11 AE                 L..

; ----------------------------------------------------------------------------
LABC5:
        bit     JOYPAD_INPUT                             ; ABC5 24 20                    $ 
        
		; branch if B (bit 6) is pressed
		bvs     LABCF                           ; ABC7 70 06                    p.
        
		; B is not pressed
		; clear upper nibble of JOYPAD_INPUT_REFERENCE
		lda     JOYPAD_INPUT_REFERENCE                             ; ABC9 A5 FD                    ..
        and     #$0F                            ; ABCB 29 0F                    ).
        sta     JOYPAD_INPUT_REFERENCE                             ; ABCD 85 FD                    ..
LABCF:
        lda     JOYPAD_INPUT                             ; ABCF A5 20                    . 
        and     #$0F                            ; ABD1 29 0F                    ).
        
		; branch if no dpad input
		beq     LABDF                           ; ABD3 F0 0A                    ..
        
		; there is dpad input
		; use it to replace JOYPAD_INPUT_REFERENCE lower nibble
		sta     SCRATCH_08                             ; ABD5 85 08                    ..
        lda     JOYPAD_INPUT_REFERENCE                             ; ABD7 A5 FD                    ..
        and     #$F0                            ; ABD9 29 F0                    ).
        ora     SCRATCH_08                             ; ABDB 05 08                    ..
        sta     JOYPAD_INPUT_REFERENCE                             ; ABDD 85 FD                    ..
LABDF:
        ; branch if invulnerable
		lda     INVULN_CTR                             ; ABDF A5 85                    ..
        bne     LAC13                           ; ABE1 D0 30                    .0
        
		; branch if sprite 0 hit has not occurred
		bit     PPU_STAT_COPY                             ; ABE3 24 26                    $&
        bvc     LAC2A                           ; ABE5 50 43                    PC
        
		; sprite 0 hit did occur - so player (sprite 0) hit dragon (bg)
		; check DRAGON_SPRITE_0_CTR, add 1, branch if either bit 1 or 2 set
		; this logic will not branch if DRAGON_SPRITE_0_CTR = 0 (player) but will
		; if it's 1-3 (projectile)
		ldx     DRAGON_SPRITE_0_CTR                             ; ABE7 A6 3E                    .>
        inx                                     ; ABE9 E8                       .
        txa                                     ; ABEA 8A                       .
        and     #$06                            ; ABEB 29 06                    ).
        bne     LAC2A                           ; ABED D0 3B                    .;
        
		; player hit! use x pos vs scroll to determine if hit by fire
		; or dragon itself
		lda     PPU_SCROLL_X                             ; ABEF A5 1C                    ..
        clc                                     ; ABF1 18                       .
        adc     OBJ_X_LO,x                         ; ABF2 7D 0C 04                 }..
        cmp     #$B0                            ; ABF5 C9 B0                    ..
        
		; branch if player hit fire (10 damage)
		lda     #$0A                            ; ABF7 A9 0A                    ..
		bcc     LABFD                           ; ABF9 90 02                    ..
        
		; further right, hit dragon itself (5 damage)
		lda     #$05                            ; ABFB A9 05                    ..
LABFD:
        jsr     DRAGON_DAMAGE_PLAYER                           ; ABFD 20 2F AE                  /.
        
		; 10 frame jump from getting hit
		; note we can't move while getting bounced but we can fire
		lda     #$0A                            ; AC00 A9 0A                    ..
        sta     JUMP_FRAMES_REMAINING                             ; AC02 85 4F                    .O
        lda     #SOUND_TAKE_DAMAGE                            ; AC04 A9 21                    .!
        sta     NEXT_SOUND_EFFECT                             ; AC06 85 8F                    ..
        lda     #$02                            ; AC08 A9 02                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; AC0A 85 90                    ..
        lda     #$01                            ; AC0C A9 01                    ..
        sta     INVULN_CTR                             ; AC0E 85 85                    ..
        jsr     DRAW_PLAYER_LIFE_BAR                           ; AC10 20 7F CB                  ..
LAC13:
		; branch if jump still going up
        lda     JUMP_FRAMES_REMAINING                             ; AC13 A5 4F                    .O
        bne     FORCE_PLAYER_LEFT                           ; AC15 D0 0B                    ..
        
		; branch if still falling
		lda     CTR_PLAYER_DESCENT                             ; AC17 A5 4E                    .N
        bne     FORCE_PLAYER_LEFT                           ; AC19 D0 07                    ..
        
		; invulnerability stops when player hits the ground!
		; at that point, we are no longer forcing him left either
		lda     #$00                            ; AC1B A9 00                    ..
        sta     INVULN_CTR                             ; AC1D 85 85                    ..
        jmp     LAC2A                           ; AC1F 4C 2A AC                 L*.

; ----------------------------------------------------------------------------
; dragon/fire hits push player left
FORCE_PLAYER_LEFT:
        ; strip d-pad but set left as pressed
		; this bounces player back to left, away from dragon!
		lda     JOYPAD_INPUT                             ; AC22 A5 20                    . 
        and     #$F0                            ; AC24 29 F0                    ).
        ora     #BTN_LEFT                            ; AC26 09 02                    ..
        sta     JOYPAD_INPUT                             ; AC28 85 20                    . 
LAC2A:
        ; calc movement based on (fake) joypad input; branch if player descending
		jsr     DRAGON_FIGHT_CALC_PLAYER_MOVE_VECTOR                           ; AC2A 20 51 AE                  Q.
        lda     CTR_PLAYER_DESCENT                             ; AC2D A5 4E                    .N
        bne     LAC52                           ; AC2F D0 21                    .!
        
		; branch if jump still going up
		lda     JUMP_FRAMES_REMAINING                             ; AC31 A5 4F                    .O
        bne     LAC39                           ; AC33 D0 04                    ..
        
		; branch if a not pressed
		lda     JOYPAD_INPUT                             ; AC35 A5 20                    . 
        bpl     LAC41                           ; AC37 10 08                    ..
LAC39:
		; a pressed or previous jump still going up
        jsr     DRAGON_UPDATE_PLAYER_JUMP                           ; AC39 20 6D AC                  m.
        
		; kill any upward jumping
		lda     #$00                            ; AC3C A9 00                    ..
        jmp     LAC45                           ; AC3E 4C 45 AC                 LE.

; ----------------------------------------------------------------------------
LAC41:
		; not jumping
        lda     #$00                            ; AC41 A9 00                    ..
        sta     JUMP_FLAG                             ; AC43 85 22                    ."
LAC45:
        sta     JUMP_FRAMES_REMAINING                             ; AC45 85 4F                    .O
        
		; sets carry if oob due to horizontal movement
		jsr     DRAGON_FIX_DY_IF_OOB                           ; AC47 20 C7 AD                  ..
		
		; branch if in bounds
		bcc     LAC4F                           ; AC4A 90 03                    ..
        
		; jump if oob horizontally
		jmp     DRAGON_PLAYER_OOB                           ; AC4C 4C AF AC                 L..

; ----------------------------------------------------------------------------
LAC4F:
        jmp     DRAGON_PLAYER_IN_BOUNDS                           ; AC4F 4C A1 AC                 L..

; ----------------------------------------------------------------------------
LAC52:
		; jump here if player was descending while forced left
		; set descent velocity
        lsr     a                               ; AC52 4A                       J
        lsr     a                               ; AC53 4A                       J
        clc                                     ; AC54 18                       .
        adc     #$01                            ; AC55 69 01                    i.
        sta     PLAYER_DY                             ; AC57 85 4B                    .K
        jsr     DRAGON_FIX_DY_IF_OOB                           ; AC59 20 C7 AD                  ..
        bcs     LAC61                           ; AC5C B0 03                    ..
        jmp     DRAGON_PLAYER_IN_BOUNDS                           ; AC5E 4C A1 AC                 L..

; ----------------------------------------------------------------------------
LAC61:
		; kill dx and check bounds
        lda     #$00                            ; AC61 A9 00                    ..
        sta     PLAYER_DX                             ; AC63 85 49                    .I
        jsr     DRAGON_FIX_DY_IF_OOB                           ; AC65 20 C7 AD                  ..
        bcc     DRAGON_PLAYER_IN_BOUNDS                           ; AC68 90 37                    .7
        jmp     DRAGON_PLAYER_OOB                           ; AC6A 4C AF AC                 L..

; ----------------------------------------------------------------------------
DRAGON_UPDATE_PLAYER_JUMP:
        ; branch if frames remain in jump ascent - continue the jump
		ldx     JUMP_FRAMES_REMAINING                             ; AC6D A6 4F                    .O
        bne     LAC7E                           ; AC6F D0 0D                    ..
        
		; branch if no jump in progress, else rts
		lda     JUMP_FLAG                             ; AC71 A5 22                    ."
        beq     LAC76                           ; AC73 F0 01                    ..
        rts                                     ; AC75 60                       `

; ----------------------------------------------------------------------------
LAC76:
		; start a new jump!
        lda     #SOUND_JUMP                            ; AC76 A9 1B                    ..
        sta     NEXT_SOUND_EFFECT                             ; AC78 85 8F                    ..
        lda     PLAYER_JUMP_FRAMES                             ; AC7A A5 5C                    .\
        sta     JUMP_FRAMES_REMAINING                             ; AC7C 85 4F                    .O
LAC7E:
		; existing jump continue here
        pla                                     ; AC7E 68                       h
        pla                                     ; AC7F 68                       h
        lda     #$01                            ; AC80 A9 01                    ..
        sta     JUMP_FLAG                             ; AC82 85 22                    ."
        dec     JUMP_FRAMES_REMAINING                             ; AC84 C6 4F                    .O
        
		; -JUMP_FRAMES_REMAINING/4 + 1 = DY
		txa                                     ; AC86 8A                       .
        lsr     a                               ; AC87 4A                       J
        lsr     a                               ; AC88 4A                       J
        eor     #$FF                            ; AC89 49 FF                    I.
        clc                                     ; AC8B 18                       .
        adc     #$01                            ; AC8C 69 01                    i.
        sta     PLAYER_DY                             ; AC8E 85 4B                    .K
        
		; keep player in bounds
		jsr     DRAGON_FIX_DY_IF_OOB                           ; AC90 20 C7 AD                  ..
        bcc     DRAGON_PLAYER_IN_BOUNDS                           ; AC93 90 0C                    ..
        lda     #$00                            ; AC95 A9 00                    ..
        sta     PLAYER_DX                             ; AC97 85 49                    .I
        jsr     DRAGON_FIX_DY_IF_OOB                           ; AC99 20 C7 AD                  ..
        bcc     DRAGON_PLAYER_IN_BOUNDS                           ; AC9C 90 03                    ..
        jmp     DRAGON_PLAYER_OOB                           ; AC9E 4C AF AC                 L..

; ----------------------------------------------------------------------------
DRAGON_PLAYER_IN_BOUNDS:
		; jump here if fully in bounds; save new x and y positions
        lda     TEMP_NEXT_X_LO                             ; ACA1 A5 0E                    ..
        sta     PX_LO                             ; ACA3 85 43                    .C
        lda     TEMP_NEXT_Y                             ; ACA5 A5 0A                    ..
        sta     PY                             ; ACA7 85 45                    .E
        jsr     DRAGON_CHECK_HARD_LANDING                           ; ACA9 20 E4 AD                  ..
        jmp     DRAGON_UPDATE_AND_DRAW_PLAYER                           ; ACAC 4C BB AC                 L..

; ----------------------------------------------------------------------------
DRAGON_PLAYER_OOB:
		; branch here if oob horizontally - we just don't save the new x/y values!
		; not jumping
        lda     #$00                            ; ACAF A9 00                    ..
        sta     JUMP_FRAMES_REMAINING                             ; ACB1 85 4F                    .O
        sta     CTR_PLAYER_DESCENT                             ; ACB3 85 4E                    .N
        jsr     DRAGON_CHECK_HARD_LANDING                           ; ACB5 20 E4 AD                  ..
        jmp     DRAGON_UPDATE_AND_DRAW_PLAYER                           ; ACB8 4C BB AC                 L..

; ----------------------------------------------------------------------------
DRAGON_UPDATE_AND_DRAW_PLAYER:
        jsr     DRAGON_CALC_PLAYER_FRAME                           ; ACBB 20 E0 AC                  ..
        jsr     DRAGON_PLAYER_ANIMATIONS                           ; ACBE 20 3B AD                  ;.
        jsr     DRAW_PLAYER_SINGLE_SCREEN                           ; ACC1 20 7A AD                  z.
        rts                                     ; ACC4 60                       `

; ----------------------------------------------------------------------------

DRAGON_MOVE_PLAYER:
        lda     PX_LO                             ; ACC5 A5 43                    .C
        sta     TEMP_NEXT_X_LO                             ; ACC7 85 0E                    ..
        lda     PY                             ; ACC9 A5 45                    .E
        sta     TEMP_NEXT_Y                             ; ACCB 85 0A                    ..
        
		; branch if not moving vertically
		lda     PLAYER_DY                             ; ACCD A5 4B                    .K
        beq     LACD6                           ; ACCF F0 05                    ..
        
		; else apply y movement
		clc                                     ; ACD1 18                       .
        adc     TEMP_NEXT_Y                             ; ACD2 65 0A                    e.
        sta     TEMP_NEXT_Y                             ; ACD4 85 0A                    ..
LACD6:
		; branch if not moving horizontally
        lda     PLAYER_DX                             ; ACD6 A5 49                    .I
        beq     LACDF                           ; ACD8 F0 05                    ..
        
		; else apply dx
		clc                                     ; ACDA 18                       .
        adc     TEMP_NEXT_X_LO                             ; ACDB 65 0E                    e.
        sta     TEMP_NEXT_X_LO                             ; ACDD 85 0E                    ..
LACDF:
        rts                                     ; ACDF 60                       `

; ----------------------------------------------------------------------------
; simplified version of CALC_PLAYER_FRAME_AND_SPRITE_FLAGS
DRAGON_CALC_PLAYER_FRAME:
		; branch if A or A+B are pressed, nothing else
		; x = player frame
        ldx     #$09                            ; ACE0 A2 09                    ..
        lda     JOYPAD_INPUT                             ; ACE2 A5 20                    . 
        and     #$BF                            ; ACE4 29 BF                    ).
        cmp     #$80                            ; ACE6 C9 80                    ..
        beq     LAD1F                           ; ACE8 F0 35                    .5
        
		; some other combo; branch if not moving vertically
		lda     PLAYER_DY                             ; ACEA A5 4B                    .K
        beq     LAD06                           ; ACEC F0 18                    ..
        
		; branch if moving up
		bmi     LACFF                           ; ACEE 30 0F                    0.
        
		; moving down; branch if descent ctr <> 0
		lda     CTR_PLAYER_DESCENT                             ; ACF0 A5 4E                    .N
        bne     LAD22                           ; ACF2 D0 2E                    ..
        
		; branch if up not pressed
		lda     JOYPAD_INPUT                             ; ACF4 A5 20                    . 
        and     #$04                            ; ACF6 29 04                    ).
        beq     LAD06                           ; ACF8 F0 0C                    ..
        
		; up pressed
		ldx     #$0D                            ; ACFA A2 0D                    ..
        jmp     LAD1F                           ; ACFC 4C 1F AD                 L..

; ----------------------------------------------------------------------------
LACFF:
		; branch if no jump ascent in progress
        lda     JUMP_FRAMES_REMAINING                             ; ACFF A5 4F                    .O
        beq     LAD1F                           ; AD01 F0 1C                    ..
        
		; else jump
		jmp     LAD22                           ; AD03 4C 22 AD                 L".

; ----------------------------------------------------------------------------
LAD06:
        ldx     #$01                            ; AD06 A2 01                    ..
        ldy     #$00                            ; AD08 A0 00                    ..
        
		; branch if moving left
		lda     PLAYER_DX                             ; AD0A A5 49                    .I
        bmi     LAD12                           ; AD0C 30 04                    0.
        
		; or not moving horizontally (rts)
		beq     LAD21                           ; AD0E F0 11                    ..
        
		; moving right - flip horizontally
		ldy     #$40                            ; AD10 A0 40                    .@
LAD12:
        stx     SCRATCH_08                             ; AD12 86 08                    ..
        
		; clear PLAYER_FRAME upper nibble; set bit 0
		lda     PLAYER_FRAME                             ; AD14 A5 56                    .V
        and     #$07                            ; AD16 29 07                    ).
        ora     SCRATCH_08                             ; AD18 05 08                    ..
        sta     PLAYER_FRAME                             ; AD1A 85 56                    .V
        sty     PLAYER_SPRITE_FLAGS                             ; AD1C 84 57                    .W
        rts                                     ; AD1E 60                       `

; ----------------------------------------------------------------------------
LAD1F:
        stx     PLAYER_FRAME                             ; AD1F 86 56                    .V
LAD21:
        rts                                     ; AD21 60                       `

; ----------------------------------------------------------------------------
LAD22: ; player jump ascent in progress
        ldx     #$39                            ; AD22 A2 39                    .9
        ldy     #$00                            ; AD24 A0 00                    ..
        
		; branch if moving left
		lda     PLAYER_DX                             ; AD26 A5 49                    .I
        bmi     LAD2E                           ; AD28 30 04                    0.
        
		; or not moving horizontally (rts)
		beq     LAD21                           ; AD2A F0 F5                    ..
        
		; moving right - flip horizontally
		ldy     #$40                            ; AD2C A0 40                    .@
LAD2E:
        stx     SCRATCH_08                             ; AD2E 86 08                    ..
        
		; clear upper 6 bits of PLAYER_FRAME; then ORA x39
		lda     PLAYER_FRAME                             ; AD30 A5 56                    .V
        and     #$03                            ; AD32 29 03                    ).
        ora     SCRATCH_08                             ; AD34 05 08                    ..
        sta     PLAYER_FRAME                             ; AD36 85 56                    .V
        sty     PLAYER_SPRITE_FLAGS                             ; AD38 84 57                    .W
        rts                                     ; AD3A 60                       `

; ----------------------------------------------------------------------------
; walking animations for dragon fight; simplified version of APPLY_PLAYER_FRAME_ANIMATIONS
DRAGON_PLAYER_ANIMATIONS:
        lda     PLAYER_FRAME                             ; AD3B A5 56                    .V
        cmp     #$20                            ; AD3D C9 20                    . 
        bcs     LAD50                           ; AD3F B0 0F                    ..
        lda     PLAYER_FRAME                             ; AD41 A5 56                    .V
        bit     JOYPAD_INPUT                             ; AD43 24 20                    $ 
        bvs     LAD4C                           ; AD45 70 05                    p.
        and     #OFFSCREEN_Y                            ; AD47 29 EF                    ).
        jmp     LAD4E                           ; AD49 4C 4E AD                 LN.

; ----------------------------------------------------------------------------
LAD4C:
        ora     #$10                            ; AD4C 09 10                    ..
LAD4E:
        sta     PLAYER_FRAME                             ; AD4E 85 56                    .V
LAD50:
        lda     JOYPAD_INPUT                             ; AD50 A5 20                    . 
        and     #$0F                            ; AD52 29 0F                    ).
        beq     LAD79                           ; AD54 F0 23                    .#
        lda     JUMP_FRAMES_REMAINING                             ; AD56 A5 4F                    .O
        ora     CTR_PLAYER_DESCENT                             ; AD58 05 4E                    .N
        bne     LAD79                           ; AD5A D0 1D                    ..
        inc     CTR_PLAYER_WALK_ANIMATION                             ; AD5C E6 4D                    .M
        lda     CTR_PLAYER_WALK_ANIMATION                             ; AD5E A5 4D                    .M
        and     #$07                            ; AD60 29 07                    ).
        bne     LAD79                           ; AD62 D0 15                    ..
        lda     PLAYER_FRAME                             ; AD64 A5 56                    .V
        and     #$08                            ; AD66 29 08                    ).
        bne     LAD73                           ; AD68 D0 09                    ..
        lda     PLAYER_FRAME                             ; AD6A A5 56                    .V
        eor     #$04                            ; AD6C 49 04                    I.
        sta     PLAYER_FRAME                             ; AD6E 85 56                    .V
        jmp     LAD79                           ; AD70 4C 79 AD                 Ly.

; ----------------------------------------------------------------------------
LAD73:
        ; flip bit 6 (horiz flip)
		lda     PLAYER_SPRITE_FLAGS                             ; AD73 A5 57                    .W
        eor     #$40                            ; AD75 49 40                    I@
        sta     PLAYER_SPRITE_FLAGS                             ; AD77 85 57                    .W
LAD79:
        rts                                     ; AD79 60                       `

; ----------------------------------------------------------------------------
; simpler version used e.g. for dragon fight without horizontal scrolling
DRAW_PLAYER_SINGLE_SCREEN:
		; branch if not invulnerable
        lda     INVULN_CTR                             ; AD7A A5 85                    ..
        beq     LAD8D                           ; AD7C F0 0F                    ..
        
		; invulnerable; branch if counter odd
		lda     FRAME_CTR                             ; AD7E A5 84                    ..
        and     #$01                            ; AD80 29 01                    ).
        bne     LAD8D                           ; AD82 D0 09                    ..
        
		; even counter, invulnerable = don't draw
		lda     #OFFSCREEN_Y                            ; AD84 A9 EF                    ..
        sta     PLAYER_SPRITE_0                           ; AD86 8D 10 02                 ...
        sta     PLAYER_SPRITE_1                           ; AD89 8D 14 02                 ...
        rts                                     ; AD8C 60                       `

; ----------------------------------------------------------------------------
LAD8D:
		; set player y
        lda     PY                             ; AD8D A5 45                    .E
        clc                                     ; AD8F 18                       .
        adc     #OBJ_SCREEN_Y_PAD                            ; AD90 69 2B                    i+
        sta     PLAYER_SPRITE_0                           ; AD92 8D 10 02                 ...
        sta     PLAYER_SPRITE_1                           ; AD95 8D 14 02                 ...
        
		; hey, PX_LO is just the on-screen player pos, a simplification
		; from when we're on dungeon levels
		lda     PX_LO                             ; AD98 A5 43                    .C
        sta     PLAYER_SPRITE_0_X                           ; AD9A 8D 13 02                 ...
        clc                                     ; AD9D 18                       .
        adc     #$08                            ; AD9E 69 08                    i.
        sta     PLAYER_SPRITE_1_X                           ; ADA0 8D 17 02                 ...
       
        ; set bit 5 (behind bg)  
        lda     PLAYER_SPRITE_FLAGS                             ; ADA3 A5 57                    .W
        ora     #$20                            ; ADA5 09 20                    . 
        sta     PLAYER_SPRITE_0_FLAGS                           ; ADA7 8D 12 02                 ...
        sta     PLAYER_SPRITE_1_FLAGS                           ; ADAA 8D 16 02                 ...
        
		; branch if horizontally flipped
		bit     PLAYER_SPRITE_FLAGS                             ; ADAD 24 57                    $W
        bvs     LADBC                           ; ADAF 70 0B                    p.
        
		; not horizontally flipped
		ldx     PLAYER_FRAME                             ; ADB1 A6 56                    .V
        stx     PLAYER_SPRITE_0_ID                           ; ADB3 8E 11 02                 ...
        inx                                     ; ADB6 E8                       .
        inx                                     ; ADB7 E8                       .
        stx     PLAYER_SPRITE_1_ID                           ; ADB8 8E 15 02                 ...
        rts                                     ; ADBB 60                       `

; ----------------------------------------------------------------------------
LADBC:
		; horizontally flipped
        ldx     PLAYER_FRAME                             ; ADBC A6 56                    .V
        stx     PLAYER_SPRITE_1_ID                           ; ADBE 8E 15 02                 ...
        inx                                     ; ADC1 E8                       .
        inx                                     ; ADC2 E8                       .
        stx     PLAYER_SPRITE_0_ID                           ; ADC3 8E 11 02                 ...
        rts                                     ; ADC6 60                       `

; ----------------------------------------------------------------------------
DRAGON_FIX_DY_IF_OOB:
        lda     PLAYER_DY                             ; ADC7 A5 4B                    .K
        pha                                     ; ADC9 48                       H
LADCA:
        jsr     DRAGON_MOVE_PLAYER                           ; ADCA 20 C5 AC                  ..
        jsr     DRAGON_CHECK_PLAYER_BOUNDS                           ; ADCD 20 41 AE                  A.
        
		; branch if player in bounds
		bcc     LADE0                           ; ADD0 90 0E                    ..
        
		; oob - branch (set carry) if not moving vertically 
		ldx     PLAYER_DY                             ; ADD2 A6 4B                    .K
        beq     LADDF                           ; ADD4 F0 09                    ..
        
		; branch (inc dy) if moving up
		bmi     LADDA                           ; ADD6 30 02                    0.
        
		; otherwise net dec dy if moving down
		dex                                     ; ADD8 CA                       .
        dex                                     ; ADD9 CA                       .
LADDA:
        inx                                     ; ADDA E8                       .
        stx     PLAYER_DY                             ; ADDB 86 4B                    .K
        
		; having decreased speed, we try again!
		bne     LADCA                           ; ADDD D0 EB                    ..
LADDF:
		; happens if oob due to horizontal movement
        sec                                     ; ADDF 38                       8
LADE0:
        pla                                     ; ADE0 68                       h
        sta     PLAYER_DY                             ; ADE1 85 4B                    .K
        rts                                     ; ADE3 60                       `

; ----------------------------------------------------------------------------
; also notes if player is descending
; I guess Roas could get a hard landing if bounced at the top of a jump? Kinda rough.
DRAGON_CHECK_HARD_LANDING:
		; branch if no jump frames remaining
        lda     JUMP_FRAMES_REMAINING                             ; ADE4 A5 4F                    .O
        beq     LADEA                           ; ADE6 F0 02                    ..
        clc                                     ; ADE8 18                       .
        rts                                     ; ADE9 60                       `

; ----------------------------------------------------------------------------
LADEA:
		; no jump frames remain; 
        lda     PY                             ; ADEA A5 45                    .E
        cmp     #$A0                            ; ADEC C9 A0                    ..
        bcs     LADF3                           ; ADEE B0 03                    ..
        inc     CTR_PLAYER_DESCENT                             ; ADF0 E6 4E                    .N
        rts                                     ; ADF2 60                       `

; ----------------------------------------------------------------------------
LADF3:
		; branch if player has fallen fewer frames than their jump height
        lda     CTR_PLAYER_DESCENT                             ; ADF3 A5 4E                    .N
        cmp     PLAYER_JUMP_FRAMES                             ; ADF5 C5 5C                    .\
        bcc     LAE0C                           ; ADF7 90 13                    ..
        sec                                     ; ADF9 38                       8
        sbc     #$07                            ; ADFA E9 07                    ..
        cmp     PLAYER_JUMP_FRAMES                             ; ADFC C5 5C                    .\
        bcc     LAE02                           ; ADFE 90 02                    ..
        lda     PLAYER_JUMP_FRAMES                             ; AE00 A5 5C                    .\
LAE02:
        sec                                     ; AE02 38                       8
        sbc     #$01                            ; AE03 E9 01                    ..
        sta     JUMP_FRAMES_REMAINING                             ; AE05 85 4F                    .O
        lda     #SOUND_HARD_LANDING                            ; AE07 A9 0A                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; AE09 8D 8F 00                 ...
LAE0C:
        lda     #$00                            ; AE0C A9 00                    ..
        sta     CTR_PLAYER_DESCENT                             ; AE0E 85 4E                    .N
        rts                                     ; AE10 60                       `

; ----------------------------------------------------------------------------
DRAGON_FIGHT_START_PRESSED:
        lda     #SOUND_OPEN_START_MENU                            ; AE11 A9 03                    ..
        sta     NEXT_SOUND_EFFECT                             ; AE13 85 8F                    ..
        inc     FLAG_START_SCREEN_OPEN                             ; AE15 E6 8D                    ..

; loop until no joypad input
LAE17:
        jsr     READ_JOYPADS                           ; AE17 20 43 CC                  C.
        bne     LAE17                           ; AE1A D0 FB                    ..

; read joypads again
LAE1C:
        jsr     READ_JOYPADS                           ; AE1C 20 43 CC                  C.
        and     #BTN_START                            ; AE1F 29 10                    ).
        
		; loop if start not pressed
		beq     LAE1C                           ; AE21 F0 F9                    ..

		; start was pressed
		; loop until nothing pressed
LAE23:
        jsr     READ_JOYPADS                           ; AE23 20 43 CC                  C.
        bne     LAE23                           ; AE26 D0 FB                    ..
        
		; nothing pressed on dpad
		lda     #SOUND_CLOSE_START_MENU                            ; AE28 A9 04                    ..
        sta     NEXT_SOUND_EFFECT                             ; AE2A 85 8F                    ..
        dec     FLAG_START_SCREEN_OPEN                             ; AE2C C6 8D                    ..
        rts                                     ; AE2E 60                       `

; ----------------------------------------------------------------------------
; input: a = how much damage
DRAGON_DAMAGE_PLAYER:
        sta     SCRATCH_08                             ; AE2F 85 08                    ..
        lda     PLAYER_LIFE                             ; AE31 A5 58                    .X
        sec                                     ; AE33 38                       8
        sbc     SCRATCH_08                             ; AE34 E5 08                    ..
        sta     PLAYER_LIFE                             ; AE36 85 58                    .X
        php                                     ; AE38 08                       .
        
		; branch if player still has life
		bcs     LAE3F                           ; AE39 B0 04                    ..
        
		; no life; set it to 0
		lda     #$00                            ; AE3B A9 00                    ..
        sta     PLAYER_LIFE                             ; AE3D 85 58                    .X
LAE3F:
        plp                                     ; AE3F 28                       (
        rts                                     ; AE40 60                       `

; ----------------------------------------------------------------------------
; sets carry if player NEXT Y/X_LO are OOB
DRAGON_CHECK_PLAYER_BOUNDS:
        ; branch (set carry) if too low
		lda     TEMP_NEXT_Y                             ; AE41 A5 0A                    ..
        cmp     #$A1                            ; AE43 C9 A1                    ..
        bcs     LAE4D                           ; AE45 B0 06                    ..
        
		; branch (clear carry) if not too far right
		lda     TEMP_NEXT_X_LO                             ; AE47 A5 0E                    ..
        cmp     #$F1                            ; AE49 C9 F1                    ..
        bcc     LAE4F                           ; AE4B 90 02                    ..
LAE4D:
		; oob
        sec                                     ; AE4D 38                       8
        rts                                     ; AE4E 60                       `

; ----------------------------------------------------------------------------
LAE4F:
		; in bounds
        clc                                     ; AE4F 18                       .
        rts                                     ; AE50 60                       `

; ----------------------------------------------------------------------------
; calculates basic dx/dy for any dpad input, assuming speed of 1
DRAGON_FIGHT_CALC_PLAYER_MOVE_VECTOR:
        ; mult dpad lower nibble by 2 --> x index into table
		lda     JOYPAD_INPUT                             ; AE51 A5 20                    . 
        and     #$0F                            ; AE53 29 0F                    ).
        asl     a                               ; AE55 0A                       .
        tax                                     ; AE56 AA                       .
        
		; grab the x and y speeds
		lda     TBL_DPAD_TO_DX,x                         ; AE57 BD 8B FE                 ...
        sta     a:PLAYER_DX                           ; AE5A 8D 49 00                 .I.
        lda     TBL_DPAD_TO_DY,x                         ; AE5D BD 8C FE                 ...
        sta     a:PLAYER_DY                           ; AE60 8D 4B 00                 .K.
        rts                                     ; AE63 60                       `

; ----------------------------------------------------------------------------
; END OF DRAGON FIGHT CODE
; ----------------------------------------------------------------------------

; LOAD_START_SCREEN $AE64 
LOAD_START_SCREEN:
        ; data cleanup, select pattern table (don't think it's used, though as it's overwritten below)
		jsr     WIPE_PLAYER_AND_PALETTE_DATA                           ; AE64 20 31 B6                  1.
        lda     #$37                            ; AE67 A9 37                    .7
        sta     CHR_BANK_PLAYER_SPRITES                             ; AE69 85 2C                    .,
        lda     #$00                            ; AE6B A9 00                    ..
        sta     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; AE6D 85 29                    .)
        
		; nmi enable, 8x16 sprites
		lda     #$A0                            ; AE6F A9 A0                    ..
        sta     PPU_CTRL_COPY                             ; AE71 85 23                    .#
        sta     PPU_CTRL                           ; AE73 8D 00 20                 .. 
        lda     #$00                            ; AE76 A9 00                    ..
        sta     PPU_MASK_COPY                             ; AE78 85 24                    .$
        sta     PPU_MASK                           ; AE7A 8D 01 20                 .. 
        lda     #$00                            ; AE7D A9 00                    ..
        sta     PPU_SCROLL_X                             ; AE7F 85 1C                    ..
        sta     PPU_NAMETABLE_SELECT                             ; AE81 85 1D                    ..
        lda     #$E8                            ; AE83 A9 E8                    ..
        sta     PPU_SCROLL_Y                             ; AE85 85 1E                    ..
        
		; loop to wipe palette data buffer
		lda     #$0F                            ; AE87 A9 0F                    ..
        ldx     #$1F                            ; AE89 A2 1F                    ..
LAE8B:
        sta     DATA_BUFFER_0180,x                         ; AE8B 9D 80 01                 ...
        dex                                     ; AE8E CA                       .
        bpl     LAE8B                           ; AE8F 10 FA                    ..
        
		; jump to $c569 / NMI_UPDATE_PALETTE_FROM_BUFFER
		lda     #$69                            ; AE91 A9 69                    .i
        sta     JMP_DEST_0E_LO                             ; AE93 85 0E                    ..
        lda     #$C5                            ; AE95 A9 C5                    ..
        sta     JMP_DEST_0F_HI                             ; AE97 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; AE99 20 E4 CC                  ..
        
		; init/clear RAM and set pattern table
		jsr     CLEAR_ALL_OBJECTS                           ; AE9C 20 8A D0                  ..
        jsr     WIPE_SPRITES_EXCEPT_0                           ; AE9F 20 75 C3                  u.
        jsr     LOAD_START_SCREEN_SPRITES                           ; AEA2 20 02 B1                  ..
        lda     #$15                            ; AEA5 A9 15                    ..
        sta     CHR_BANK_PLAYER_SPRITES                             ; AEA7 85 2C                    .,
        
		; init music and graphics
		lda     #MUSIC_START_SCREEN                            ; AEA9 A9 09                    ..
        sta     MUSIC_ID                             ; AEAB 85 8E                    ..
        jsr     LOAD_MUSIC_DATA                           ; AEAD 20 08 FC                  ..
        jsr     LOAD_START_SCREEN_GRAPHICS                           ; AEB0 20 48 B6                  H.
        
		; enable sprite/bg rendering, use left 8 px of screen
		lda     #$1E                            ; AEB3 A9 1E                    ..
        sta     PPU_MASK_COPY                             ; AEB5 85 24                    .$
        sta     PPU_MASK                           ; AEB7 8D 01 20                 .. 
        
		; wait 2 seconds
		lda     #$78                            ; AEBA A9 78                    .x
        sta     NMI_WAIT_CTR                             ; AEBC 85 36                    .6
LAEBE:
        lda     NMI_WAIT_CTR                             ; AEBE A5 36                    .6
        bne     LAEBE                           ; AEC0 D0 FC                    ..
        
		; show the start screen!
		jsr     START_SCREEN_FADE_IN                           ; AEC2 20 A6 B6                  ..
        
		; prep 20 seconds wait (if start not pressed)
		lda     #$14                            ; AEC5 A9 14                    ..
        sta     CTR_WAIT_SECONDS                             ; AEC7 85 8C                    ..

START_SCREEN_MAIN_LOOP:
        ; check input every frame
		lda     #$01                            ; AEC9 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; AECB 85 36                    .6
        
		; branch if cheat input (all buttons and d-pad) not present
		jsr     READ_JOYPADS                           ; AECD 20 43 CC                  C.
        cmp     #$FF                            ; AED0 C9 FF                    ..
        bne     LAEDA                           ; AED2 D0 06                    ..
 
		; all buttons and d-pad pressed - enable cheat mode
		lda     #SOUND_CHEAT_MODE                            ; AED4 A9 1A                    ..
        sta     NEXT_SOUND_EFFECT                             ; AED6 85 8F                    ..
        sta     CHEAT_STATUS                             ; AED8 85 37                    .7
LAEDA:
        ; branch if start pressed - here we go!
		; if we're cheating, a=x1a here, so should branch
		and     #$10                            ; AEDA 29 10                    ).
        bne     JUMP_TO_START_GAME                           ; AEDC D0 39                    .9
        
		; only place JOYPAD_INPUT_TMP is used...
		; branch if equal to L+R+A on expansion controller
		; unfortunately, looks like extra bits from expansion controller/microphone are only
		; reported via the joypad registers on a Famicom, not NES, so no jump for us. :(
		; see: https://www.nesdev.org/wiki/Standard_controller
		lda     JOYPAD_INPUT_TMP                             ; AEDE A5 21                    .!
        cmp     #$83                            ; AEE0 C9 83                    ..
        beq     JUMP_TO_CREDITS                           ; AEE2 F0 36                    .6
        
		; animation loop for start text - modifies palette buffer entries $0180-019f
		lda     FRAME_CTR                             ; AEE4 A5 84                    ..
        and     #$07                            ; AEE6 29 07                    ).
        bne     LAF05                           ; AEE8 D0 1B                    ..
        
		; 1 in 8 frames update its state
		lda     DATA_BUFFER_0180+$02                           ; AEEA AD 82 01                 ...
        and     #$0F                            ; AEED 29 0F                    ).
        sta     SCRATCH_08                             ; AEEF 85 08                    ..
        
		; resets to x30 when < x10
		lda     DATA_BUFFER_0180+$02                           ; AEF1 AD 82 01                 ...
        and     #$F0                            ; AEF4 29 F0                    ).
        sec                                     ; AEF6 38                       8
        sbc     #$10                            ; AEF7 E9 10                    ..
        bcs     LAEFD                           ; AEF9 B0 02                    ..
        
		lda     #$30                            ; AEFB A9 30                    .0
LAEFD:
        sta     DATA_BUFFER_0180+$13                           ; AEFD 8D 93 01                 ...
        ora     SCRATCH_08                             ; AF00 05 08                    ..
        sta     DATA_BUFFER_0180+$02 ; AF02 8D 82 01                 ...
		
LAF05: 
		; jump to $c135 - NMI_CLEAR_FLAGS_AND_WAIT
        lda     #$35                            ; AF05 A9 35                    .5
        sta     JMP_DEST_0E_LO                             ; AF07 85 0E                    ..
        lda     #$C1                            ; AF09 A9 C1                    ..
        sta     JMP_DEST_0F_HI                             ; AF0B 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; AF0D 20 E4 CC                  ..
        
		; loop while CTR_WAIT_SECONDS > 0, then go to demo
		lda     CTR_WAIT_SECONDS                             ; AF10 A5 8C                    ..
        bne     START_SCREEN_MAIN_LOOP                           ; AF12 D0 B5                    ..
        jmp     DEMO_MAIN                           ; AF14 4C 1D AF                 L..

; ----------------------------------------------------------------------------
JUMP_TO_START_GAME:
        jmp     START_GAME_FOR_REAL                           ; AF17 4C B1 B0                 L..

; ----------------------------------------------------------------------------
JUMP_TO_CREDITS:
        jmp     ENDING_CREDITS_ROLL                           ; AF1A 4C 3D B1                 L=.

; ----------------------------------------------------------------------------
; gameplay demo before you press start
DEMO_MAIN:
		; fade out, clean-up, load sprites for demo
        jsr     PALETTE_FADE_OUT_LC461                           ; AF1D 20 61 C4                  a.
        jsr     WIPE_SPRITES_EXCEPT_0                           ; AF20 20 75 C3                  u.
        jsr     CLEAR_ALL_OBJECTS                           ; AF23 20 8A D0                  ..
        jsr     LOAD_DEMO_SPRITES                           ; AF26 20 0E B1                  ..
        
		; random map within normal dungeon; x=0-3, y=0-f
		lda     #$04                            ; AF29 A9 04                    ..
        jsr     UPDATE_RNG                           ; AF2B 20 64 CC                  d.
        sta     MAP_X                             ; AF2E 85 47                    .G
        lda     #$10                            ; AF30 A9 10                    ..
        jsr     UPDATE_RNG                           ; AF32 20 64 CC                  d.
        sta     MAP_Y                             ; AF35 85 48                    .H
        
		; setup jump to $c8f2 (LOAD_MAP_FULL)
		lda     #$F2                            ; AF37 A9 F2                    ..
        sta     JMP_DEST_0E_LO                             ; AF39 85 0E                    ..
        lda     #$C8                            ; AF3B A9 C8                    ..
        sta     JMP_DEST_0F_HI                             ; AF3D 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; AF3F 20 E4 CC                  ..
LAF42:
        ; choose random player x hi and y
		lda     #$40                            ; AF42 A9 40                    .@
        jsr     UPDATE_RNG                           ; AF44 20 64 CC                  d.
        sta     PX_HI                             ; AF47 85 44                    .D
        sta     SCRATCH_0C                             ; AF49 85 0C                    ..
        lda     #$00                            ; AF4B A9 00                    ..
        sta     PX_LO                             ; AF4D 85 43                    .C
        lda     #$0B                            ; AF4F A9 0B                    ..
        jsr     UPDATE_RNG                           ; AF51 20 64 CC                  d.
        asl     a                               ; AF54 0A                       .
        asl     a                               ; AF55 0A                       .
        asl     a                               ; AF56 0A                       .
        asl     a                               ; AF57 0A                       .
        sta     PY                             ; AF58 85 45                    .E
        
		; prep to draw at this location
		sta     PLAYER_MAP_TILE_HI                             ; AF5A 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; AF5C 20 54 CA                  T.
        
		; loop if that location is a solid tile
		ldy     #$00                            ; AF5F A0 00                    ..
        lda     ($0C),y                         ; AF61 B1 0C                    ..
        and     #$3F                            ; AF63 29 3F                    )?
        cmp     #$30                            ; AF65 C9 30                    .0
        bcs     LAF42                           ; AF67 B0 D9                    ..
        
		; loop if tile id=2 
		cmp     #$02                            ; AF69 C9 02                    ..
        beq     LAF42                           ; AF6B F0 D5                    ..
        
		; loop if it's a fake tile
		cmp     MAP_FAKE_TILE_ID                             ; AF6D C5 70                    .p
        beq     LAF42                           ; AF6F F0 D1                    ..
        
		; now check beneath player and loop if not a solid tile
		iny                                     ; AF71 C8                       .
        lda     ($0C),y                         ; AF72 B1 0C                    ..
        and     #$3F                            ; AF74 29 3F                    )?
        cmp     #$30                            ; AF76 C9 30                    .0
        bcc     LAF42                           ; AF78 90 C8                    ..
        beq     LAF42                           ; AF7A F0 C6                    ..
        
		; constrain SCROLL_X_HI between 0 and x30
		; branch if px_hi >= 8
		lda     PX_HI                             ; AF7C A5 44                    .D
        sec                                     ; AF7E 38                       8
        sbc     #$08                            ; AF7F E9 08                    ..
        bcs     LAF85                           ; AF81 B0 02                    ..
        
		; otherwise, set tentative scroll x to 0
		lda     #$00                            ; AF83 A9 00                    ..
LAF85:
        ; now branch if less than x30
		cmp     #$30                            ; AF85 C9 30                    .0
        bcc     LAF8B                           ; AF87 90 02                    ..
        
		; otherwise, set to x30
		lda     #$30                            ; AF89 A9 30                    .0
LAF8B:
        sta     SCROLL_X_HI                             ; AF8B 85 7C                    .|
        
		; align scroll to blocks
		lda     #$00                            ; AF8D A9 00                    ..
        sta     SCROLL_X_LO                             ; AF8F 85 7B                    .{
LAF91:
        ; for each demo scene, a random value 0-4 is chosen and used both as 
		; PLAYER_ID and index into TBL_DEMO_ITEMS, so all 5 players can be seen
		; in the demo and each will always have the same, single item equipped in
		; the first slot. 
		; Slightly hilarious is the fact that Pochi gets equipped with the knuckle,
		; which he can't actually use in the real game...
		lda     #$05                            ; AF91 A9 05                    ..
        jsr     UPDATE_RNG                           ; AF93 20 64 CC                  d.
        tax                                     ; AF96 AA                       .
        tay                                     ; AF97 A8                       .
        
		; set carry for loop below
		sec                                     ; AF98 38                       8
        lda     #$00                            ; AF99 A9 00                    ..
LAF9B:
		; rol carry bit into slot in a corresponding to y, e.g. 0x02 if y=1
        rol     a                               ; AF9B 2A                       *
        dey                                     ; AF9C 88                       .
        bpl     LAF9B                           ; AF9D 10 FC                    ..
        
		; loop and pick a new slot if this doesn't match any bits in MAP_PREFERRED_PLAYERS
		; prevents player from appearing on a family member's map
		and     MAP_PREFERRED_PLAYERS                             ; AF9F 25 41                    %A
        beq     LAF91                           ; AFA1 F0 EE                    ..
        
		; equip item
		lda     TBL_DEMO_ITEMS,x                         ; AFA3 BD AC B0                 ...
        sta     CUR_EQUIP_ITEMS                             ; AFA6 85 51                    .Q
        lda     #$00                            ; AFA8 A9 00                    ..
        sta     CUR_EQUIP_SLOT_SELECTED                             ; AFAA 85 55                    .U
        
		; assign player
		stx     PLAYER_ID                             ; AFAC 86 40                    .@
        txa                                     ; AFAE 8A                       .
        asl     a                               ; AFAF 0A                       .
        asl     a                               ; AFB0 0A                       .
        clc                                     ; AFB1 18                       .
        adc     #$03                            ; AFB2 69 03                    i.
        tay                                     ; AFB4 A8                       .
        ldx     #$03                            ; AFB5 A2 03                    ..
LAFB7:
		; load the player's stats (jump frames, shot power, etc) 
        lda     TBL_PLAYER_STATS,y                         ; AFB7 B9 A7 FF                 ...
        sta     PLAYER_JUMP_FRAMES,x                           ; AFBA 95 5C                    .\
        dey                                     ; AFBC 88                       .
        dex                                     ; AFBD CA                       .
        bpl     LAFB7                           ; AFBE 10 F7                    ..
        
		; set pattern table for specific player
		lda     PLAYER_ID                             ; AFC0 A5 40                    .@
        clc                                     ; AFC2 18                       .
        adc     #$38                            ; AFC3 69 38                    i8
        sta     CHR_BANK_PLAYER_SPRITES                             ; AFC5 85 2C                    .,
        
		; set pattern tables for items
		lda     #$3E                            ; AFC7 A9 3E                    .>
        sta     CHR_BANK_SPRITES_02                             ; AFC9 85 2E                    ..
        lda     #$20                            ; AFCB A9 20                    . 
        sta     CHR_BANK_SPRITES_03                             ; AFCD 85 2F                    ./
        lda     #$0D                            ; AFCF A9 0D                    ..
        sta     PLAYER_FRAME                             ; AFD1 85 56                    .V
        lda     #$00                            ; AFD3 A9 00                    ..
        sta     PLAYER_SPRITE_FLAGS                             ; AFD5 85 57                    .W
        lda     #$01                            ; AFD7 A9 01                    ..
        sta     DEMO_INPUT_CTR                             ; AFD9 85 42                    .B
        
		; full life/magic
		lda     #$64                            ; AFDB A9 64                    .d
        sta     PLAYER_LIFE                             ; AFDD 85 58                    .X
        sta     PLAYER_MAGIC                             ; AFDF 85 59                    .Y
        
		; jump to $c38b / WIPE_NAMETABLE
		lda     #$8B                            ; AFE1 A9 8B                    ..
        sta     JMP_DEST_0E_LO                             ; AFE3 85 0E                    ..
        lda     #$C3                            ; AFE5 A9 C3                    ..
        sta     JMP_DEST_0F_HI                             ; AFE7 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; AFE9 20 E4 CC                  ..
        
		; prep the status bar
		jsr     LOAD_STATUS_BAR_GRAPHICS                           ; AFEC 20 7A C5                  z.
        
		; jump to $c5cb / LOAD_GRAPHICS_FOR_MAP_LEVEL
		lda     #$CB                            ; AFEF A9 CB                    ..
        sta     JMP_DEST_0E_LO                             ; AFF1 85 0E                    ..
        lda     #$C5                            ; AFF3 A9 C5                    ..
        sta     JMP_DEST_0F_HI                             ; AFF5 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; AFF7 20 E4 CC                  ..
        
		; update visuals
		jsr     EVENT_PLAYER_LIFE_CHANGE                           ; AFFA 20 B6 CA                  ..
        jsr     EVENT_PLAYER_MAGIC_CHANGE                           ; AFFD 20 CC CA                  ..
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; B000 20 F8 CA                  ..
        jsr     EVENT_PLAYER_KEY_CHANGE                           ; B003 20 E2 CA                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; B006 20 C7 C1                  ..
        jsr     HIDE_SPRITES_280_UP                           ; B009 20 7C D0                  |.
        jsr     DRAW_PLAYER                           ; B00C 20 D8 C1                  ..
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; B00F 20 34 C2                  4.
        
		; jump to $c492 / PALETTE_FADE_IN
		lda     #$92                            ; B012 A9 92                    ..
        sta     JMP_DEST_0E_LO                             ; B014 85 0E                    ..
        lda     #$C4                            ; B016 A9 C4                    ..
        sta     JMP_DEST_0F_HI                             ; B018 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B01A 20 E4 CC                  ..
        
		; wait 10 seconds while demo plays
		lda     #$0A                            ; B01D A9 0A                    ..
        sta     CTR_WAIT_SECONDS                             ; B01F 85 8C                    ..

DEMO_GAMEPLAY_LOOP:
        lda     #$01                            ; B021 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; B023 85 36                    .6
        lda     SCROLL_X_HI                             ; B025 A5 7C                    .|
        sta     LAST_SCROLL_X_HI                             ; B027 85 7E                    .~
        jsr     DEMO_PUSH_START_MSG                           ; B029 20 1A B1                  ..
        
		; branch if start not pressed
		; else start game (exit demo)
		jsr     READ_JOYPADS                           ; B02C 20 43 CC                  C.
        and     #BTN_START                            ; B02F 29 10                    ).
        beq     DO_DEMO_GAMEPLAY                           ; B031 F0 03                    ..
        jmp     START_GAME_FOR_REAL                           ; B033 4C B1 B0                 L..

; ----------------------------------------------------------------------------
; generate some random gameplay
DO_DEMO_GAMEPLAY:
        lda     DEMO_INPUT_COPY                             ; B036 A5 FE                    ..
        sta     JOYPAD_INPUT                             ; B038 85 20                    . 
        
		; branch if player not moving
		lda     PLAYER_DX                             ; B03A A5 49                    .I
        ora     PLAYER_DY                             ; B03C 05 4B                    .K
        beq     LB044                           ; B03E F0 04                    ..
        
		; player moving; branch if DEMO_INPUT_CTR <> 0
		dec     DEMO_INPUT_CTR                             ; B040 C6 42                    .B
        bne     LB04F                           ; B042 D0 0B                    ..
LB044:
		; DEMO_INPUT_CTR = 0; reset to x80
		; every 128 frames take another fake action in the demo
        lda     #$80                            ; B044 A9 80                    ..
        sta     DEMO_INPUT_CTR                             ; B046 85 42                    .B
        jsr     GET_DEMO_INPUT                           ; B048 20 E4 B0                  ..
        lda     JOYPAD_INPUT                             ; B04B A5 20                    . 
        sta     DEMO_INPUT_COPY                             ; B04D 85 FE                    ..
LB04F:
		; jump to $d42b / UPDATE_PLAYER
        lda     #$2B                            ; B04F A9 2B                    .+
        sta     JMP_DEST_0E_LO                             ; B051 85 0E                    ..
        lda     #$D4                            ; B053 A9 D4                    ..
        sta     JMP_DEST_0F_HI                             ; B055 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B057 20 E4 CC                  ..
        
		; jump to $f628 / HANDLE_PLAYER_FIRING
		lda     #$28                            ; B05A A9 28                    .(
        sta     JMP_DEST_0E_LO                             ; B05C 85 0E                    ..
        lda     #$F6                            ; B05E A9 F6                    ..
        sta     JMP_DEST_0F_HI                             ; B060 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B062 20 E4 CC                  ..
        
		; jump to $e87c / UPDATE_LEVEL_OBJECTS
		lda     #$7C                            ; B065 A9 7C                    .|
        sta     JMP_DEST_0E_LO                             ; B067 85 0E                    ..
        lda     #$E8                            ; B069 A9 E8                    ..
        sta     JMP_DEST_0F_HI                             ; B06B 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B06D 20 E4 CC                  ..
        
		; jump to $F782 / BLOCK_ANIMATION_FLAG
		lda     #$82                            ; B070 A9 82                    ..
        sta     JMP_DEST_0E_LO                             ; B072 85 0E                    ..
        lda     #$F7                            ; B074 A9 F7                    ..
        sta     JMP_DEST_0F_HI                             ; B076 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B078 20 E4 CC                  ..
        
		; jump to $c15d / CALC_HORIZ_SCROLL_VARS
		lda     #$5D                            ; B07B A9 5D                    .]
        sta     JMP_DEST_0E_LO                             ; B07D 85 0E                    ..
        lda     #$C1                            ; B07F A9 C1                    ..
        sta     JMP_DEST_0F_HI                             ; B081 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B083 20 E4 CC                  ..
        
		; redraw
		jsr     DRAW_PLAYER                           ; B086 20 D8 C1                  ..
        jsr     DRAW_OBJECTS                           ; B089 20 B1 C2                  ..
        
		; compare LAST_SCROLL_X_HI to SCROLL_X_HI - if unequal then flag an update
  	    lda     LAST_SCROLL_X_HI                             ; B08C A5 7E                    .~
        cmp     SCROLL_X_HI                             ; B08E C5 7C                    .|
        beq     LB094                           ; B090 F0 02                    ..
        inc     SCROLL_UPDATE_FLAG                             ; B092 E6 3D                    .=
LB094:
		; jump to $c135 / NMI_CLEAR_FLAGS_AND_WAIT
        lda     #$35                            ; B094 A9 35                    .5
        sta     JMP_DEST_0E_LO                             ; B096 85 0E                    ..
        lda     #$C1                            ; B098 A9 C1                    ..
        sta     JMP_DEST_0F_HI                             ; B09A 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B09C 20 E4 CC                  ..
        
		; branch (back to start screen) if done waiting
		lda     CTR_WAIT_SECONDS                            ; B09F A5 8C                    ..
        beq     DEMO_TIMED_OUT                           ; B0A1 F0 03                    ..
        
		; else loop
		jmp     DEMO_GAMEPLAY_LOOP                           ; B0A3 4C 21 B0                 L!.

; ----------------------------------------------------------------------------
DEMO_TIMED_OUT:
        jsr     PALETTE_FADE_OUT_LC461                           ; B0A6 20 61 C4                  a.
        jmp     LOAD_START_SCREEN                           ; B0A9 4C 64 AE                 Ld.

; ----------------------------------------------------------------------------
; allows random selection of an equipped item for game demo
TBL_DEMO_ITEMS: ; $B0AC
        .byte   INV_ITEM_GLOVE, INV_ITEM_CROSSBOW, INV_ITEM_MAGIC_BOOTS, INV_ITEM_MATTOCK, INV_ITEM_KNUCKLE

; FCEUX CDL appears to have flagged these lines as code, but they're part of the above
; table; ? ever executed - seems doubtful
;        ora     $02                             ; B0AE 05 02                    ..
;        php                                     ; B0B0 08                       .

; entry point once start pressed to start the game!
START_GAME_FOR_REAL:
        ; fade the start screen out
		jsr     PALETTE_FADE_OUT_LC461                           ; B0B1 20 61 C4                  a.
        
		; jump to $c38b / WIPE_NAMETABLE
		lda     #$8B                            ; B0B4 A9 8B                    ..
        sta     JMP_DEST_0E_LO                             ; B0B6 85 0E                    ..
        lda     #$C3                            ; B0B8 A9 C3                    ..
        sta     JMP_DEST_0F_HI                             ; B0BA 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B0BC 20 E4 CC                  ..
        
		; clean-up and prep status bar
		jsr     LOAD_STATUS_BAR_GRAPHICS                           ; B0BF 20 7A C5                  z.
        jsr     WIPE_SPRITES_EXCEPT_0                           ; B0C2 20 75 C3                  u.
        jsr     WIPE_PLAYER_AND_PALETTE_DATA                           ; B0C5 20 31 B6                  1.
        jsr     EVENT_PLAYER_LIFE_CHANGE                           ; B0C8 20 B6 CA                  ..
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; B0CB 20 F8 CA                  ..
        jsr     EVENT_PLAYER_KEY_CHANGE                           ; B0CE 20 E2 CA                  ..
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; B0D1 20 F8 CA                  ..
        lda     #$01                            ; B0D4 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; B0D6 85 36                    .6
        
		; $c135 NMI_CLEAR_FLAGS_AND_WAIT
		lda     #$35                            ; B0D8 A9 35                    .5
        sta     JMP_DEST_0E_LO                             ; B0DA 85 0E                    ..
        lda     #$C1                            ; B0DC A9 C1                    ..
        sta     JMP_DEST_0F_HI                             ; B0DE 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B0E0 20 E4 CC                  ..
        rts                                     ; B0E3 60                       `

; ----------------------------------------------------------------------------
GET_DEMO_INPUT:
		; pick some random joypad input from the table
        lda     #$04                            ; B0E4 A9 04                    ..
        jsr     UPDATE_RNG                           ; B0E6 20 64 CC                  d.
        tax                                     ; B0E9 AA                       .
        lda     TBL_DEMO_INPUT_LB0FE,x                         ; B0EA BD FE B0                 ...
        sta     JOYPAD_INPUT                             ; B0ED 85 20                    . 
        lda     #$0A                            ; B0EF A9 0A                    ..
        jsr     UPDATE_RNG                           ; B0F1 20 64 CC                  d.
        tax                                     ; B0F4 AA                       .
        
		; branch if random value non-zero
		bne     LB0FD                           ; B0F5 D0 06                    ..
        
		; 1 in 10 times, modify the random input - press b button
		lda     JOYPAD_INPUT                             ; B0F7 A5 20                    . 
        ora     #BTN_B                            ; B0F9 09 40                    .@
        sta     JOYPAD_INPUT                             ; B0FB 85 20                    . 
LB0FD:
        rts                                     ; B0FD 60                       `

; ----------------------------------------------------------------------------
; input chosen randomly for demo scenes
; A+R, A+U, A+L, (no input)
; note that random b presses are added separately
TBL_DEMO_INPUT_LB0FE:
		.byte $81, $84, $82, $00

; loads 128 bytes sprite data from table and into $0240
; much bigger table than LOAD_DEMO_SPRITES but most of it's empty; maybe they
; had bigger plans for it? It just has 8 sprites saying 'push start'
LOAD_START_SCREEN_SPRITES:
        ldx     #$7F                            ; B102 A2 7F                    ..
LB104:
        lda     TBL_START_SCREEN_SPRITES,x                         ; B104 BD 1C B7                 ...
        sta     $0240,x                         ; B107 9D 40 02                 .@.
        dex                                     ; B10A CA                       .
        bpl     LB104                           ; B10B 10 F7                    ..
        rts                                     ; B10D 60                       `

; ----------------------------------------------------------------------------
; loads 32 bytes sprite data from table and into $0240
LOAD_DEMO_SPRITES:
        ldx     #$1F                            ; B10E A2 1F                    ..
LB110:
        lda     TBL_DEMO_SPRITES,x                         ; B110 BD FC B6                 ...
        sta     $0240,x                         ; B113 9D 40 02                 .@.
        dex                                     ; B116 CA                       .
        bpl     LB110                           ; B117 10 F7                    ..
        rts                                     ; B119 60                       `

; ----------------------------------------------------------------------------
; flashes 'push start' text mid-screen while demo is playing
DEMO_PUSH_START_MSG:
		; move 8 sprites offscreen (ctr 0-15) or to y=0x80 onscreen (ctr 16+)
        ldx     #OFFSCREEN_Y                            ; B11A A2 EF                    ..
        lda     FRAME_CTR                             ; B11C A5 84                    ..
        and     #$30                            ; B11E 29 30                    )0
        beq     LB124                           ; B120 F0 02                    ..
        ldx     #$80                            ; B122 A2 80                    ..
LB124:
		; set each sprite's y 
        stx     $0240                           ; B124 8E 40 02                 .@.
        stx     $0244                           ; B127 8E 44 02                 .D.
        stx     $0248                           ; B12A 8E 48 02                 .H.
        stx     $024C                           ; B12D 8E 4C 02                 .L.
        stx     $0250                           ; B130 8E 50 02                 .P.
        stx     $0254                           ; B133 8E 54 02                 .T.
        stx     $0258                           ; B136 8E 58 02                 .X.
        stx     $025C                           ; B139 8E 5C 02                 .\.
        rts                                     ; B13C 60                       `

; ----------------------------------------------------------------------------
ENDING_CREDITS_ROLL:
        ; fade music and graphics, do some cleanup
		inc     SND_FADE_OUT_FLAG                             ; B13D E6 92                    ..
        jsr     ENDING_MUSIC_FADE                           ; B13F 20 9B B2                  ..
        jsr     PALETTE_FADE_OUT_LC461                           ; B142 20 61 C4                  a.
        jsr     WIPE_NAMETABLE                           ; B145 20 8B C3                  ..
        jsr     HIDE_ALL_SPRITES                           ; B148 20 EE B2                  ..
        
		; set pattern tables with ending text
		lda     #$20                            ; B14B A9 20                    . 
        sta     CHR_BANK_BG_0                             ; B14D 85 2A                    .*
        lda     #$22                            ; B14F A9 22                    ."
        sta     CHR_BANK_BG_1                             ; B151 85 2B                    .+
        
		; enable bg/sprite rendering
		lda     PPU_MASK_COPY                             ; B153 A5 24                    .$
        ora     #$18                            ; B155 09 18                    ..
        sta     PPU_MASK_COPY                             ; B157 85 24                    .$
        
		lda     #$FF                            ; B159 A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; B15B 20 8F CC                  ..
        
		; set the music
		lda     #MUSIC_CREDITS                            ; B15E A9 0A                    ..
        sta     MUSIC_ID                             ; B160 85 8E                    ..
        jsr     LOAD_MUSIC_DATA                           ; B162 20 08 FC                  ..
        
		; clear some values
		lda     #$00                            ; B165 A9 00                    ..
        sta     a:PPU_SCROLL_X                           ; B167 8D 1C 00                 ...
        sta     a:PPU_NAMETABLE_SELECT                           ; B16A 8D 1D 00                 ...
        sta     a:$0A                           ; B16D 8D 0A 00                 ...
        sta     SCROLL_X_LO                             ; B170 85 7B                    .{
        sta     SCROLL_X_HI                             ; B172 85 7C                    .|
        
		; some other init
		jsr     ENDING_FLASH_DATA_BUFFER                           ; B174 20 CC B2                  ..
        
		; used for buffer address - 32 bytes at SCROLL_NAME_BUFFER_LEFT_COL
		lda     #$40                            ; B177 A9 40                    .@
        sta     PPU_BUFFER_LO                             ; B179 85 18                    ..
        lda     #$01                            ; B17B A9 01                    ..
        sta     PPU_BUFFER_HI                             ; B17D 85 19                    ..        
		lda     #$20                            ; B17F A9 20                    . 
        sta     PPU_BUFFER_LENGTH                             ; B181 85 1A                    ..
        
		; used for ROM read address - $b79c
		lda     #$9C                            ; B183 A9 9C                    ..
		sta     SCRATCH_0C                             ; B185 85 0C                    ..
        lda     #$B7                            ; B187 A9 B7                    ..
        sta     SCRATCH_0D                             ; B189 85 0D                    ..
LB18B:
		; loop here to let the credits run by
		; the 'load more' routines set carry when they hit a stop byte and then we proceed
        jsr     CREDITS_ROLL_LOOP                           ; B18B 20 5D B2                  ].
        jsr     CREDITS_ROLL_LOAD_MORE_0                           ; B18E 20 EA B1                  ..
        bcs     LB19B                           ; B191 B0 08                    ..
        jsr     CREDITS_ROLL_LOOP                           ; B193 20 5D B2                  ].
        jsr     CREDITS_ROLL_LOAD_MORE_1                           ; B196 20 15 B2                  ..
        
		; loop if carry clear
		bcc     LB18B                           ; B199 90 F0                    ..
LB19B:
		; play the dragon sound and wait for SND_CTRL_DMC (noise?) to be non-zero (start playing)
        lda     #SOUND_DRAGON                            ; B19B A9 20                    . 
        sta     NEXT_SOUND_EFFECT                             ; B19D 85 8F                    ..
LB19F:
        lda     SND_CTRL_DMC                             ; B19F A5 D4                    ..
        beq     LB19F                           ; B1A1 F0 FC                    ..
LB1A3:
		; now wait for it to be zero (? finish playing)
        lda     SND_CTRL_DMC                             ; B1A3 A5 D4                    ..
        bne     LB1A3                           ; B1A5 D0 FC                    ..
        
		; prep 60 frame wait
		lda     #$3C                            ; B1A7 A9 3C                    .<
        sta     NMI_WAIT_CTR                             ; B1A9 85 36                    .6
LB1AB:
		; loop until wait over
        lda     NMI_WAIT_CTR                             ; B1AB A5 36                    .6
        bne     LB1AB                           ; B1AD D0 FC                    ..
        
		; clear multiple channels
		lda     #$00                            ; B1AF A9 00                    ..
        sta     SND_CHAN_CTRL                             ; B1B1 85 94                    ..
        sta     SND_CTRL_SQ2                             ; B1B3 85 A4                    ..
        sta     SND_CTRL_TRIANGLE                             ; B1B5 85 B4                    ..
        sta     SND_CTRL_NOISE                             ; B1B7 85 C4                    ..
        
		; cross sound
		lda     #SOUND_CROSS                            ; B1B9 A9 18                    ..
        sta     NEXT_SOUND_EFFECT                             ; B1BB 85 8F                    ..
        
		; code below recreates the cross/flash visual effect at the very end
		ldx     #$0A                            ; B1BD A2 0A                    ..
LB1BF:
        txa                                     ; B1BF 8A                       .
        pha                                     ; B1C0 48                       H
        
		; loop to fill DATA_BUFFER_0180-19f with 0x30
		lda     #$30                            ; B1C1 A9 30                    .0
        ldx     #$1F                            ; B1C3 A2 1F                    ..
LB1C5:
        sta     DATA_BUFFER_0180,x                         ; B1C5 9D 80 01                 ...
        dex                                     ; B1C8 CA                       .
        bpl     LB1C5                           ; B1C9 10 FA                    ..
        
		jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; B1CB 20 69 C5                  i.
        lda     #$01                            ; B1CE A9 01                    ..
        sta     NMI_WAIT_CTR                             ; B1D0 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; B1D2 20 35 C1                  5.
        
		jsr     ENDING_FLASH_DATA_BUFFER                           ; B1D5 20 CC B2                  ..
        
		jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; B1D8 20 69 C5                  i.
        lda     #$02                            ; B1DB A9 02                    ..
        sta     NMI_WAIT_CTR                             ; B1DD 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; B1DF 20 35 C1                  5.
        pla                                     ; B1E2 68                       h
        tax                                     ; B1E3 AA                       .
        dex                                     ; B1E4 CA                       .
        
		; loop flashing until x = 0
		bne     LB1BF       		; B1E5 D0 D8                    ..
LB1E7:
		; infinite loop here - ending finishes on a soft-lock!
        jmp     LB1E7                           ; B1E7 4C E7 B1                 L..

; ----------------------------------------------------------------------------
; load some more credits
CREDITS_ROLL_LOAD_MORE_0:
        jsr     WIPE_CREDITS_BUFFER                           ; B1EA 20 FC B2                  ..
        ldy     #$00                            ; B1ED A0 00                    ..
LB1EF:
        ; load byte, branch (set carry, rts) if 0
		lda     ($0C),y                         ; B1EF B1 0C                    ..
        beq     LB213                           ; B1F1 F0 20                    . 
        
		; branch if = x0D, code for palette change?
		cmp     #$0D                            ; B1F3 C9 0D                    ..
        beq     LB209                           ; B1F5 F0 12                    ..
        
		; otherwise, store lower nibble
		and     #$0F                            ; B1F7 29 0F                    ).
        sta     SCRATCH_08                             ; B1F9 85 08                    ..
        
		; manipulate upper nibble and write to buffer
		lda     ($0C),y                         ; B1FB B1 0C                    ..
        and     #$F0                            ; B1FD 29 F0                    ).
        asl     a                               ; B1FF 0A                       .
        ora     SCRATCH_08                             ; B200 05 08                    ..
        sta     SCROLL_NAME_BUFFER_LEFT_COL,y                         ; B202 99 40 01                 .@.
        iny                                     ; B205 C8                       .
        
		; loop
		jmp     LB1EF                           ; B206 4C EF B1                 L..

; ----------------------------------------------------------------------------
LB209:
		; set addr for next PPU write
        jsr     CREDITS_CALC_PPU_ADDR                           ; B209 20 4E B2                  N.
        
		; will run NMI_ROUTINE_WRITE_CREDIT_ROLL
		lda     #$05                            ; B20C A9 05                    ..
        jsr     ROLL_PPU_SCROLL_Y                           ; B20E 20 78 B2                  x.
        clc                                     ; B211 18                       .
        rts                                     ; B212 60                       `

; ----------------------------------------------------------------------------
LB213:
		; carry set when stop byte is encountered
        sec                                     ; B213 38                       8
        rts                                     ; B214 60                       `

; ----------------------------------------------------------------------------
CREDITS_ROLL_LOAD_MORE_1:
        jsr     WIPE_CREDITS_BUFFER                           ; B215 20 FC B2                  ..
        ldy     #$00                            ; B218 A0 00                    ..
LB21A:
        ; branch (set carry, rts) if byte=0
		lda     ($0C),y                         ; B21A B1 0C                    ..
        beq     LB24C                           ; B21C F0 2E                    ..
        
		; branch 
		cmp     #$0D                            ; B21E C9 0D                    ..
        beq     LB237                           ; B220 F0 15                    ..
        
		; else do some calcs and write to the buffer
		and     #$0F                            ; B222 29 0F                    ).
        sta     SCRATCH_08                             ; B224 85 08                    ..
        lda     ($0C),y                         ; B226 B1 0C                    ..
        and     #$F0                            ; B228 29 F0                    ).
        asl     a                               ; B22A 0A                       .
        ora     SCRATCH_08                             ; B22B 05 08                    ..
        clc                                     ; B22D 18                       .
        adc     #$10                            ; B22E 69 10                    i.
        sta     SCROLL_NAME_BUFFER_LEFT_COL,y                         ; B230 99 40 01                 .@.
        
		; advance and loop
		iny                                     ; B233 C8                       .
        jmp     LB21A                           ; B234 4C 1A B2                 L..

; ----------------------------------------------------------------------------
LB237:
        ; advance and handle rollover
		iny                                     ; B237 C8                       .
        tya                                     ; B238 98                       .
        clc                                     ; B239 18                       .
        adc     SCRATCH_0C                             ; B23A 65 0C                    e.
        sta     SCRATCH_0C                             ; B23C 85 0C                    ..
        bcc     LB242                           ; B23E 90 02                    ..
        inc     SND_WRITE_BUFFER_HI                             ; B240 E6 0D                    ..
LB242:
        jsr     CREDITS_CALC_PPU_ADDR                           ; B242 20 4E B2                  N.
        lda     #$05                            ; B245 A9 05                    ..
        jsr     ROLL_PPU_SCROLL_Y                           ; B247 20 78 B2                  x.
        clc                                     ; B24A 18                       .
        rts                                     ; B24B 60                       `

; ----------------------------------------------------------------------------
LB24C:
		; set carry when stop byte encountered
        sec                                     ; B24C 38                       8
        rts                                     ; B24D 60                       `

; ----------------------------------------------------------------------------
; figure out where to write the next bit of credits graphics
CREDITS_CALC_PPU_ADDR:
		; start with addr $0800
        lda     #$08                            ; B24E A9 08                    ..
        sta     PPU_WRITE_HI                             ; B250 85 17                    ..
        
		; rol upper 2 bits of counter to lower 2 of PPU_WRITE_HI
		; makes HI $20-23, LO = lower 6 bits x0A * 4
		lda     LOOP_COUNTER_0A                             ; B252 A5 0A                    ..
        asl     a                               ; B254 0A                       .
        rol     PPU_WRITE_HI                             ; B255 26 17                    &.
        asl     a                               ; B257 0A                       .
        rol     PPU_WRITE_HI                             ; B258 26 17                    &.
        sta     PPU_WRITE_LO                             ; B25A 85 16                    ..
        rts                                     ; B25C 60                       `

; ----------------------------------------------------------------------------
CREDITS_ROLL_LOOP:
        ; branch 1 in 8 cycles
		inc     LOOP_COUNTER_0A                             ; B25D E6 0A                    ..
        lda     LOOP_COUNTER_0A                             ; B25F A5 0A                    ..
        and     #$07                            ; B261 29 07                    ).
        beq     LB26D                           ; B263 F0 08                    ..
        
		; 7 in 8, use PPU y scroll to roll credits
		lda     #$FF                            ; B265 A9 FF                    ..
        jsr     ROLL_PPU_SCROLL_Y                           ; B267 20 78 B2                  x.
        
		; loop
		jmp     CREDITS_ROLL_LOOP                           ; B26A 4C 5D B2                 L].

; ----------------------------------------------------------------------------
LB26D:
		; counter runs from 0-xF0; just check it stays in bounds
        lda     LOOP_COUNTER_0A                             ; B26D A5 0A                    ..
        cmp     #$F0                            ; B26F C9 F0                    ..
        bne     LB277                           ; B271 D0 04                    ..
        lda     #$00                            ; B273 A9 00                    ..
        sta     LOOP_COUNTER_0A                             ; B275 85 0A                    ..
LB277:
        rts                                     ; B277 60                       `

; ----------------------------------------------------------------------------
; input: a=NMI routine to run
; used e.g. for credits roll
ROLL_PPU_SCROLL_Y:
		; save a on stack
        pha                                     ; B278 48                       H
        
		; branch if ctr+6<xF0
		lda     LOOP_COUNTER_0A                             ; B279 A5 0A                    ..
        clc                                     ; B27B 18                       .
        adc     #$06                            ; B27C 69 06                    i.
        cmp     #$F0                            ; B27E C9 F0                    ..
        bcc     LB285                           ; B280 90 03                    ..
        
		; else add x10
		clc                                     ; B282 18                       .
        adc     #$10                            ; B283 69 10                    i.
LB285:
		; set the y scroll to roll credits and update
        sta     PPU_SCROLL_Y                             ; B285 85 1E                    ..
        pla                                     ; B287 68                       h
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; B288 20 8F CC                  ..
        lda     #$FF                            ; B28B A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; B28D 20 8F CC                  ..
        lda     #$FF                            ; B290 A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; B292 20 8F CC                  ..
        lda     #$FF                            ; B295 A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; B297 20 8F CC                  ..
        rts                                     ; B29A 60                       `

; ----------------------------------------------------------------------------

; loops drawing objects and decrementing various sound counters to decrease the 
; volume on all channels
; so action is frozen while sound plays
; used only for ending; when Roas flies offscreen after beating dragon
; and when family stops waving and we transition to the credits
ENDING_MUSIC_FADE:
        lda     #$00                            ; B29B A9 00                    ..
        sta     SND_CTRL_TRIANGLE                             ; B29D 85 B4                    ..
        lda     #$10                            ; B29F A9 10                    ..
        sta     SND_WRITE_BUFFER_HI                             ; B2A1 85 0D                    ..
LB2A3:
        ; branch if SND_CHAN_VOL_MULTIPLIER = 0 else dec it
		lda     SND_CHAN_VOL_MULTIPLIER                             ; B2A3 A5 A0                    ..
        beq     LB2A9                           ; B2A5 F0 02                    ..
        dec     SND_CHAN_VOL_MULTIPLIER	                             ; B2A7 C6 A0                    ..
LB2A9:
        ; branch if SND_VOL_FADE_B0 = 0 else dec it
		lda     SND_VOL_FADE_B0                             ; B2A9 A5 B0                    ..
        beq     LB2AF                           ; B2AB F0 02                    ..
        dec     SND_VOL_FADE_B0                             ; B2AD C6 B0                    ..
LB2AF:
        ; branch if SND_VOL_FADE_D0 = 0 else dec it
		lda     SND_VOL_FADE_D0                             ; B2AF A5 D0                    ..
        beq     LB2B5                           ; B2B1 F0 02                    ..
        dec     SND_VOL_FADE_D0                             ; B2B3 C6 D0                    ..
LB2B5:
        lda     #$14                            ; B2B5 A9 14                    ..
        sta     SCRATCH_0C                             ; B2B7 85 0C                    ..
LB2B9:	; each loop takes 20 frames and will dec SND_WRITE_BUFFER_HI, so we do 
        ; 16 loops of 20 frames each (320f) before exiting when SND_WRITE_BUFFER_HI = 0
        jsr     DRAW_OBJECTS                           ; B2B9 20 B1 C2                  ..
        lda     #$01                            ; B2BC A9 01                    ..
        sta     NMI_WAIT_CTR                             ; B2BE 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; B2C0 20 35 C1                  5.
        
		; dec SCRATCH_0C and branch (loop) if <> 0
		dec     SCRATCH_0C                             ; B2C3 C6 0C                    ..
        bne     LB2B9                           ; B2C5 D0 F2                    ..
        
		; SCRATCH_0C = 0; dec SND_WRITE_BUFFER_HI and branch (loop) if <> 0
		dec     SND_WRITE_BUFFER_HI                             ; B2C7 C6 0D                    ..
        bne     LB2A3                           ; B2C9 D0 D8                    ..
        rts                                     ; B2CB 60                       `

; ----------------------------------------------------------------------------
ENDING_FLASH_DATA_BUFFER:
		; manually set the status bar palette ($0180-3) then loop to set the rest to x0F
        lda     #$0F                            ; B2CC A9 0F                    ..
        sta     DATA_BUFFER_0180                           ; B2CE 8D 80 01                 ...
        lda     #$0C                            ; B2D1 A9 0C                    ..
        sta     DATA_BUFFER_0180+1                           ; B2D3 8D 81 01                 ...
        lda     #$10                            ; B2D6 A9 10                    ..
        sta     DATA_BUFFER_0180+2                           ; B2D8 8D 82 01                 ...
        lda     #$30                            ; B2DB A9 30                    .0
        sta     DATA_BUFFER_0180+3                           ; B2DD 8D 83 01                 ...
        lda     #$0F                            ; B2E0 A9 0F                    ..
        ldx     #$1B                            ; B2E2 A2 1B                    ..
LB2E4:
        sta     PALETTE_BUFFER_NON_STATUS_BAR,x                         ; B2E4 9D 84 01                 ...
        dex                                     ; B2E7 CA                       .
        bpl     LB2E4                           ; B2E8 10 FA                    ..
        jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; B2EA 20 69 C5                  i.
        rts                                     ; B2ED 60                       `

; ----------------------------------------------------------------------------
; loops to move all sprites offscreen
HIDE_ALL_SPRITES:
        ldx     #$00                            ; B2EE A2 00                    ..
        lda     #OFFSCREEN_Y                            ; B2F0 A9 EF                    ..
LB2F2:
        sta     SPRITE_0_Y,x                         ; B2F2 9D 00 02                 ...
       
        ; advance to next sprite and loop until x is 0 again
  	    inx                                     ; B2F5 E8                       .
        inx                                     ; B2F6 E8                       .
        inx                                     ; B2F7 E8                       .
        inx                                     ; B2F8 E8                       .
        bne     LB2F2                           ; B2F9 D0 F7                    ..
        rts                                     ; B2FB 60                       `

; ----------------------------------------------------------------------------
; 32 bytes of xC0 written to SCROLL_NAME_BUFFER_LEFT_COL
WIPE_CREDITS_BUFFER:
        ldy     #$1F                            ; B2FC A0 1F                    ..
        lda     #$C0                            ; B2FE A9 C0                    ..
LB300:
        sta     SCROLL_NAME_BUFFER_LEFT_COL,y                         ; B300 99 40 01                 .@.
        dey                                     ; B303 88                       .
        bpl     LB300                           ; B304 10 FA                    ..
        rts                                     ; B306 60                       `

; ----------------------------------------------------------------------------

; jump here from main loop when player dies
; return - x value
; 0 = not dead; elixir or cheat
; 1 =
; 2 = 
HANDLE_PLAYER_DEATH: ; $b307
        ; push prior music in case we avoid death
		lda     MUSIC_ID                             ; B307 A5 8E                    ..
        pha                                     ; B309 48                       H
        inc     FLAG_START_SCREEN_OPEN                             ; B30A E6 8D                    ..
        jsr     HIDE_SPRITES_280_UP                           ; B30C 20 7C D0                  |.
        
		; player faces screen
		; x=frame, y=flags (no mirroring)
		ldx     #$35                            ; B30F A2 35                    .5
        ldy     #$00                            ; B311 A0 00                    ..
        jsr     UPDATE_PLAYER_DEATH_SPIN                           ; B313 20 C5 B4                  ..
        
		; wait a second
		lda     #$3C                            ; B316 A9 3C                    .<
        sta     NMI_WAIT_CTR                             ; B318 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; B31A 20 35 C1                  5.
        
		; death music
		lda     #MUSIC_PLAYER_DEATH                            ; B31D A9 08                    ..
        jsr     LOAD_MUSIC_DATA_IF_NEC                           ; B31F 20 2E D0                  ..
        dec     FLAG_START_SCREEN_OPEN                             ; B322 C6 8D                    ..
        
		; 5 spins; each update waits 8 frames
		lda     #$05                            ; B324 A9 05                    ..
        sta     LOOP_COUNTER_0A                             ; B326 85 0A                    ..
LB328:
        ldx     #$0D                            ; B328 A2 0D                    ..
        ldy     #$00                            ; B32A A0 00                    ..
        jsr     UPDATE_PLAYER_DEATH_SPIN                           ; B32C 20 C5 B4                  ..
        ldx     #$01                            ; B32F A2 01                    ..
        ldy     #$00                            ; B331 A0 00                    ..
        jsr     UPDATE_PLAYER_DEATH_SPIN                           ; B333 20 C5 B4                  ..
        ldx     #$09                            ; B336 A2 09                    ..
        ldy     #$00                            ; B338 A0 00                    ..
        jsr     UPDATE_PLAYER_DEATH_SPIN                           ; B33A 20 C5 B4                  ..
        ldx     #$01                            ; B33D A2 01                    ..
        ldy     #$40                            ; B33F A0 40                    .@
        jsr     UPDATE_PLAYER_DEATH_SPIN                           ; B341 20 C5 B4                  ..

		; loop if LOOP_COUNTER_0A <> 0
        dec     LOOP_COUNTER_0A                             ; B344 C6 0A                    ..
        bne     LB328                           ; B346 D0 E0                    ..

		; done spinning, player falls over
        lda     #$01                            ; B348 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; B34A 85 36                    .6
        lda     #$31                            ; B34C A9 31                    .1
        sta     PLAYER_FRAME                             ; B34E 85 56                    .V
        jsr     DRAW_PLAYER                           ; B350 20 D8 C1                  ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; B353 20 35 C1                  5.
        
		; branch if this was during the dragon fight - elixir can't save you
		; b/c you should have the Dragon Slayer equipped
        lda     DRAGON_FIGHT_FLAG                             ; B356 A5 EC                    ..
		bne     PLAYER_DEATH_NO_ELIXIR                           ; B358 D0 29                    .)
        
		; branch if not cheating, check for elixir equipped
		lda     CHEAT_STATUS                             ; B35A A5 37                    .7
		bpl     LB363                           ; B35C 10 05                    ..
        
		; we are cheating; increment it and restore life
		inc     CHEAT_STATUS                             ; B35E E6 37                    .7
        jmp     ELIXIR_PREVENT_DEATH                           ; B360 4C 72 B3                 Lr.

; ----------------------------------------------------------------------------
LB363:
		; note for a little drama, the death animation shows before elixir resurrects you!
		; branch if elixir not equipped - we're dead!
        ldx     CUR_EQUIP_SLOT_SELECTED                             ; B363 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; B365 B5 51                    .Q
        cmp     #INV_ITEM_ELIXIR                            ; B367 C9 0C                    ..
		bne     PLAYER_DEATH_NO_ELIXIR                           ; B369 D0 18                    ..
        
		; elixir equipped - use it!
		; no longer equipped
		lda     #$FF                            ; B36B A9 FF                    ..
        sta     CUR_EQUIP_ITEMS,x                           ; B36D 95 51                    .Q
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; B36F 20 34 C2                  4.

ELIXIR_PREVENT_DEATH:
		; do the actual healing
        jsr     ACTION_ELIXIR                           ; B372 20 6A D1                  j.
        
		; post-heal player appearance; wait for player to press/release something 
		; before continuing
		lda     #$19                            ; B375 A9 19                    ..
        sta     PLAYER_FRAME                             ; B377 85 56                    .V
        jsr     HOLD_FOR_JOYPAD_ACKNOWLEDGE                           ; B379 20 09 CC                  ..
        
		; restore the prior music
		pla                                     ; B37C 68                       h
        jsr     LOAD_MUSIC_DATA_IF_NEC                           ; B37D 20 2E D0                  ..
        
		; exit code 0 = not dead!
		ldx     #$00                            ; B380 A2 00                    ..
        rts                                     ; B382 60                       `

; ----------------------------------------------------------------------------
; player actually dies; no cheat or elixir
; do some cleanup and show the game over screen
PLAYER_DEATH_NO_ELIXIR:
		; pull previously saved music off stack (not used)
		pla                                     ; B383 68                       h
        
		; fade to black
        jsr     PALETTE_FADE_OUT_LC461                           ; B384 20 61 C4                  a.
        
		; clean up
		lda     #$00                            ; B387 A9 00                    ..
        sta     DRAGON_FIGHT_FLAG                             ; B389 85 EC                    ..
        sta     FIRST_OBJECT_OFFSET                             ; B38B 85 3E                    .>
        lda     #$80                            ; B38D A9 80                    ..
        sta     OBJECT_SPRITE_RAM_START                             ; B38F 85 3F                    .?
        jsr     WIPE_NAMETABLE                           ; B391 20 8B C3                  ..
        jsr     CLEAR_ALL_OBJECTS                           ; B394 20 8A D0                  ..
        jsr     DRAW_OBJECTS                           ; B397 20 B1 C2                  ..
        
		; set pattern tables for game over
		lda     #$16                            ; B39A A9 16                    ..
        sta     CHR_BANK_BG_1                             ; B39C 85 2B                    .+
        lda     #$36                            ; B39E A9 36                    .6
        sta     CHR_BANK_PLAYER_SPRITES                             ; B3A0 85 2C                    .,
        lda     #$00                            ; B3A2 A9 00                    ..
        sta     a:PPU_SCROLL_X                           ; B3A4 8D 1C 00                 ...
        sta     a:PPU_NAMETABLE_SELECT                           ; B3A7 8D 1D 00                 ...
        sta     a:PPU_SCROLL_Y                           ; B3AA 8D 1E 00                 ...
        sta     SCROLL_X_LO                             ; B3AD 85 7B                    .{
        sta     SCROLL_X_HI                             ; B3AF 85 7C                    .|
        
		; write "game over" to $216b
		lda     #$6B                            ; B3B1 A9 6B                    .k
        sta     PPU_WRITE_LO                             ; B3B3 85 16                    ..
        lda     #$21                            ; B3B5 A9 21                    .!
        sta     PPU_WRITE_HI                             ; B3B7 85 17                    ..
        
		; 9 bytes from $b4af
		lda     #$AF                            ; B3B9 A9 AF                    ..
        sta     PPU_BUFFER_LO                             ; B3BB 85 18                    ..
        lda     #$B4                            ; B3BD A9 B4                    ..
        sta     PPU_BUFFER_HI                             ; B3BF 85 19                    ..
        lda     #$09                            ; B3C1 A9 09                    ..
        sta     PPU_BUFFER_LENGTH                             ; B3C3 85 1A                    ..
        
		; use nmi routine 5 - PPU write for bg graphics
		lda     #$05                            ; B3C5 A9 05                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; B3C7 20 8F CC                  ..
        
		; ? load graphics for game over screen
		; write "retry" to $224c
		lda     #$4C                            ; B3CA A9 4C                    .L
        sta     PPU_WRITE_LO                             ; B3CC 85 16                    ..
        lda     #$22                            ; B3CE A9 22                    ."
        sta     PPU_WRITE_HI                             ; B3D0 85 17                    ..
        
		; 5 bytes from $b4b8
		lda     #$B8                            ; B3D2 A9 B8                    ..
        sta     PPU_BUFFER_LO                             ; B3D4 85 18                    ..
        lda     #$B4                            ; B3D6 A9 B4                    ..
        sta     PPU_BUFFER_HI                             ; B3D8 85 19                    ..
        lda     #$05                            ; B3DA A9 05                    ..
        sta     PPU_BUFFER_LENGTH                             ; B3DC 85 1A                    ..
        
		; use nmi routine 5 - PPU write for bg graphics
		lda     #$05                            ; B3DE A9 05                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; B3E0 20 8F CC                  ..
        
		; write "continue" to $228c (nametable 0)
		lda     #$8C                            ; B3E3 A9 8C                    ..
        sta     PPU_WRITE_LO                             ; B3E5 85 16                    ..
        lda     #$22                            ; B3E7 A9 22                    ."
        sta     PPU_WRITE_HI                             ; B3E9 85 17                    ..
        
		; 8 bytes from $b4bd
		lda     #$BD                            ; B3EB A9 BD                    ..
        sta     PPU_BUFFER_LO                             ; B3ED 85 18                    ..
        lda     #$B4                            ; B3EF A9 B4                    ..
        sta     PPU_BUFFER_HI                             ; B3F1 85 19                    ..
        lda     #$08                            ; B3F3 A9 08                    ..
        sta     PPU_BUFFER_LENGTH                             ; B3F5 85 1A                    ..
        
		; use nmi routine 5 - PPU write for bg graphics
		lda     #$05                            ; B3F7 A9 05                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; B3F9 20 8F CC                  ..
        
		; position the icon for retry/continue selection
		lda     #$05                            ; B3FC A9 05                    ..
        sta     PX_HI                             ; B3FE 85 44                    .D
        lda     #$00                            ; B400 A9 00                    ..
        sta     PX_LO                             ; B402 85 43                    .C
        lda     #$70                            ; B404 A9 70                    .p
        sta     PY                             ; B406 85 45                    .E
        lda     #$39                            ; B408 A9 39                    .9
        sta     PLAYER_FRAME                             ; B40A 85 56                    .V
        jsr     WIPE_SPRITES_EXCEPT_0                           ; B40C 20 75 C3                  u.
        jsr     DRAW_PLAYER                           ; B40F 20 D8 C1                  ..
        
		; jump for $c4e0 - fade to game over screen
		lda     #$E0                            ; B412 A9 E0                    ..
        sta     JMP_DEST_0E_LO                             ; B414 85 0E                    ..
        lda     #$C4                            ; B416 A9 C4                    ..
        sta     JMP_DEST_0F_HI                             ; B418 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B41A 20 E4 CC                  ..
LB41D:
        ; branch if start pressed
		jsr     HOLD_FOR_JOYPAD_ACKNOWLEDGE                           ; B41D 20 09 CC                  ..
        and     #BTN_START                            ; B420 29 10                    ).
        bne     PLAYER_DEATH_CHOICE_MADE                           ; B422 D0 0D                    ..
        
		; start not pressed - alternate between retry and continue
		; eor moves the selection icon up/down x10 pixels
		lda     PY                             ; B424 A5 45                    .E
        eor     #$10                            ; B426 49 10                    I.
        sta     PY                             ; B428 85 45                    .E
        lda     #SOUND_EQUIP_SELECT_TICK                            ; B42A A9 0C                    ..
        sta     NEXT_SOUND_EFFECT                             ; B42C 85 8F                    ..
        jmp     LB41D                           ; B42E 4C 1D B4                 L..

; ----------------------------------------------------------------------------
PLAYER_DEATH_CHOICE_MADE:
        lda     #SOUND_CROSS                            ; B431 A9 18                    ..
        sta     NEXT_SOUND_EFFECT                             ; B433 85 8F                    ..
        
		; branch if PY=x70 (upper position, retry)
		lda     PY                             ; B435 A5 45                    .E
        cmp     #$70                            ; B437 C9 70                    .p
        beq     PLAYER_DEATH_CONTINUE                           ; B439 F0 15                    ..
        
		; retry chosen; fade out, wait
		jsr     PALETTE_FADE_OUT_LC461                           ; B43B 20 61 C4                  a.
        lda     #$78                            ; B43E A9 78                    .x
        sta     NMI_WAIT_CTR                             ; B440 85 36                    .6
        
		; jump to $c135 NMI_CLEAR_FLAGS_AND_WAIT
		lda     #$35                            ; B442 A9 35                    .5
        sta     JMP_DEST_0E_LO                             ; B444 85 0E                    ..
        lda     #$C1                            ; B446 A9 C1                    ..
        sta     JMP_DEST_0F_HI                             ; B448 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B44A 20 E4 CC                  ..
        
		; exit code = 2, retry
		ldx     #$02                            ; B44D A2 02                    ..
        rts                                     ; B44F 60                       `

; ----------------------------------------------------------------------------
; selecting 'continue' takes you back to the home and you still have your items
PLAYER_DEATH_CONTINUE:
        ; death wipes away any progress since the last home visit
		jsr     RESTORE_PLAYER_HOME_STATE                           ; B450 20 C5 D0                  ..
        
		; nothing equipped or selected
		lda     #INV_ITEM_NOTHING                            ; B453 A9 FF                    ..
        sta     CUR_EQUIP_ITEMS                             ; B455 85 51                    .Q
        sta     CUR_EQUIP_ITEMS+1                             ; B457 85 52                    .R
        sta     CUR_EQUIP_ITEMS+2                             ; B459 85 53                    .S
        lda     #EQUIP_SLOT_NOTHING_SELECTED                            ; B45B A9 03                    ..
        sta     CUR_EQUIP_SLOT_SELECTED                             ; B45D 85 55                    .U
        
		; ? no player selected
		lda     #PLAYER_NONE                       ; B45F A9 06                    ..
        sta     PLAYER_ID                             ; B461 85 40                    .@
        
		; right side of overworld
		lda     #MAP_X_OVERWORLD                            ; B463 A9 03                    ..
        sta     MAP_X                             ; B465 85 47                    .G
		lda     #MAP_Y_OVERWORLD                            ; B467 A9 10                    ..
        sta     MAP_Y                             ; B469 85 48                    .H
        jsr     PALETTE_FADE_OUT_LC461                           ; B46B 20 61 C4                  a.
        
		; oddly, music set to Mayna's theme here - assuming this is over-written before it plays?
		lda     #MUSIC_MAYNA                            ; B46E A9 02                    ..
        sta     MUSIC_ID                             ; B470 85 8E                    ..
        jsr     WIPE_NAMETABLE                           ; B472 20 8B C3                  ..
        jsr     LOAD_STATUS_BAR_GRAPHICS                           ; B475 20 7A C5                  z.
        jsr     EVENT_PLAYER_LIFE_CHANGE                           ; B478 20 B6 CA                  ..
        jsr     EVENT_PLAYER_MAGIC_CHANGE                           ; B47B 20 CC CA                  ..
        jsr     EVENT_PLAYER_KEY_CHANGE                           ; B47E 20 E2 CA                  ..
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; B481 20 F8 CA                  ..
        
		; setup jump to $c8f2 (LOAD_MAP_FULL)
		lda     #$F2                            ; B484 A9 F2                    ..
        sta     JMP_DEST_0E_LO                             ; B486 85 0E                    ..
        lda     #$C8                            ; B488 A9 C8                    ..
        sta     JMP_DEST_0F_HI                             ; B48A 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B48C 20 E4 CC                  ..
        
		; fill buffer with 32 bytes of x0F
		lda     #$0F                            ; B48F A9 0F                    ..
        ldx     #$1F                            ; B491 A2 1F                    ..
LB493:
        sta     DATA_BUFFER_0180,x                         ; B493 9D 80 01                 ...
        dex                                     ; B496 CA                       .
        bpl     LB493                           ; B497 10 FA                    ..
        
		; player sprite offscreen
		lda     #OFFSCREEN_Y                            ; B499 A9 EF                    ..
        sta     PLAYER_SPRITE_0                           ; B49B 8D 10 02                 ...
        sta     PLAYER_SPRITE_1                           ; B49E 8D 14 02                 ...
        
		; jump to $c4b4 / CONTINUE_FADE_TO_HOME
		lda     #$B4                            ; B4A1 A9 B4                    ..
        sta     JMP_DEST_0E_LO                             ; B4A3 85 0E                    ..
        lda     #$C4                            ; B4A5 A9 C4                    ..
        sta     JMP_DEST_0F_HI                             ; B4A7 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B4A9 20 E4 CC                  ..
        
		; exit code = 1; continue
		ldx     #$01                            ; B4AC A2 01                    ..
        rts                                     ; B4AE 60                       `

; ----------------------------------------------------------------------------
; graphics for the text on the game over screen
TBL_GAME_OVER_TEXT: 
		; $b4af: GAME OVER
		.byte $e7, $e1, $ed, $e5, $c0, $ef, $f6, $e5, $f2
		
		; $b4b8: RETRY
        .byte $f2, $e5, $f4, $f2, $f9
		
		; $b4bd: CONTINUE
		.byte $e3, $ef, $ee, $f4, $e9, $ee, $f5, $e5
		
; ----------------------------------------------------------------------------
; advance the player death spin - saves x as frame, y as flags, waits 8 frames
UPDATE_PLAYER_DEATH_SPIN:
        stx     PLAYER_FRAME                             ; B4C5 86 56                    .V
        sty     PLAYER_SPRITE_FLAGS                             ; B4C7 84 57                    .W
        lda     #$08                            ; B4C9 A9 08                    ..
        sta     NMI_WAIT_CTR                             ; B4CB 85 36                    .6
        jsr     DRAW_PLAYER                           ; B4CD 20 D8 C1                  ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; B4D0 20 35 C1                  5.
        rts                                     ; B4D3 60                       `

; ----------------------------------------------------------------------------

; encode all our various info and make a password
GENERATE_PASSWORD: ; $b4d4
        ldx     #$0F                            ; B4D4 A2 0F                    ..
        ldy     #$07                            ; B4D6 A0 07                    ..
LB4D8:
		; encode the treasures still to be collected, upper/lower nibble stored separately
        lda     HOME_STATE_EXTANT_TREASURES,y                         ; B4D8 B9 08 03                 ...
        lsr     a                               ; B4DB 4A                       J
        lsr     a                               ; B4DC 4A                       J
        lsr     a                               ; B4DD 4A                       J
        lsr     a                               ; B4DE 4A                       J
        sta     PASSWORD_BUFFER,x                         ; B4DF 9D 22 03                 .".
        dex                                     ; B4E2 CA                       .
        lda     HOME_STATE_EXTANT_TREASURES,y                         ; B4E3 B9 08 03                 ...
        and     #$0F                            ; B4E6 29 0F                    ).
        sta     PASSWORD_BUFFER,x                         ; B4E8 9D 22 03                 .".
        dex                                     ; B4EB CA                       .
        dey                                     ; B4EC 88                       .
        bpl     LB4D8                           ; B4ED 10 E9                    ..
		; store the items in the home
        ldx     #$0F                            ; B4EF A2 0F                    ..
LB4F1:
		lda     HOME_STATE_INVENTORY,x                         ; B4F1 BD 10 03                 ...
        and     #$0F                            ; B4F4 29 0F                    ).
        sta     PASSWORD_BUFFER+16,x                         ; B4F6 9D 32 03                 .2.
        dex                                     ; B4F9 CA                       .
        bpl     LB4F1                           ; B4FA 10 F5                    ..
        
		; bit values of keys and golds are scattered among 8 separate bytes
		lda     HOME_STATE_KEYS                           ; B4FC AD 20 03                 . .
        ldx     #$0F                            ; B4FF A2 0F                    ..
LB501:
        lsr     a                               ; B501 4A                       J
        rol     PASSWORD_BUFFER,x                         ; B502 3E 22 03                 >".
        dex                                     ; B505 CA                       .
        dex                                     ; B506 CA                       .
        bpl     LB501                           ; B507 10 F8                    ..
        lda     HOME_STATE_GOLDS                           ; B509 AD 21 03                 .!.
        ldx     #$0F                            ; B50C A2 0F                    ..
LB50E:
        lsr     a                               ; B50E 4A                       J
        rol     PASSWORD_BUFFER+16,x                         ; B50F 3E 32 03                 >2.
        dex                                     ; B512 CA                       .
        dex                                     ; B513 CA                       .
        bpl     LB50E                           ; B514 10 F8                    ..
        
		; loop through and create a checksum, stored to PASSWORD_CHECKSUM
		lda     #$00                            ; B516 A9 00                    ..
        ldx     #$1F                            ; B518 A2 1F                    ..
LB51A:
        clc                                     ; B51A 18                       .
        adc     PASSWORD_BUFFER,x                         ; B51B 7D 22 03                 }".
        dex                                     ; B51E CA                       .
        bpl     LB51A                           ; B51F 10 F9                    ..
        
		sta     PASSWORD_CHECKSUM                           ; B521 8D 89 03                 ...
        
		; now do serial EOR for another check byte at PASSWORD_EOR_CHECK
		lda     #$0A                            ; B524 A9 0A                    ..
        ldx     #$1F                            ; B526 A2 1F                    ..
LB528:
        eor     PASSWORD_BUFFER,x                         ; B528 5D 22 03                 ]".
        dex                                     ; B52B CA                       .
        bpl     LB528                           ; B52C 10 FA                    ..
        
		sta     PASSWORD_EOR_CHECK                           ; B52E 8D 8A 03                 ...
        
		; scatter the checksum bits among 8 bytes
		lda     PASSWORD_CHECKSUM                           ; B531 AD 89 03                 ...
        ldx     #$0E                            ; B534 A2 0E                    ..
LB536:
        lsr     a                               ; B536 4A                       J
        rol     PASSWORD_BUFFER,x                         ; B537 3E 22 03                 >".
        dex                                     ; B53A CA                       .
        dex                                     ; B53B CA                       .
        bpl     LB536                           ; B53C 10 F8                    ..
        
		; scatter the eor check as well
		lda     PASSWORD_EOR_CHECK                           ; B53E AD 8A 03                 ...
        ldx     #$0E                            ; B541 A2 0E                    ..
LB543:
        lsr     a                               ; B543 4A                       J
        rol     PASSWORD_BUFFER+16,x                         ; B544 3E 32 03                 >2.
        dex                                     ; B547 CA                       .
        dex                                     ; B548 CA                       .
        bpl     LB543                           ; B549 10 F8                    ..
        
		; set RNG values from the password
		lda     PASSWORD_BUFFER+15                           ; B54B AD 31 03                 .1.
        sta     RNG_2                             ; B54E 85 3A                    .:
        lda     PASSWORD_BUFFER+31                           ; B550 AD 41 03                 .A.
        sta     RNG_3                             ; B553 85 3B                    .;
        
		; loop and generate some RNG values and encode them as well as an additional check/encryption 
		ldx     #$0E                            ; B555 A2 0E                    ..
LB557:
        stx     SCRATCH_08                             ; B557 86 08                    ..
        lda     #$20                            ; B559 A9 20                    . 
        jsr     UPDATE_RNG                           ; B55B 20 64 CC                  d.
        ldx     SCRATCH_08                             ; B55E A6 08                    ..
        eor     PASSWORD_BUFFER,x                         ; B560 5D 22 03                 ]".
        sta     PASSWORD_BUFFER,x                         ; B563 9D 22 03                 .".
        lda     #$20                            ; B566 A9 20                    . 
        jsr     UPDATE_RNG                           ; B568 20 64 CC                  d.
        ldx     SCRATCH_08                             ; B56B A6 08                    ..
        eor     PASSWORD_BUFFER+16,x                         ; B56D 5D 32 03                 ]2.
        sta     PASSWORD_BUFFER+16,x                         ; B570 9D 32 03                 .2.
        dex                                     ; B573 CA                       .
        bpl     LB557                           ; B574 10 E1                    ..
        rts                                     ; B576 60                       `

; ----------------------------------------------------------------------------
;
; not going into crazy detail here, but basically reverses the encoding applied
; above to check if the password is valid
; if so, carry is clear and we load the state
; if not, play the fail sound and set carry
CHECK_PASSWORD: ; $b577
        ldx     #$1F                            ; B577 A2 1F                    ..
LB579:
		; copy the password into another buffer for checking
        lda     PASSWORD_BUFFER,x                         ; B579 BD 22 03                 .".
        sta     PASSWORD_CHECK_BUFFER,x                         ; B57C 9D 42 03                 .B.
        dex                                     ; B57F CA                       .
        bpl     LB579                           ; B580 10 F7                    ..
        
		; seed the RNG
		lda     PASSWORD_CHECK_BUFFER+$0f                           ; B582 AD 51 03                 .Q.
        sta     RNG_2                             ; B585 85 3A                    .:
        lda     PASSWORD_CHECK_BUFFER+$1f                           ; B587 AD 61 03                 .a.
        sta     RNG_3                             ; B58A 85 3B                    .;
        ldx     #$0E                            ; B58C A2 0E                    ..
LB58E:
		; reverse the eor encryption
        stx     SCRATCH_08                             ; B58E 86 08                    ..
        lda     #$20                            ; B590 A9 20                    . 
        jsr     UPDATE_RNG                           ; B592 20 64 CC                  d.
        ldx     SCRATCH_08                             ; B595 A6 08                    ..
        eor     PASSWORD_CHECK_BUFFER,x                         ; B597 5D 42 03                 ]B.
        sta     PASSWORD_CHECK_BUFFER,x                         ; B59A 9D 42 03                 .B.
        lda     #$20                            ; B59D A9 20                    . 
        jsr     UPDATE_RNG                           ; B59F 20 64 CC                  d.
        ldx     SCRATCH_08                             ; B5A2 A6 08                    ..
        eor     PASSWORD_CHECK_BUFFER+$10,x                         ; B5A4 5D 52 03                 ]R.
        sta     PASSWORD_CHECK_BUFFER+$10,x                         ; B5A7 9D 52 03                 .R.
        dex                                     ; B5AA CA                       .
        bpl     LB58E                           ; B5AB 10 E1                    ..
        ldx     #$0E                            ; B5AD A2 0E                    ..
LB5AF:
        ; collect the low bit from 8 bytes into a --> PASSWORD_EOR_CHECK
		lsr     PASSWORD_CHECK_BUFFER+$10,x                         ; B5AF 5E 52 03                 ^R.
        ror     a                               ; B5B2 6A                       j
        dex                                     ; B5B3 CA                       .
        dex                                     ; B5B4 CA                       .
        bpl     LB5AF                           ; B5B5 10 F8                    ..
		sta     PASSWORD_EOR_CHECK                           ; B5B7 8D 8A 03                 ...
        
		ldx     #$0E                            ; B5BA A2 0E                    ..
LB5BC:
        ; collect the low bit from 8 bytes into a --> PASSWORD_CHECKSUM
		lsr     PASSWORD_CHECK_BUFFER,x                         ; B5BC 5E 42 03                 ^B.
        ror     a                               ; B5BF 6A                       j
        dex                                     ; B5C0 CA                       .
        dex                                     ; B5C1 CA                       .
        bpl     LB5BC                           ; B5C2 10 F8                    ..
        sta     PASSWORD_CHECKSUM                           ; B5C4 8D 89 03                 ...
        
		; do a 32 byte checksum and compare to PASSWORD_CHECKSUM
		lda     #$00                            ; B5C7 A9 00                    ..
        ldx     #$1F                            ; B5C9 A2 1F                    ..
LB5CB:
        clc                                     ; B5CB 18                       .
        adc     PASSWORD_CHECK_BUFFER,x                         ; B5CC 7D 42 03                 }B.
        dex                                     ; B5CF CA                       .
        bpl     LB5CB                           ; B5D0 10 F9                    ..
        
		; branch (success) if checksum matches
		cmp     PASSWORD_CHECKSUM                           ; B5D2 CD 89 03                 ...
        beq     LB5DA                           ; B5D5 F0 03                    ..
        
		; invalid password
		jmp     PASSWORD_FAIL                           ; B5D7 4C 29 B6                 L).

; ----------------------------------------------------------------------------
LB5DA:
		; a=x0a at the start, we EOR each byte and compare to PASSWORD_EOR_CHECK
        lda     #$0A                            ; B5DA A9 0A                    ..
        ldx     #$1F                            ; B5DC A2 1F                    ..
LB5DE:
        eor     PASSWORD_CHECK_BUFFER,x                         ; B5DE 5D 42 03                 ]B.
        dex                                     ; B5E1 CA                       .
        bpl     LB5DE                           ; B5E2 10 FA                    ..
        
		; branch (success) if eor check matches
		cmp     PASSWORD_EOR_CHECK                           ; B5E4 CD 8A 03                 ...
        beq     RESTORE_STATE_FROM_PASSWORD                           ; B5E7 F0 03                    ..
        
		; invalid password
		jmp     PASSWORD_FAIL                           ; B5E9 4C 29 B6                 L).

; ----------------------------------------------------------------------------
; we have a valid password; use it to restore the state
RESTORE_STATE_FROM_PASSWORD:
        ldx     #$0F                            ; B5EC A2 0F                    ..
LB5EE:
        ; keys
		lsr     PASSWORD_CHECK_BUFFER,x                         ; B5EE 5E 42 03                 ^B.
        ror     a                               ; B5F1 6A                       j
        dex                                     ; B5F2 CA                       .
        dex                                     ; B5F3 CA                       .
        bpl     LB5EE                           ; B5F4 10 F8                    ..
        sta     HOME_STATE_KEYS                           ; B5F6 8D 20 03                 . .
        ldx     #$0F                            ; B5F9 A2 0F                    ..
LB5FB:
        ; golds
		lsr     PASSWORD_CHECK_BUFFER+$10,x                         ; B5FB 5E 52 03                 ^R.
        ror     a                               ; B5FE 6A                       j
        dex                                     ; B5FF CA                       .
        dex                                     ; B600 CA                       .
        bpl     LB5FB                           ; B601 10 F8                    ..
        sta     HOME_STATE_GOLDS                           ; B603 8D 21 03                 .!.
        ldx     #$0F                            ; B606 A2 0F                    ..
        ldy     #$07                            ; B608 A0 07                    ..
LB60A:
        ; dungeon treasures still out there
		lda     PASSWORD_CHECK_BUFFER,x                         ; B60A BD 42 03                 .B.
        asl     a                               ; B60D 0A                       .
        asl     a                               ; B60E 0A                       .
        asl     a                               ; B60F 0A                       .
        asl     a                               ; B610 0A                       .
        dex                                     ; B611 CA                       .
        ora     PASSWORD_CHECK_BUFFER,x                         ; B612 1D 42 03                 .B.
        dex                                     ; B615 CA                       .
        sta     HOME_STATE_EXTANT_TREASURES,y                         ; B616 99 08 03                 ...
        dey                                     ; B619 88                       .
        bpl     LB60A                           ; B61A 10 EE                    ..
        ldx     #$0F                            ; B61C A2 0F                    ..
LB61E:
        ; items in the home
		lda     PASSWORD_CHECK_BUFFER+$10,x                         ; B61E BD 52 03                 .R.
        sta     HOME_STATE_INVENTORY,x                         ; B621 9D 10 03                 ...
        dex                                     ; B624 CA                       .
        bpl     LB61E                           ; B625 10 F7                    ..
        
		; clear carry = successful password entry
		clc                                     ; B627 18                       .
        rts                                     ; B628 60                       `

; ----------------------------------------------------------------------------
; return - carry set = failed password entry
PASSWORD_FAIL:
        lda     #SOUND_BAD_PASSWORD                            ; B629 A9 1C                    ..
        sta     NEXT_SOUND_EFFECT                             ; B62B 85 8F                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; B62D 85 90                    ..
        sec                                     ; B62F 38                       8
        rts                                     ; B630 60                       `

; ----------------------------------------------------------------------------
; re-initializes some zero page and buffer memory
; $40-8c is the main player state vars, e.g. player id up to scroll counters
; $0180 is mostly used for palettes
WIPE_PLAYER_AND_PALETTE_DATA:
        ; load some data from ROM to $40-8c; fill $0180-9f data buffer with x0F
		ldx     #$40                            ; B631 A2 40                    .@
LB633:
        lda     TBL_PLAYER_DATA_INIT,x                         ; B633 BD 9F 9B                 ...
        sta     $00,x                           ; B636 95 00                    ..
        inx                                     ; B638 E8                       .
        cpx     #$8C                            ; B639 E0 8C                    ..
        bne     LB633                           ; B63B D0 F6                    ..
        
		; loop to set DATA_BUFFER_0180-$019f to x0F
		lda     #$0F                            ; B63D A9 0F                    ..
        ldx     #$1F                            ; B63F A2 1F                    ..
LB641:
        sta     DATA_BUFFER_0180,x                         ; B641 9D 80 01                 ...
        dex                                     ; B644 CA                       .
        bpl     LB641                           ; B645 10 FA                    ..
        rts                                     ; B647 60                       `

; ----------------------------------------------------------------------------
; populates the name & attr tables for the start screen
; 1024 bytes pulled from a table
LOAD_START_SCREEN_GRAPHICS:
        ; disable nmi, advance VRAM horizontally
		lda     PPU_CTRL_COPY                             ; B648 A5 23                    .#
        pha                                     ; B64A 48                       H
        and     #$7B                            ; B64B 29 7B                    ){
        sta     PPU_CTRL                           ; B64D 8D 00 20                 .. 
        lda     #$00                            ; B650 A9 00                    ..
        sta     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; B652 85 29                    .)
        lda     PPU_MASK_COPY                             ; B654 A5 24                    .$
        pha                                     ; B656 48                       H
        and     #$E7                            ; B657 29 E7                    ).
        sta     PPU_MASK                           ; B659 8D 01 20                 .. 
        
		; write to $2000, nametable 0
		lda     #$20                            ; B65C A9 20                    . 
        sta     PPU_ADDRESS                           ; B65E 8D 06 20                 .. 
        lda     #$00                            ; B661 A9 00                    ..
        sta     PPU_ADDRESS                           ; B663 8D 06 20                 .. 
        ldx     #$00                            ; B666 A2 00                    ..
LB668:
		; loop to write 256 bytes to PPU
        lda     TBL_START_SCREEN_GRAPHICS_0,x                         ; B668 BD C9 9E                 ...
        sta     PPU_DATA_RW                           ; B66B 8D 07 20                 .. 
        inx                                     ; B66E E8                       .
        bne     LB668                           ; B66F D0 F7                    ..
        ldx     #$00                            ; B671 A2 00                    ..
LB673:
        ; loop to write 256 bytes to PPU
        lda     TBL_START_SCREEN_GRAPHICS_1,x                         ; B673 BD C9 9F                 ...
        sta     PPU_DATA_RW                           ; B676 8D 07 20                 .. 
        inx                                     ; B679 E8                       .
        bne     LB673                           ; B67A D0 F7                    ..
        ldx     #$00                            ; B67C A2 00                    ..
LB67E:
        ; loop to write 256 bytes to PPU
        lda     TBL_START_SCREEN_GRAPHICS_2,x                         ; B67E BD C9 A0                 ...
        sta     PPU_DATA_RW                           ; B681 8D 07 20                 .. 
        inx                                     ; B684 E8                       .
        bne     LB67E                           ; B685 D0 F7                    ..
        ldx     #$00                            ; B687 A2 00                    ..
LB689:
        ; loop to write 256 bytes to PPU
        lda     TBL_START_SCREEN_GRAPHICS_3,x                         ; B689 BD C9 A1                 ...
        sta     PPU_DATA_RW                           ; B68C 8D 07 20                 .. 
        inx                                     ; B68F E8                       .
        bne     LB689                           ; B690 D0 F7                    ..
        
		; set pattern tables for start screen
		lda     START_SCREEN_CHR_0                           ; B692 AD E9 A2                 ...
        sta     CHR_BANK_BG_0                             ; B695 85 2A                    .*
        lda     START_SCREEN_CHR_1                           ; B697 AD EA A2                 ...
        sta     CHR_BANK_BG_1                             ; B69A 85 2B                    .+
        
		; restore PPU state
		pla                                     ; B69C 68                       h
        sta     PPU_MASK_COPY                             ; B69D 85 24                    .$
        pla                                     ; B69F 68                       h
        sta     PPU_CTRL_COPY                             ; B6A0 85 23                    .#
        sta     PPU_CTRL                           ; B6A2 8D 00 20                 .. 
        rts                                     ; B6A5 60                       `

; ----------------------------------------------------------------------------
START_SCREEN_FADE_IN:
        lda     #$40                            ; B6A6 A9 40                    .@
        sta     SCRATCH_09                             ; B6A8 85 09                    ..
LB6AA:
        lda     #$05                            ; B6AA A9 05                    ..
        sta     NMI_WAIT_CTR                             ; B6AC 85 36                    .6
        jsr     INIT_START_SCREEN_PALETTE_BUFFER                           ; B6AE 20 F0 B6                  ..
        ldx     #$00                            ; B6B1 A2 00                    ..
        ldy     #$20                            ; B6B3 A0 20                    . 
        jsr     STEP_START_SCREEN_PALETTE_BUFFER                           ; B6B5 20 D0 B6                  ..
        
		; jump to $c135 / NMI_CLEAR_FLAGS_AND_WAIT
		lda     #$35                            ; B6B8 A9 35                    .5
        sta     JMP_DEST_0E_LO                             ; B6BA 85 0E                    ..
        lda     #$C1                            ; B6BC A9 C1                    ..
        sta     JMP_DEST_0F_HI                             ; B6BE 85 0F                    ..
        jsr     REVERT_PRG_AND_JUMP                           ; B6C0 20 E4 CC                  ..
        
		; loop, stepping palette
		lda     SCRATCH_09                             ; B6C3 A5 09                    ..
        sec                                     ; B6C5 38                       8
        sbc     #$10                            ; B6C6 E9 10                    ..
        sta     SCRATCH_09                             ; B6C8 85 09                    ..
        bpl     LB6AA                           ; B6CA 10 DE                    ..
        
		jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; B6CC 20 69 C5                  i.
        rts                                     ; B6CF 60                       `

; ----------------------------------------------------------------------------
STEP_START_SCREEN_PALETTE_BUFFER:
        ; use DATA_BUFFER_0180,x to set SCRATCH_08 and then update DATA_BUFFER_0180,x
		lda     DATA_BUFFER_0180,x                         ; B6D0 BD 80 01                 ...
        and     #$0F                            ; B6D3 29 0F                    ).
        sta     SCRATCH_08                             ; B6D5 85 08                    ..
        
		lda     DATA_BUFFER_0180,x                         ; B6D7 BD 80 01                 ...
        and     #$F0                            ; B6DA 29 F0                    ).
        sec                                     ; B6DC 38                       8
        sbc     SCRATCH_09                             ; B6DD E5 09                    ..
        
		; branch if upper nibble of DATA_BUFFER_0180,x was non-zero
		; if so, we'll OR it with SCRATCH_08 (original lower nibble)
		; if not, we'll set it to 0x0F
		bcs     LB6E6                           ; B6DF B0 05                    ..
        lda     #$0F                            ; B6E1 A9 0F                    ..
        jmp     LB6E8                           ; B6E3 4C E8 B6                 L..

; ----------------------------------------------------------------------------
LB6E6:
        ora     SCRATCH_08                             ; B6E6 05 08                    ..
LB6E8:
        sta     DATA_BUFFER_0180,x                         ; B6E8 9D 80 01                 ...
        inx                                     ; B6EB E8                       .
        dey                                     ; B6EC 88                       .
        bne     STEP_START_SCREEN_PALETTE_BUFFER                           ; B6ED D0 E1                    ..
        rts                                     ; B6EF 60                       `

; ----------------------------------------------------------------------------
INIT_START_SCREEN_PALETTE_BUFFER:
		; initialize DATA_BUFFER_0180-$019f from table at TBL_START_SCREEN_PALETTE
        ldx     #$1F                            ; B6F0 A2 1F                    ..
LB6F2:
        lda     TBL_START_SCREEN_PALETTE,x                         ; B6F2 BD C9 A2                 ...
        sta     DATA_BUFFER_0180,x                         ; B6F5 9D 80 01                 ...
        dex                                     ; B6F8 CA                       .
        bpl     LB6F2                           ; B6F9 10 F7                    ..
        rts                                     ; B6FB 60                       `

.include "include\bankc-d-credits-and-sprites.asm"		
		
.segment "PRG_EF"		

; ----------------------------------------------------------------------------
; Banks e-f: fixed banks/code
; ----------------------------------------------------------------------------

; Reset vector jumps here after a few instructions.
; see https://www.nesdev.org/wiki/Init_code for fun facts
RESET_C000:
        ; ignore IRQs (again)
		sei  									; C000 78                       x
        
		; initial config for stack, PPU, APU
		ldx     #$FF                            ; C001 A2 FF                    ..
        txs                                     ; C003 9A                       .
        
		; disable nmi, rendering, DMC IRQs
		lda     #$00                            ; C004 A9 00                    ..
        sta     PPU_CTRL                           ; C006 8D 00 20                 .. 
        sta     PPU_MASK                           ; C009 8D 01 20                 .. 
        sta     APU_DMC_TIMER                           ; C00C 8D 10 40                 ..@
        
		; enable all sound channels
		lda     #$1F                            ; C00F A9 1F                    ..
        sta     a:SOUND_APU_STAT_FLAGS                           ; C011 8D 27 00                 .'.
        sta     APU_STAT_4015                           ; C014 8D 15 40                 ..@
        
		; send a+b to joypad 2 - I guess to wake it up?
		lda     #$C0                            ; C017 A9 C0                    ..
        sta     JOY_2_REG                           ; C019 8D 17 40                 ..@
LC01C:
		; wait 2 frames to let PPU stabilize
        lda     PPU_STATUS                           ; C01C AD 02 20                 .. 
        bpl     LC01C                           ; C01F 10 FB                    ..
LC021:
        lda     PPU_STATUS                           ; C021 AD 02 20                 .. 
        bpl     LC021                           ; C024 10 FB                    ..

; restarting with Retry after a game over picks up here
NEW_GAME_RETRY:
		; again, stack --> xFF (to be sure?)
        ldx     #$FF                            ; C026 A2 FF                    ..
        txs                                     ; C028 9A                       .
        
		; configure mapper
		lda     #$00                            ; C029 A9 00                    ..
        sta     MAPPER_NAMETABLE_MIRRORING                           ; C02B 8D 00 A0                 ...
        jsr     USE_PRG_CD_AND_RETURN                           ; C02E 20 08 CD                  ..
        jmp     LC041                           ; C031 4C 41 C0                 LA.

; ----------------------------------------------------------------------------
; code here appears to be unused 
        .byte   $80                             ; C034 80                       .
        lda     #$07                            ; C035 A9 07                    ..
        sta     LAST_BANK_UPDATED                             ; C037 85 25                    .%
        sta     MAPPER_BANK_SELECT                           ; C039 8D 00 80                 ...
        lda     #$0D                            ; C03C A9 0D                    ..
        sta     MAPPER_BANK_VALUE                           ; C03E 8D 01 80                 ...

; Reset vector continues...
LC041:
		; initialize zero page and other RAM from bank CD tables
		; if starting a new game after dying and selecting 'retry' this is what
		; wipes all your items, etc.
        jsr     RESET_COPY_TABLES_1                           ; C041 20 C8 D1                  ..
        
		; jump to LOAD_START_SCREEN $AE64
		lda     #$64                            ; C044 A9 64                    .d
        sta     JMP_DEST_0E_LO                           ; C046 85 0E                    ..
        lda     #$AE                            ; C048 A9 AE                    ..
        sta     JMP_DEST_0F_HI                             ; C04A 85 0F                    ..
        jsr     USE_PRG_CD                           ; C04C 20 9C CC                  ..

; if you die and select continue, you jump here to enter the home with your items
; and scroll counter still intact - you can actually maintain scroll after death! 
NEW_GAME_CONTINUE:
        ; clear some vars
		lda     #$00                            ; C04F A9 00                    ..
        sta     PLAYER_HARD_LANDING_CTR                             ; C051 85 46                    .F
        sta     SCROLL_X_LO                             ; C053 85 7B                    .{
        sta     PX_LO                             ; C055 85 43                    .C
        
		; set scroll to be in front of house, player in doorway
		; then load the overworld map
		lda     #$30                            ; C057 A9 30                    .0
        sta     SCROLL_X_HI                             ; C059 85 7C                    .|
        lda     #$3C                            ; C05B A9 3C                    .<
        sta     PX_HI                             ; C05D 85 44                    .D
        lda     #$A0                            ; C05F A9 A0                    ..
        sta     PY                             ; C061 85 45                    .E
		jsr     LOAD_MAP_FULL                           ; C063 20 F2 C8                  ..
        
		; fake up press - not sure why?
		lda     #BTN_UP                            ; C066 A9 08                    ..
        sta     JOYPAD_INPUT                             ; C068 85 20                    . 
        jsr     UPDATE_PLAYER                           ; C06A 20 2B D4                  +.

; loop here and play frames until the player dies
GAMEPLAY_MAIN_LOOP:
		; branch if player alive
        lda     PLAYER_LIFE                             ; C06D A5 58                    .X
        bne     PLAY_A_FRAME                           ; C06F D0 22                    ."
        
		; else, player dead!
		lda     #$00                            ; C071 A9 00                    ..
        sta     INVULN_CTR                             ; C073 85 85                    ..
        jsr     DRAW_PLAYER                           ; C075 20 D8 C1                  ..
        
		; player dead - jump to $b307 / HANDLE_PLAYER_DEATH
		lda     #$07                            ; C078 A9 07                    ..
        sta     JMP_DEST_0E_LO                           ; C07A 85 0E                    ..
        lda     #$B3                            ; C07C A9 B3                    ..
        sta     JMP_DEST_0F_HI                             ; C07E 85 0F                    ..
        jsr     USE_PRG_CD                           ; C080 20 9C CC                  ..
        
		; x is the exit code for HANDLE_PLAYER_DEATH
		; 0 = not really dead (elixir or cheat enabled)
		; 1 = continue
		; 2 = retry
		cpx     #$00                            ; C083 E0 00                    ..
        bne     LC08A                           ; C085 D0 03                    ..
        
		; x=0 (not actually dead due to elixir or cheat!)
		jmp     GAMEPLAY_MAIN_LOOP                           ; C087 4C 6D C0                 Lm.

; ----------------------------------------------------------------------------
LC08A:
		; branch if x was originally 2
        dex                                     ; C08A CA                       .
        bne     LC090                           ; C08B D0 03                    ..
        
		; x was 1: continue - go back to home, keep items from last home visit
		jmp     NEW_GAME_CONTINUE                           ; C08D 4C 4F C0                 LO.

; ----------------------------------------------------------------------------
LC090:
		; retry: starting completely over, lose all items/golds/keys
        jmp     NEW_GAME_RETRY                           ; C090 4C 26 C0                 L&.

; ----------------------------------------------------------------------------
; main function for gameplay i.e. beyond the start screen
PLAY_A_FRAME:
        ; single frame delay, save SCROLL_X_HI
		lda     #$01                            ; C093 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; C095 85 36                    .6
        lda     SCROLL_X_HI                             ; C097 A5 7C                    .|
        sta     LAST_SCROLL_X_HI                             ; C099 85 7E                    .~
        
		; player takes action
		jsr     READ_JOYPADS                           ; C09B 20 43 CC                  C.
        jsr     UPDATE_PLAYER                           ; C09E 20 2B D4                  +.
        
		; branch if time to fight the dragon
		lda     DRAGON_FIGHT_FLAG                             ; C0A1 A5 EC                    ..
        bne     START_DRAGON_FIGHT                           ; C0A3 D0 24                    .$
        
		; not fighting the dragon
		; let player fire weapon if desired
		; update enemies/objects
		; update any e.g. block/door animations
		; figure out if we need to scroll
		jsr     HANDLE_PLAYER_FIRING                           ; C0A5 20 28 F6                  (.
        jsr     UPDATE_LEVEL_OBJECTS                           ; C0A8 20 7C E8                  |.
        jsr     HANDLE_BLOCK_ANIMATIONS                           ; C0AB 20 82 F7                  ..
        jsr     CALC_HORIZ_SCROLL_VARS                           ; C0AE 20 5D C1                  ].
        
		; save carry and draw
		php                                     ; C0B1 08                       .
        jsr     DRAW_PLAYER                           ; C0B2 20 D8 C1                  ..
        jsr     DRAW_OBJECTS                           ; C0B5 20 B1 C2                  ..
        
		; restore carry and branch if set (no scroll update flagged)
		plp                                     ; C0B8 28                       (
        bcs     LC0C3                           ; C0B9 B0 08                    ..
        
		; else, carry clear - compare LAST_SCROLL_X_HI to SCROLL_X_HI - if unequal then flag an update
		lda     LAST_SCROLL_X_HI                             ; C0BB A5 7E                    .~
        cmp     SCROLL_X_HI                             ; C0BD C5 7C                    .|
        beq     LC0C3                           ; C0BF F0 02                    ..
        inc     SCROLL_UPDATE_FLAG                             ; C0C1 E6 3D                    .=
LC0C3:
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C0C3 20 35 C1                  5.
        
		; loop
		jmp     GAMEPLAY_MAIN_LOOP                           ; C0C6 4C 6D C0                 Lm.

; ----------------------------------------------------------------------------
; we branch here from above if DRAGON_FIGHT_FLAG <> 0
; the dragon fight uses a whole separate game engine on banks c-d

; play the intro sequence
START_DRAGON_FIGHT:
		; jump to $a2eb / DRAGON_FIGHT_INTRO
        lda     #$EB                            ; C0C9 A9 EB                    ..
        sta     JMP_DEST_0E_LO                           ; C0CB 85 0E                    ..
        lda     #$A2                            ; C0CD A9 A2                    ..
        sta     JMP_DEST_0F_HI                             ; C0CF 85 0F                    ..
        jsr     USE_PRG_CD                           ; C0D1 20 9C CC                  ..

; now we loop here until the fight concludes
DRAGON_FIGHT_MAIN:
		; Roas is now fighting the dragon!
        jsr     READ_JOYPADS                           ; C0D4 20 43 CC                  C.
        
		; jump to $abbc / DRAGON_FIGHT_CHECK_JOYPAD
		lda     #$BC                            ; C0D7 A9 BC                    ..
        sta     JMP_DEST_0E_LO                           ; C0D9 85 0E                    ..
        lda     #$AB                            ; C0DB A9 AB                    ..
        sta     JMP_DEST_0F_HI                             ; C0DD 85 0F                    ..
        jsr     USE_PRG_CD                           ; C0DF 20 9C CC                  ..
        
		; jump to $a5e6 / DRAGONSLAYER_FIRE_AND_UPDATE
		lda     #$E6                            ; C0E2 A9 E6                    ..
        sta     JMP_DEST_0E_LO                           ; C0E4 85 0E                    ..
        lda     #$A5                            ; C0E6 A9 A5                    ..
        sta     JMP_DEST_0F_HI                             ; C0E8 85 0F                    ..
        jsr     USE_PRG_CD                           ; C0EA 20 9C CC                  ..
        
		; jump to $a75d / DRAGON_FIGHT_COPY_TO_SPRITE_0
		; sets up collision detection with Dragon
		lda     #$5D                            ; C0ED A9 5D                    .]
        sta     JMP_DEST_0E_LO                           ; C0EF 85 0E                    ..
        lda     #$A7                            ; C0F1 A9 A7                    ..
        sta     JMP_DEST_0F_HI                             ; C0F3 85 0F                    ..
        jsr     USE_PRG_CD                           ; C0F5 20 9C CC                  ..
        
		; jump to $A3E3 / CHECK_DRAGON_DAMAGE
		lda     #CUR_OBJ_SLOT_NUM                            ; C0F8 A9 E3                    ..
        sta     JMP_DEST_0E_LO                           ; C0FA 85 0E                    ..
        lda     #$A3                            ; C0FC A9 A3                    ..
        sta     JMP_DEST_0F_HI                             ; C0FE 85 0F                    ..
        jsr     USE_PRG_CD                           ; C100 20 9C CC                  ..
        
		; loop if player has life
		lda     PLAYER_LIFE                             ; C103 A5 58                    .X
        bne     DRAGON_FIGHT_MAIN                           ; C105 D0 CD                    ..
        
		; player has no life :(
		; convert from single-screen to dungeon level coords
		; I guess this is done so the death animation code can be re-used?
		lda     PX_LO                             ; C107 A5 43                    .C
        lsr     a                               ; C109 4A                       J
        lsr     a                               ; C10A 4A                       J
        lsr     a                               ; C10B 4A                       J
        lsr     a                               ; C10C 4A                       J
        sta     PX_HI                             ; C10D 85 44                    .D
        lda     PX_LO                             ; C10F A5 43                    .C
        and     #$0F                            ; C111 29 0F                    ).
        sta     PX_LO                             ; C113 85 43                    .C
        
		; disable status bar
		lda     #OFFSCREEN_Y                            ; C115 A9 EF                    ..
        sta     SPRITE_0_Y                           ; C117 8D 00 02                 ...
        
		; draw player and hop to $b307 / HANDLE_PLAYER_DEATH
		lda     #$00                            ; C11A A9 00                    ..
        sta     INVULN_CTR                             ; C11C 85 85                    ..
        jsr     DRAW_PLAYER                           ; C11E 20 D8 C1                  ..
        lda     #$07                            ; C121 A9 07                    ..
        sta     JMP_DEST_0E_LO                           ; C123 85 0E                    ..
        lda     #$B3                            ; C125 A9 B3                    ..
        sta     JMP_DEST_0F_HI                             ; C127 85 0F                    ..
        jsr     USE_PRG_CD                           ; C129 20 9C CC                  ..
        
		; x is our output from HANDLE_PLAYER_DEATH
		; In normal play, HANDLE_PLAYER_DEATH can return 0 if death has been cheated
		; or avoided with elixir, but not during the dragon fight so we subtract
		; 1 without checking
		dex                                     ; C12C CA                       .
        
		; branch if x<>0 - retry (2) was chosen and we go back to start screen (close to a soft reset)
		bne     LC132                           ; C12D D0 03                    ..
        
		; continue (1) was chosen and we'll go to the home and still have our items
		jmp     NEW_GAME_CONTINUE                           ; C12F 4C 4F C0                 LO.

; ----------------------------------------------------------------------------
LC132:
		; jumps to early in reset vector
        jmp     NEW_GAME_RETRY                           ; C132 4C 26 C0                 L&.

; ----------------------------------------------------------------------------
; performs any requested graphical updates and waits for NMI to run
NMI_CLEAR_FLAGS_AND_WAIT:
        ; branch if SCROLL_UPDATE_FLAG = 0
		lda     SCROLL_UPDATE_FLAG                             ; C135 A5 3D                    .=
        beq     LC143                           ; C137 F0 0A                    ..
        
		; SCROLL_UPDATE_FLAG non-zero; clear it 
		lda     #$00                            ; C139 A9 00                    ..
        sta     SCROLL_UPDATE_FLAG                             ; C13B 85 3D                    .=
        jsr     UPDATE_PPU_FOR_X_SCROLL                           ; C13D 20 FE C7                  ..
        jmp     LC158                           ; C140 4C 58 C1                 LX.

; ----------------------------------------------------------------------------
LC143:
        ; branch if STATUS_BAR_UPDATE_FLAG=0
		lda     STATUS_BAR_UPDATE_FLAG                             ; C143 A5 3C                    .<
        beq     LC151                           ; C145 F0 0A                    ..
        
		; STATUS_BAR_UPDATE_FLAG non-zero; clear it
		lda     #$00                            ; C147 A9 00                    ..
        sta     STATUS_BAR_UPDATE_FLAG                             ; C149 85 3C                    .<
        jsr     QUEUE_NMI_ROUTINE_STATUS_BAR_UPDATE                           ; C14B 20 A5 CA                  ..
        jmp     LC158                           ; C14E 4C 58 C1                 LX.

; ----------------------------------------------------------------------------
LC151:
        ; branch if NMI_WAIT_CTR=0
		lda     NMI_WAIT_CTR                             ; C151 A5 36                    .6
        beq     LC158                           ; C153 F0 03                    ..
        
		; NMI_WAIT_CTR non-zero
		jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; C155 20 69 C5                  i.
LC158:
        lda     NMI_WAIT_CTR                             ; C158 A5 36                    .6
        
		; loop while NMI_WAIT_CTR non-zero
		bne     LC158                           ; C15A D0 FC                    ..
        rts                                     ; C15C 60                       `

; ----------------------------------------------------------------------------
; Calculate updated scroll positions/direction based on the player's x position
; return - carry - clear if scroll update needs to be flagged
CALC_HORIZ_SCROLL_VARS:
        ; SCROLL_X_HI*16 | SCROLL_X_LO --> SCRATCH_08
		lda     SCROLL_X_HI                             ; C15D A5 7C                    .|
        asl     a                               ; C15F 0A                       .
        asl     a                               ; C160 0A                       .
        asl     a                               ; C161 0A                       .
        asl     a                               ; C162 0A                       .
        ora     SCROLL_X_LO                             ; C163 05 7B                    .{
        sta     SCRATCH_08                             ; C165 85 08                    ..
        
		; PX_HI*16 | PX_LO - SCRATCH_08
		lda     PX_HI                             ; C167 A5 44                    .D
        asl     a                               ; C169 0A                       .
        asl     a                               ; C16A 0A                       .
        asl     a                               ; C16B 0A                       .
        asl     a                               ; C16C 0A                       .
        ora     PX_LO                             ; C16D 05 43                    .C
        sec                                     ; C16F 38                       8
        sbc     SCRATCH_08                             ; C170 E5 08                    ..
        
		; difference < x60
		cmp     #$60                            ; C172 C9 60                    .`
        bcc     LC19D                           ; C174 90 27                    .'
        
		; difference 60-x91
		cmp     #$91                            ; C176 C9 91                    ..
        bcc     LC1C2                           ; C178 90 48                    .H
        lda     SCROLL_X_HI                             ; C17A A5 7C                    .|
        
		; else branch if SCROLL_X_HI >= x30
		cmp     #$30                            ; C17C C9 30                    .0
        bcs     LC192                           ; C17E B0 12                    ..
        
		; else here
		; PX_HI - 9 --> SCROLL_X_HI
		; PX_LO --> SCROLL_X_LO
		; 1 --> SCROLL_X_DIR
		lda     PX_HI                             ; C180 A5 44                    .D
        sec                                     ; C182 38                       8
        sbc     #$09                            ; C183 E9 09                    ..
        sta     SCROLL_X_HI                             ; C185 85 7C                    .|
        lda     PX_LO                             ; C187 A5 43                    .C
        sta     SCROLL_X_LO                             ; C189 85 7B                    .{
        
		; scrolling right
		lda     #$01                            ; C18B A9 01                    ..
        sta     SCROLL_X_DIR                             ; C18D 85 7F                    ..
        jmp     LC1BD                           ; C18F 4C BD C1                 L..

; ----------------------------------------------------------------------------
LC192:
		; rightmost edge of map section 
		; x30 --> SCROLL_X_HI
		; 0 --> SCROLL_X_LO
		; 
        lda     #$30                            ; C192 A9 30                    .0
        sta     SCROLL_X_HI                             ; C194 85 7C                    .|
        lda     #$00                            ; C196 A9 00                    ..
        sta     SCROLL_X_LO                             ; C198 85 7B                    .{
        jmp     LC1C2                           ; C19A 4C C2 C1                 L..

; ----------------------------------------------------------------------------
LC19D:
        ; branch if SCROLL_X_HI and SCROLL_X_LO both zero
		lda     SCROLL_X_HI                             ; C19D A5 7C                    .|
        ora     SCROLL_X_LO                             ; C19F 05 7B                    .{
        beq     LC1C2                           ; C1A1 F0 1F                    ..
        
		; branch if PX_HI < 6
		lda     PX_HI                             ; C1A3 A5 44                    .D
        sec                                     ; C1A5 38                       8
        sbc     #$06                            ; C1A6 E9 06                    ..
        bcc     LC1B7                           ; C1A8 90 0D                    ..
        
		; PX_HI >= 6
		; PX_HI - 6 --> SCROLL_X_HI
		; PX_LO --> SCROLL_X_LO
		; xFF --> SCROLL_X_DIR (scrolling left)
		sta     SCROLL_X_HI                             ; C1AA 85 7C                    .|
        lda     PX_LO                             ; C1AC A5 43                    .C
        sta     SCROLL_X_LO                             ; C1AE 85 7B                    .{
        lda     #$FF                            ; C1B0 A9 FF                    ..
        sta     SCROLL_X_DIR                             ; C1B2 85 7F                    ..
        jmp     LC1BD                           ; C1B4 4C BD C1                 L..

; ----------------------------------------------------------------------------
LC1B7:
        ; pin scroll at left edge and clear carry (flag scroll update)
		lda     #$00                            ; C1B7 A9 00                    ..
        sta     SCROLL_X_LO                             ; C1B9 85 7B                    .{
        sta     SCROLL_X_HI                             ; C1BB 85 7C                    .|
LC1BD:
        jsr     UPDATE_PPU_SCROLL_X                           ; C1BD 20 C7 C1                  ..
        clc                                     ; C1C0 18                       .
        rts                                     ; C1C1 60                       `

; ----------------------------------------------------------------------------
LC1C2:
		; scroll already at left edge; set carry (no scroll update flagged)
        jsr     UPDATE_PPU_SCROLL_X                           ; C1C2 20 C7 C1                  ..
        sec                                     ; C1C5 38                       8
        rts                                     ; C1C6 60                       `

; ----------------------------------------------------------------------------
; convert map x scroll vars to correct PPU scroll value, including selecting nametable
; via PPU_NAMETABLE_SELECT
UPDATE_PPU_SCROLL_X: ; $c1c7
        lda     SCROLL_X_HI                             ; C1C7 A5 7C                    .|
        asl     a                               ; C1C9 0A                       .
        asl     a                               ; C1CA 0A                       .
        asl     a                               ; C1CB 0A                       .
        asl     a                               ; C1CC 0A                       .
        ora     SCROLL_X_LO                             ; C1CD 05 7B                    .{
        tax                                     ; C1CF AA                       .
        
		; move carry flag to a and use it to set PPU_NAMETABLE_SELECT 
		lda     #$00                            ; C1D0 A9 00                    ..
        rol     a                               ; C1D2 2A                       *
        stx     PPU_SCROLL_X                             ; C1D3 86 1C                    ..
        sta     PPU_NAMETABLE_SELECT                             ; C1D5 85 1D                    ..
        rts                                     ; C1D7 60                       `

; ----------------------------------------------------------------------------
DRAW_PLAYER:
        ; branch if not invulnerable
		lda     INVULN_CTR                             ; C1D8 A5 85                    ..
        beq     LC1EB                           ; C1DA F0 0F                    ..
        
		; we are invulnerable - draw if frame_ctr%2 = 1 (flicker effect)
		lda     FRAME_CTR                             ; C1DC A5 84                    ..
        and     #$01                            ; C1DE 29 01                    ).
        bne     LC1EB                           ; C1E0 D0 09                    ..
        
		; else player is not drawn this farme
		lda     #OFFSCREEN_Y                            ; C1E2 A9 EF                    ..
        sta     PLAYER_SPRITE_0                           ; C1E4 8D 10 02                 ...
        sta     PLAYER_SPRITE_1                           ; C1E7 8D 14 02                 ...
        rts                                     ; C1EA 60                       `

; ----------------------------------------------------------------------------
LC1EB:
        ; set y values
		lda     PY                             ; C1EB A5 45                    .E
        clc                                     ; C1ED 18                       .
        adc     #OBJ_SCREEN_Y_PAD                            ; C1EE 69 2B                    i+
        sta     PLAYER_SPRITE_0                           ; C1F0 8D 10 02                 ...
        sta     PLAYER_SPRITE_1                           ; C1F3 8D 14 02                 ...
        
		; set x
		lda     SCROLL_X_HI                             ; C1F6 A5 7C                    .|
        asl     a                               ; C1F8 0A                       .
        asl     a                               ; C1F9 0A                       .
        asl     a                               ; C1FA 0A                       .
        asl     a                               ; C1FB 0A                       .
        ora     SCROLL_X_LO                             ; C1FC 05 7B                    .{
        sta     SCRATCH_08                             ; C1FE 85 08                    ..
        lda     PX_HI                             ; C200 A5 44                    .D
        asl     a                               ; C202 0A                       .
        asl     a                               ; C203 0A                       .
        asl     a                               ; C204 0A                       .
        asl     a                               ; C205 0A                       .
        ora     PX_LO                             ; C206 05 43                    .C
        sec                                     ; C208 38                       8
        sbc     SCRATCH_08                             ; C209 E5 08                    ..
        sta     PLAYER_SPRITE_0+3                           ; C20B 8D 13 02                 ...
        clc                                     ; C20E 18                       .
        adc     #$08                            ; C20F 69 08                    i.
        sta     PLAYER_SPRITE_1+3                           ; C211 8D 17 02                 ...
        
		; set flags
		lda     PLAYER_SPRITE_FLAGS                             ; C214 A5 57                    .W
        sta     PLAYER_SPRITE_0+2                           ; C216 8D 12 02                 ...
        sta     PLAYER_SPRITE_1+2                           ; C219 8D 16 02                 ...
        ldx     PLAYER_FRAME                             ; C21C A6 56                    .V
        
		; branch  if horizontally flipped
		bit     PLAYER_SPRITE_FLAGS                             ; C21E 24 57                    $W
        bvs     LC22B                           ; C220 70 09                    p.
        
		; not horizontally flipped
		stx     PLAYER_SPRITE_0+1                           ; C222 8E 11 02                 ...
        inx                                     ; C225 E8                       .
        inx                                     ; C226 E8                       .
        stx     PLAYER_SPRITE_1+1                           ; C227 8E 15 02                 ...
        rts                                     ; C22A 60                       `

; ----------------------------------------------------------------------------
LC22B:
        ; horizontally flipped
		stx     PLAYER_SPRITE_1+1                           ; C22B 8E 15 02                 ...
        inx                                     ; C22E E8                       .
        inx                                     ; C22F E8                       .
        stx     PLAYER_SPRITE_0+1                           ; C230 8E 11 02                 ...
        rts                                     ; C233 60                       `

; ----------------------------------------------------------------------------
; when visible, the current item cursor is drawn using sprites at $0238 and $023C
DRAW_EQUIP_ITEM_CURSOR:
        lda     CUR_EQUIP_SLOT_SELECTED                             ; C234 A5 55                    .U
        cmp     #EQUIP_SLOT_NOTHING_SELECTED                            ; C236 C9 03                    ..
        
		; set y screen value for cursor sprites
		ldx     #$13                            ; C238 A2 13                    ..
        
		; branch if an equipped item is selected (a<3)
		bcc     LC247              		; C23A 90 0B                    ..
        
		; no equipped item selected - ? equip cursor hidden
		ldx     #OFFSCREEN_Y                            ; C23C A2 EF                    ..
        stx     $0238                           ; C23E 8E 38 02                 .8.
        stx     $023C                           ; C241 8E 3C 02                 .<.
        jmp     LC26F                           ; C244 4C 6F C2                 Lo.

; ----------------------------------------------------------------------------
LC247:
		; equipped item is selected, a=slot index 0-2
		; set y values
        stx     $0238                           ; C247 8E 38 02                 .8.
        stx     $023C                           ; C24A 8E 3C 02                 .<.
        
		; cursor x pos: xC8 + index*16
		asl     a                               ; C24D 0A                       .
        asl     a                               ; C24E 0A                       .
        asl     a                               ; C24F 0A                       .
        asl     a                               ; C250 0A                       .
        clc                                     ; C251 18                       .
        adc     #$C8                            ; C252 69 C8                    i.
        sta     $023B                           ; C254 8D 3B 02                 .;.
        
		; and the right side +8
		clc                                     ; C257 18                       .
        adc     #$08                            ; C258 69 08                    i.
		sta     $023F                           ; C25A 8D 3F 02                 .?.
        
		; set flags (all on?)
		lda     #$FF                            ; C25D A9 FF                    ..
        sta     $0239                           ; C25F 8D 39 02                 .9.
        sta     $023D                           ; C262 8D 3D 02                 .=.
        
		; set sprite ids
		lda     #$01                            ; C265 A9 01                    ..
        sta     $023A                           ; C267 8D 3A 02                 .:.
        lda     #$41                            ; C26A A9 41                    .A
        sta     $023E                           ; C26C 8D 3E 02                 .>.
LC26F:
        ldx     #$02                            ; C26F A2 02                    ..
        ldy     #$10                            ; C271 A0 10                    ..

; equipped items are drawn using 3 pairs of sprites starting at $0220
DRAW_EQUIP_ITEMS:
        lda     CUR_EQUIP_ITEMS,x                           ; C273 B5 51                    .Q
        
		; branch (force offscreen) if equipped item <0 i.e. blank
		bmi     LC2A0                           ; C275 30 29                    0)
        
		; mult by 4 and add xA1 --> flags?
		asl     a                               ; C277 0A                       .
        asl     a                               ; C278 0A                       .
        clc                                     ; C279 18                       .
        adc     #$A1                            ; C27A 69 A1                    i.
        sta     $0221,y                         ; C27C 99 21 02                 .!.
        clc                                     ; C27F 18                       .
        adc     #$02                            ; C280 69 02                    i.
        sta     $0225,y                         ; C282 99 25 02                 .%.
        tya                                     ; C285 98                       .
        
		; mult a*2 and add xC8 --> xE8
		asl     a                               ; C286 0A                       .
        clc                                     ; C287 18                       .
        adc     #$C8                            ; C288 69 C8                    i.
        
		; set the x coords
		sta     $0223,y                         ; C28A 99 23 02                 .#.
        clc                                     ; C28D 18                       .
        adc     #$08                            ; C28E 69 08                    i.
        sta     $0227,y                         ; C290 99 27 02                 .'.
        
		; set sprite flags
		lda     #$01                            ; C293 A9 01                    ..
        sta     $0222,y                         ; C295 99 22 02                 .".
        sta     $0226,y                         ; C298 99 26 02                 .&.
        
		; default y coord
		lda     #$13                            ; C29B A9 13                    ..
        jmp     LC2A2                           ; C29D 4C A2 C2                 L..

; ----------------------------------------------------------------------------
LC2A0:
		; force sprite offscreen if nothing equipped
        lda     #OFFSCREEN_Y                            ; C2A0 A9 EF                    ..
LC2A2:
		; otherwise, y=x13
        sta     $0220,y                         ; C2A2 99 20 02                 . .
        sta     $0224,y                         ; C2A5 99 24 02                 .$.
        
		; next item will be drawn 2 sprite slots earlier (y -= 8 bytes)
		tya                                     ; C2A8 98                       .
        sec                                     ; C2A9 38                       8
        sbc     #$08                            ; C2AA E9 08                    ..
        tay                                     ; C2AC A8                       .
        dex                                     ; C2AD CA                       .
        
		; while x >= 0, loop to draw each item
		bpl     DRAW_EQUIP_ITEMS                           ; C2AE 10 C3                    ..
        rts                                     ; C2B0 60                       `

; ----------------------------------------------------------------------------
; draw the objects - enemies, treasure chests & items inside, monster drop items, temp objects (animating moveable blocks, etc)
; FIRST_OBJECT_OFFSET is used to draw 1/3 of objects on each frame
DRAW_OBJECTS:
        ; LOOP_COUNTER_0A used as a loop counter
		lda     #$10                            ; C2B1 A9 10                    ..
        sta     LOOP_COUNTER_0A                             ; C2B3 85 0A                    ..
        ldx     OBJECT_SPRITE_RAM_START                             ; C2B5 A6 3F                    .?
        ldy     FIRST_OBJECT_OFFSET                             ; C2B7 A4 3E                    .>
LC2B9:
        jsr     DRAW_OBJECT_Y                           ; C2B9 20 DB C2                  ..
        
		; loops add 8 to x (with bit 7 always set) and x30 to y
		; first x used will be OBJECT_SPRITE_RAM_START + 8 | x80; increases by 8 each time to advance by 2 sprites
		; first y used will be FIRST_OBJECT_OFFSET+x30
		txa                                     ; C2BC 8A                       .
        clc                                     ; C2BD 18                       .
        adc     #$08                            ; C2BE 69 08                    i.
        ora     #$80                            ; C2C0 09 80                    ..
        tax                                     ; C2C2 AA                       .
        
		; advanced by x30 (3 objects), so draw 1/3 of objects on each call
		tya                                     ; C2C3 98                       .
        clc                                     ; C2C4 18                       .
        adc     #$30                            ; C2C5 69 30                    i0
        tay                                     ; C2C7 A8                       .
        dec     LOOP_COUNTER_0A                             ; C2C8 C6 0A                    ..
        
		; loop while LOOP_COUNTER_0A > 0
		bne     LC2B9                           ; C2CA D0 ED                    ..
        
		; setup for next time
		; x advanced by x38 (7 sprites) with bit 7 always set (so >0280)
		; y advanced by x10, so each function call will draw an object every 3rd time
		txa                                     ; C2CC 8A                       .
        clc                                     ; C2CD 18                       .
        adc     #$38                            ; C2CE 69 38                    i8
        ora     #$80                            ; C2D0 09 80                    ..
        sta     OBJECT_SPRITE_RAM_START                             ; C2D2 85 3F                    .?
        tya                                     ; C2D4 98                       .
        clc                                     ; C2D5 18                       .
        adc     #$10                            ; C2D6 69 10                    i.
        sta     FIRST_OBJECT_OFFSET                             ; C2D8 85 3E                    .>
        rts                                     ; C2DA 60                       `

; ----------------------------------------------------------------------------
; inputs - y = offset in object data array ($0400s)
;          x = offset to sprite RAM ($0200s) 
DRAW_OBJECT_Y:
        lda     OBJ_GENERAL_TYPE,y                         ; C2DB B9 01 04                 ...
        
		; branch (erase sprite) if OBJ_GENERAL_TYPE = 0 (empty)
		beq     LC35A                           ; C2DE F0 7A                    .z
        lda     OBJ_Y,y                         ; C2E0 B9 0E 04                 ...
        cmp     #MAX_SCREEN_Y_POS                            ; C2E3 C9 BF                    ..
        
		; branch (erase sprite) if falling of bottom of screen
		bcs     LC35A                           ; C2E5 B0 73                    .s
        
		; obj non-zero type, hasn't fallen offscreen
		lda     OBJ_SPRITE_FLAGS,y                         ; C2E7 B9 02 04                 ...
        sta     SPRITE_0_FLAGS,x                         ; C2EA 9D 02 02                 ...
        sta     SPRITE_0_FLAGS+4,x                         ; C2ED 9D 06 02                 ...
		and     #$40                            ; C2F0 29 40                    )@
        
		; branch if sprite flag 6 set
		bne     LC302                           ; C2F2 D0 0E                    ..
        
		; sprite flag 6 clear
		; set the sprite IDs (2 for each object)
		lda     OBJ_SPRITE,y                         ; C2F4 B9 00 04                 ...
        sta     SPRITE_0_ID,x                         ; C2F7 9D 01 02                 ...
        
		; 2nd sprite ID is +2 by custom
		adc     #$02                            ; C2FA 69 02                    i.
        sta     SPRITE_0_ID+4,x                         ; C2FC 9D 05 02                 ...
        jmp     LC30D                           ; C2FF 4C 0D C3                 L..

; ----------------------------------------------------------------------------
LC302:
        ; set sprite IDs - using lower ID # for the SPRITE_0_ID+4 sprite instead of the SPRITE_0_ID one
		lda     OBJ_SPRITE,y                         ; C302 B9 00 04                 ...
        sta     SPRITE_0_ID+4,x                         ; C305 9D 05 02                 ...
        adc     #$02                            ; C308 69 02                    i.
        sta     SPRITE_0_ID,x                         ; C30A 9D 01 02                 ...
LC30D:
        ; object X_LO difference with x scroll --> SCRATCH_08
		lda     OBJ_X_LO,y                         ; C30D B9 0C 04                 ...
        sec                                     ; C310 38                       8
        sbc     SCROLL_X_LO                             ; C311 E5 7B                    .{
        and     #$0F                            ; C313 29 0F                    ).
        sta     SCRATCH_08                             ; C315 85 08                    ..
        
		; branch if object >= 10 blocks right of left edge of screen
		lda     OBJ_X_HI,y                         ; C317 B9 0D 04                 ...
        sbc     SCROLL_X_HI                             ; C31A E5 7C                    .|
        cmp     #$10                            ; C31C C9 10                    ..
        bcs     LC35A                           ; C31E B0 3A                    .:
        
		; < 10 blocks from left edge; mult the diff by 16 (upper nibble) and ORA with existing SCRATCH_08 as lower nibble
		asl     a                               ; C320 0A                       .
        asl     a                               ; C321 0A                       .
        asl     a                               ; C322 0A                       .
        asl     a                               ; C323 0A                       .
        ora     SCRATCH_08                             ; C324 05 08                    ..
        sta     SCRATCH_08                             ; C326 85 08                    ..
		
		; branch if not type 1 (enemy)
		lda     OBJ_GENERAL_TYPE,y                         ; C328 B9 01 04                 ...
        cmp     #OBJ_GEN_TYPE_ENEMY                            ; C32B C9 01                    ..
		bne     LC33E                           ; C32D D0 0F                    ..
        
		; branch if not being hit by projectile
		lda     OBJ_PROJECTILE_WIGGLE,y                         ; C32F B9 0F 04                 ...
        beq     LC33E                           ; C332 F0 0A                    ..
        
		; being hit by projectile (projectile code sets it to xFE or x02)
		; add it to SCRATCH_08 and clear OBJ_PROJECTILE_WIGGLE
		; this makes enemies wiggle 2 px left/right while a projectile is hitting them
		clc                                     ; C334 18                       .
        adc     SCRATCH_08                             ; C335 65 08                    e.
        sta     SCRATCH_08                             ; C337 85 08                    ..
        lda     #$00                            ; C339 A9 00                    ..
        sta     OBJ_PROJECTILE_WIGGLE,y                         ; C33B 99 0F 04                 ...
LC33E:
        ; branch (2nd sprite in pair offscreen) if SCRATCH_08 >= OFFSCREEN_Y
		lda     SCRATCH_08                             ; C33E A5 08                    ..
        cmp     #OFFSCREEN_Y                            ; C340 C9 EF                    ..
		bcs     LC363                           ; C342 B0 1F                    ..
        
		; both sprites onscreen; set the x and y
		sta     SPRITE_0_X,x                         ; C344 9D 03 02                 ...
        clc                                     ; C347 18                       .
        adc     #$08                            ; C348 69 08                    i.
        sta     SPRITE_0_X+4,x                         ; C34A 9D 07 02                 ...
        
		; set the y positions
		lda     OBJ_Y,y                         ; C34D B9 0E 04                 ...
        clc                                     ; C350 18                       .
        adc     #OBJ_SCREEN_Y_PAD                            ; C351 69 2B                    i+
        sta     SPRITE_0_Y,x                         ; C353 9D 00 02                 ...
        sta     SPRITE_1_Y,x                         ; C356 9D 04 02                 ...
        rts                                     ; C359 60                       `

; ----------------------------------------------------------------------------
; move the sprite specified by X offscreen
LC35A:
        lda     #OFFSCREEN_Y                            ; C35A A9 EF                    ..
        sta     SPRITE_0_Y,x                         ; C35C 9D 00 02                 ...
        sta     SPRITE_1_Y,x                         ; C35F 9D 04 02                 ...
        rts                                     ; C362 60                       `

; ----------------------------------------------------------------------------
; set x and y for the first sprite of a pair specified by x, with the 2nd drawn offscreen
LC363:
        sta     SPRITE_0_X,x                         ; C363 9D 03 02                 ...
        lda     OBJ_Y,y                         ; C366 B9 0E 04                 ...
        clc                                     ; C369 18                       .
        adc     #OBJ_SCREEN_Y_PAD                            ; C36A 69 2B                    i+
        sta     SPRITE_0_Y,x                         ; C36C 9D 00 02                 ...
        lda     #OFFSCREEN_Y                            ; C36F A9 EF                    ..
        sta     SPRITE_1_Y,x                         ; C371 9D 04 02                 ...
        rts                                     ; C374 60                       `

; ----------------------------------------------------------------------------
; writes sprite 0 values from table
; then writes xF8 to every other sprite value
WIPE_SPRITES_EXCEPT_0:
        ldx     #$03                            ; C375 A2 03                    ..
LC377:
        lda     TBL_SPRITE_0_VALUES,x                         ; C377 BD 6B FF                 .k.
        sta     SPRITE_0_Y,x                         ; C37A 9D 00 02                 ...
        dex                                     ; C37D CA                       .
        bpl     LC377                           ; C37E 10 F7                    ..
        ldx     #$04                            ; C380 A2 04                    ..
LC382:
        lda     #$F8                            ; C382 A9 F8                    ..
        sta     SPRITE_0_Y,x                         ; C384 9D 00 02                 ...
        inx                                     ; C387 E8                       .
        bne     LC382                           ; C388 D0 F8                    ..
        rts                                     ; C38A 60                       `

; ----------------------------------------------------------------------------
; fills both nametables with xC0, fills attr table 0 with x00. 
; leaves attr table 1 alone for whatever reason...
WIPE_NAMETABLE: ; $c38b
        
		lda     PPU_CTRL_COPY                             ; C38B A5 23                    .#
        pha                                     ; C38D 48                       H
        
		; clear bits 2 (inc VRAM by 1, horiz) and 7 (disable NMI) from PPU_CTRL_COPY and write to PPU_CTRL
		and     #$7B                            ; C38E 29 7B                    ){
        sta     PPU_CTRL                           ; C390 8D 00 20                 .. 
        lda     #$00                            ; C393 A9 00                    ..
        sta     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; C395 85 29                    .)
        lda     PPU_MASK_COPY                             ; C397 A5 24                    .$
        pha                                     ; C399 48                       H
        and     #$E7                            ; C39A 29 E7                    ).
        sta     PPU_MASK                           ; C39C 8D 01 20                 .. 
        
		; writing to $2000, nametable 0 ($2000-23bf); set xC0 bytes to value xC0
		; and do this 5 times
		lda     #$20                            ; C39F A9 20                    . 
        sta     PPU_ADDRESS                           ; C3A1 8D 06 20                 .. 
        lda     #$00                            ; C3A4 A9 00                    ..
        sta     PPU_ADDRESS                           ; C3A6 8D 06 20                 .. 
        lda     #$C0                            ; C3A9 A9 C0                    ..
        ldy     #$05                            ; C3AB A0 05                    ..
LC3AD:
        ldx     #$C0                            ; C3AD A2 C0                    ..
LC3AF:
        sta     PPU_DATA_RW                           ; C3AF 8D 07 20                 .. 
        
		; loop while x>0
		dex 		; C3B2 CA                       .
        bne     LC3AF                           ; C3B3 D0 FA                    ..
        
		; loop while y>0
		dey                                     ; C3B5 88                       .
        bne     LC3AD                           ; C3B6 D0 F5                    ..
        
		; now write 64 bytes of x00 (attribute table 0, $23c0-ff)
		lda     #$00                            ; C3B8 A9 00                    ..
        ldx     #$40                            ; C3BA A2 40                    .@
LC3BC:
        sta     PPU_DATA_RW                           ; C3BC 8D 07 20                 .. 
        dex                                     ; C3BF CA                       .
        bne     LC3BC                           ; C3C0 D0 FA                    ..
        
		; ...and another 960 bytes of xC0 (nametable 1 2400-27bf)
		lda     #$C0                            ; C3C2 A9 C0                    ..
        ldy     #$05                            ; C3C4 A0 05                    ..
LC3C6:
        ldx     #$C0                            ; C3C6 A2 C0                    ..
LC3C8:
        sta     PPU_DATA_RW                           ; C3C8 8D 07 20                 .. 
        dex                                     ; C3CB CA                       .
        bne     LC3C8                           ; C3CC D0 FA                    ..
        dey                                     ; C3CE 88                       .
        bne     LC3C6                           ; C3CF D0 F5                    ..
        lda     #$00                            ; C3D1 A9 00                    ..
        ldx     #$40                            ; C3D3 A2 40                    .@
LC3D5:
        sta     PPU_DATA_RW                           ; C3D5 8D 07 20                 .. 
        dex                                     ; C3D8 CA                       .
        bne     LC3D5                           ; C3D9 D0 FA                    ..
        
		; restore PPU settings
		pla                                     ; C3DB 68                       h
        sta     PPU_MASK_COPY                             ; C3DC 85 24                    .$
        pla                                     ; C3DE 68                       h
        sta     PPU_CTRL_COPY                             ; C3DF 85 23                    .#
        sta     PPU_CTRL                           ; C3E1 8D 00 20                 .. 
        rts                                     ; C3E4 60                       `

; ----------------------------------------------------------------------------
; called when entering/leaving locations
; likely fadeout
PALETTE_FADE_OUT:
		; fadeout is both palettes and sound!
		; 4 steps of 5 frames apiece
        inc     SND_FADE_OUT_FLAG                             ; C3E5 E6 92                    ..
        ldy     #$04                            ; C3E7 A0 04                    ..
LC3E9:
        tya                                     ; C3E9 98                       .
        pha                                     ; C3EA 48                       H
        lda     #$05                            ; C3EB A9 05                    ..
        sta     NMI_WAIT_CTR                             ; C3ED 85 36                    .6
        
		; 28 bytes from PALETTE_BUFFER_NON_STATUS_BAR to $19f
		ldx     #$1C                            ; C3EF A2 1C                    ..
LC3F1:
        lda     PALETTE_BUFFER_NON_STATUS_BAR,x                         ; C3F1 BD 84 01                 ...
        and     #$0F                            ; C3F4 29 0F                    ).
        sta     SCRATCH_08                             ; C3F6 85 08                    ..
        lda     PALETTE_BUFFER_NON_STATUS_BAR,x                         ; C3F8 BD 84 01                 ...
        and     #$F0                            ; C3FB 29 F0                    ).
        sec                                     ; C3FD 38                       8
        sbc     #$10                            ; C3FE E9 10                    ..
        bcs     LC407                           ; C400 B0 05                    ..
	    lda     #$0F                            ; C402 A9 0F                    ..
        jmp     LC409                           ; C404 4C 09 C4                 L..

; ----------------------------------------------------------------------------
LC407:
        ora     SCRATCH_08                             ; C407 05 08                    ..
LC409:
        sta     PALETTE_BUFFER_NON_STATUS_BAR,x                         ; C409 9D 84 01                 ...
        dex                                     ; C40C CA                       .
        
		; loop while x >= 0
		bpl     LC3F1                           ; C40D 10 E2                    ..
        
		; cut the volume in half
		lsr     SND_CHAN_VOL_MULTIPLIER                             ; C40F 46 A0                    F.
        lsr     SND_VOL_FADE_B0                             ; C411 46 B0                    F.
        lsr     SND_VOL_FADE_D0                             ; C413 46 D0                    F.
        lda     #$00                            ; C415 A9 00                    ..
        sta     SND_CTRL_TRIANGLE                             ; C417 85 B4                    ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C419 20 35 C1                  5.
        pla                                     ; C41C 68                       h
        tay                                     ; C41D A8                       .
        dey                                     ; C41E 88                       .
        
		; branch while y <> 0
		bne     LC3E9                           ; C41F D0 C8                    ..
        
		; y = 0; kill the music and sound entirely
		lda     #MUSIC_NONE                            ; C421 A9 FF                    ..
		sta     MUSIC_ID                             ; C423 85 8E                    ..
        lda     #$00                            ; C425 A9 00                    ..
        sta     SND_CHAN_CTRL                             ; C427 85 94                    ..
        sta     SND_CTRL_SQ2                             ; C429 85 A4                    ..
        sta     SND_CTRL_NOISE                             ; C42B 85 C4                    ..
        sta     SND_FADE_OUT_FLAG                             ; C42D 85 92                    ..
        rts                                     ; C42F 60                       `

; ----------------------------------------------------------------------------
; fade palettes other than the status bar
PALETTE_FADE_OUT_KEEP_STATUS_BAR:
        ldy     #$04                            ; C430 A0 04                    ..
LC432:
        tya                                     ; C432 98                       .
        pha                                     ; C433 48                       H
        lda     #$05                            ; C434 A9 05                    ..
        sta     NMI_WAIT_CTR                             ; C436 85 36                    .6
        ldx     #$1C                            ; C438 A2 1C                    ..
LC43A:
        lda     PALETTE_BUFFER_NON_STATUS_BAR,x                         ; C43A BD 84 01                 ...
        and     #$0F                            ; C43D 29 0F                    ).
        sta     SCRATCH_08                             ; C43F 85 08                    ..
        lda     PALETTE_BUFFER_NON_STATUS_BAR,x                         ; C441 BD 84 01                 ...
        and     #$F0                            ; C444 29 F0                    ).
        sec                                     ; C446 38                       8
        sbc     #$10                            ; C447 E9 10                    ..
        bcs     LC450                           ; C449 B0 05                    ..
        lda     #$0F                            ; C44B A9 0F                    ..
        jmp     LC452                           ; C44D 4C 52 C4                 LR.

; ----------------------------------------------------------------------------
LC450:
        ora     SCRATCH_08                             ; C450 05 08                    ..
LC452:
        sta     PALETTE_BUFFER_NON_STATUS_BAR,x                         ; C452 9D 84 01                 ...
        dex                                     ; C455 CA                       .
        bpl     LC43A                           ; C456 10 E2                    ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C458 20 35 C1                  5.
        pla                                     ; C45B 68                       h
        tay                                     ; C45C A8                       .
        dey                                     ; C45D 88                       .
        bne     LC432                           ; C45E D0 D2                    ..
        rts                                     ; C460 60                       `

; ----------------------------------------------------------------------------
PALETTE_FADE_OUT_LC461:
        ldy     #$04                            ; C461 A0 04                    ..
LC463:
        tya                                     ; C463 98                       .
        pha                                     ; C464 48                       H
        lda     #$05                            ; C465 A9 05                    ..
        sta     NMI_WAIT_CTR                             ; C467 85 36                    .6
        
		; similar to elsewhere, loop to update DATA_BUFFER_0180,x based on subtraction from upper nibble
		ldx     #$20                            ; C469 A2 20                    . 
LC46B:
        lda     DATA_BUFFER_0180,x                         ; C46B BD 80 01                 ...
        and     #$0F                            ; C46E 29 0F                    ).
        sta     SCRATCH_08                             ; C470 85 08                    ..
        lda     DATA_BUFFER_0180,x                         ; C472 BD 80 01                 ...
        and     #$F0                            ; C475 29 F0                    ).
        sec                                     ; C477 38                       8
        sbc     #$10                            ; C478 E9 10                    ..
        bcs     LC481                           ; C47A B0 05                    ..
        lda     #$0F                            ; C47C A9 0F                    ..
        jmp     LC483                           ; C47E 4C 83 C4                 L..

; ----------------------------------------------------------------------------
LC481:
        ora     SCRATCH_08                             ; C481 05 08                    ..
LC483:
        sta     DATA_BUFFER_0180,x                         ; C483 9D 80 01                 ...
        dex                                     ; C486 CA                       .
        bpl     LC46B                           ; C487 10 E2                    ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C489 20 35 C1                  5.
        pla                                     ; C48C 68                       h
        tay                                     ; C48D A8                       .
        dey                                     ; C48E 88                       .
        bne     LC463                           ; C48F D0 D2                    ..
        rts                                     ; C491 60                       `

; ----------------------------------------------------------------------------
; loop to do a palette fade here, 5 frames each step
PALETTE_FADE_IN:
        lda     #$40                            ; C492 A9 40                    .@
        sta     SCRATCH_09                             ; C494 85 09                    ..
LC496:
        lda     #$05                            ; C496 A9 05                    ..
        sta     NMI_WAIT_CTR                             ; C498 85 36                    .6
        jsr     SET_PLAYER_AND_MAP_PALETTES                           ; C49A 20 FB C9                  ..
        ldx     #$04                            ; C49D A2 04                    ..
        ldy     #$1C                            ; C49F A0 1C                    ..
        jsr     STEP_PALETTE_FADE_LC520                           ; C4A1 20 20 C5                   .
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C4A4 20 35 C1                  5.
        lda     SCRATCH_09                             ; C4A7 A5 09                    ..
        sec                                     ; C4A9 38                       8
        sbc     #$10                            ; C4AA E9 10                    ..
        sta     SCRATCH_09                             ; C4AC 85 09                    ..
        
		; loop while SCRATCH_09 positive
		bpl     LC496                           ; C4AE 10 E6                    ..
        jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; C4B0 20 69 C5                  i.
        rts                                     ; C4B3 60                       `

; ----------------------------------------------------------------------------
; used at game over --> Continue
CONTINUE_FADE_TO_HOME: ;$c4b4
        lda     #$40                            ; C4B4 A9 40                    .@
        sta     SCRATCH_09                             ; C4B6 85 09                    ..
LC4B8:
        lda     #$05                            ; C4B8 A9 05                    ..
        sta     NMI_WAIT_CTR                             ; C4BA 85 36                    .6
        
		; loop to load tiles in $a0 buffer
		ldx     #$04                            ; C4BC A2 04                    ..
        ldy     #$E0                            ; C4BE A0 E0                    ..
LC4C0:
        lda     (MAP_DATA_LO),y                         ; C4C0 B1 77                    .w
        sta     DATA_BUFFER_A0,y                           ; C4C2 99 A0 00                 ...
        iny                                     ; C4C5 C8                       .
        dex                                     ; C4C6 CA                       .
        bne     LC4C0                           ; C4C7 D0 F7                    ..
        
		; loop 5 times and do a fade
		ldx     #$00                            ; C4C9 A2 00                    ..
        ldy     #$04                            ; C4CB A0 04                    ..
        jsr     STEP_PALETTE_FADE_LC520                           ; C4CD 20 20 C5                   .
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C4D0 20 35 C1                  5.
        lda     SCRATCH_09                             ; C4D3 A5 09                    ..
        sec                                     ; C4D5 38                       8
        sbc     #$10                            ; C4D6 E9 10                    ..
        sta     SCRATCH_09                             ; C4D8 85 09                    ..
        bpl     LC4B8                           ; C4DA 10 DC                    ..
        
		; update palettes
		jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; C4DC 20 69 C5                  i.
        rts                                     ; C4DF 60                       `

; ----------------------------------------------------------------------------
; $c4e0 - fade transition, e.g. showing game over screen
        lda     #$40                            ; C4E0 A9 40                    .@
        sta     SCRATCH_09                             ; C4E2 85 09                    ..
LC4E4:
        lda     #$05                            ; C4E4 A9 05                    ..
        sta     NMI_WAIT_CTR                             ; C4E6 85 36                    .6
        ldx     #$04                            ; C4E8 A2 04                    ..
        ldy     #$E0                            ; C4EA A0 E0                    ..
LC4EC:
		; loop to load 4 bytes at DATA_BUFFER_A0,y
        lda     (MAP_DATA_LO),y                         ; C4EC B1 77                    .w
        sta     DATA_BUFFER_A0,y                           ; C4EE 99 A0 00                 ...
        iny                                     ; C4F1 C8                       .
        dex                                     ; C4F2 CA                       .
        bne     LC4EC                           ; C4F3 D0 F7                    ..
        ldx     #$04                            ; C4F5 A2 04                    ..
        ldy     #$F0                            ; C4F7 A0 F0                    ..
LC4F9:
		; load 4 more bytes at DATA_BUFFER_A0,y
        lda     (MAP_DATA_LO),y                         ; C4F9 B1 77                    .w
        sta     DATA_BUFFER_A0,y                           ; C4FB 99 A0 00                 ...
        iny                                     ; C4FE C8                       .
        dex                                     ; C4FF CA                       .
        bne     LC4F9                           ; C500 D0 F7                    ..
        ldx     #$00                            ; C502 A2 00                    ..
        ldy     #$04                            ; C504 A0 04                    ..
        jsr     STEP_PALETTE_FADE_LC520                           ; C506 20 20 C5                   .
        ldx     #$10                            ; C509 A2 10                    ..
        ldy     #$04                            ; C50B A0 04                    ..
        jsr     STEP_PALETTE_FADE_LC520                           ; C50D 20 20 C5                   .
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C510 20 35 C1                  5.
        lda     SCRATCH_09                             ; C513 A5 09                    ..
        sec                                     ; C515 38                       8
        sbc     #$10                            ; C516 E9 10                    ..
        sta     SCRATCH_09                             ; C518 85 09                    ..
        bpl     LC4E4                           ; C51A 10 C8                    ..
        jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; C51C 20 69 C5                  i.
        rts                                     ; C51F 60                       `

; ----------------------------------------------------------------------------
; similar to elsewhere = update DATA_BUFFER_0180,x based on subtraction from upper nibble
STEP_PALETTE_FADE_LC520:
        lda     DATA_BUFFER_0180,x                         ; C520 BD 80 01                 ...
        and     #$0F                            ; C523 29 0F                    ).
        sta     SCRATCH_08                             ; C525 85 08                    ..
        lda     DATA_BUFFER_0180,x                         ; C527 BD 80 01                 ...
        and     #$F0                            ; C52A 29 F0                    ).
        sec                                     ; C52C 38                       8
        sbc     SCRATCH_09                             ; C52D E5 09                    ..
        bcs     LC536                           ; C52F B0 05                    ..
        lda     #$0F                            ; C531 A9 0F                    ..
        jmp     LC538                           ; C533 4C 38 C5                 L8.

; ----------------------------------------------------------------------------
LC536:
        ora     SCRATCH_08                             ; C536 05 08                    ..
LC538:
        sta     DATA_BUFFER_0180,x                         ; C538 9D 80 01                 ...
        inx                                     ; C53B E8                       .
        dey                                     ; C53C 88                       .
        bne     STEP_PALETTE_FADE_LC520                           ; C53D D0 E1                    ..
        rts                                     ; C53F 60                       `

; ----------------------------------------------------------------------------
; alternates between cleared palette and normal palette several times for flashing effect
; input - x=# of loops
FLASH_EFFECT_C540:
        ; save x on stack
		txa                                     ; C540 8A                       .
        pha                                     ; C541 48                       H
        lda     #$30                            ; C542 A9 30                    .0
        ldx     #$1F                            ; C544 A2 1F                    ..
LC546:
		; loop and set 32 bytes on the stack to x30
        sta     DATA_BUFFER_0180,x                         ; C546 9D 80 01                 ...
        dex                                     ; C549 CA                       .
        bpl     LC546                           ; C54A 10 FA                    ..
        
		; update palette and wait 1 frame
		jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; C54C 20 69 C5                  i.
        lda     #$01                            ; C54F A9 01                    ..
        sta     NMI_WAIT_CTR                             ; C551 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C553 20 35 C1                  5.
        jsr     SET_PLAYER_AND_MAP_PALETTES                           ; C556 20 FB C9                  ..
        
		; update palette and wait 2 frames
		jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; C559 20 69 C5                  i.
        lda     #$02                            ; C55C A9 02                    ..
        sta     NMI_WAIT_CTR                             ; C55E 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; C560 20 35 C1                  5.
        pla                                     ; C563 68                       h
        tax                                     ; C564 AA                       .
        dex                                     ; C565 CA                       .
        bne     FLASH_EFFECT_C540                           ; C566 D0 D8                    ..
        rts                                     ; C568 60                       `

; ----------------------------------------------------------------------------
; sets PPU to read from $3f00 (palette) and executes routine 2 (update palette from buffer)
NMI_UPDATE_PALETTE_FROM_BUFFER:
        jsr     WAIT_FOR_NEXT_NMI_ROUTINE_CLEAR                           ; C569 20 97 CC                  c57a..
        lda     #$00                            ; C56C A9 00                    ..
        sta     PPU_WRITE_LO                             ; C56E 85 16                    ..
        lda     #$3F                            ; C570 A9 3F                    .?
        sta     PPU_WRITE_HI                             ; C572 85 17                    ..
        lda     #$02                            ; C574 A9 02                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; C576 20 8F CC                  ..
        rts                                     ; C579 60                       `

; ----------------------------------------------------------------------------

; status bar graphics prepped by loading nametable from a table and clearing bg palettes
LOAD_STATUS_BAR_GRAPHICS: ;$c57a
        jsr     WAIT_FOR_NEXT_NMI_ROUTINE_CLEAR                           ; C57A 20 97 CC                  ..
        lda     PPU_CTRL_COPY                             ; C57D A5 23                    .#
        pha                                     ; C57F 48                       H
        
		; disable NMI, horizontal VRAM advancement
		and     #$7B                            ; C580 29 7B                    ){
        sta     PPU_CTRL                           ; C582 8D 00 20                 .. 
        lda     #$00                            ; C585 A9 00                    ..
        sta     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; C587 85 29                    .)
        
		; disable sprite/bg rendering
		lda     PPU_MASK_COPY                             ; C589 A5 24                    .$
        pha                                     ; C58B 48                       H
        and     #$E7                            ; C58C 29 E7                    ).
        sta     PPU_MASK                           ; C58E 8D 01 20                 .. 
        
		; writing to $2320 - end of nametable 0, writing 160 bytes from TBL_STATUS_BAR_NAMES
		lda     #$23                            ; C591 A9 23                    .#
        sta     PPU_ADDRESS                           ; C593 8D 06 20                 .. 
        lda     #$20                            ; C596 A9 20                    . 
        sta     PPU_ADDRESS                           ; C598 8D 06 20                 .. 
        ldy     #$A0                            ; C59B A0 A0                    ..
        ldx     #$00                            ; C59D A2 00                    ..
LC59F:
        lda     TBL_STATUS_BAR_NAMES,x                         ; C59F BD CB FE                 ...
        sta     PPU_DATA_RW                           ; C5A2 8D 07 20                 .. 
        inx                                     ; C5A5 E8                       .
        dey                                     ; C5A6 88                       .
        bne     LC59F                           ; C5A7 D0 F6                    ..
        
		; now write to $23f0 - 16 bytes of x00
		; bottom of attribute table 0 (affects bg palette for the status bar)
		lda     #$23                            ; C5A9 A9 23                    .#
        sta     PPU_ADDRESS                           ; C5AB 8D 06 20                 .. 
        lda     #$F0                            ; C5AE A9 F0                    ..
        sta     PPU_ADDRESS                           ; C5B0 8D 06 20                 .. 
        ldy     #$10                            ; C5B3 A0 10                    ..
        lda     #$00                            ; C5B5 A9 00                    ..
LC5B7:
        sta     PPU_DATA_RW                           ; C5B7 8D 07 20                 .. 
        dey                                     ; C5BA 88                       .
        bne     LC5B7                           ; C5BB D0 FA                    ..
        lda     #$01                            ; C5BD A9 01                    ..
        
		; flag to update the status bar later
		inc     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; C5BF E6 29                    .)
        pla                                     ; C5C1 68                       h
        sta     PPU_MASK_COPY                             ; C5C2 85 24                    .$
        pla                                     ; C5C4 68                       h
        sta     PPU_CTRL_COPY                             ; C5C5 85 23                    .#
        sta     PPU_CTRL                           ; C5C7 8D 00 20                 .. 
        rts                                     ; C5CA 60                       `

; ----------------------------------------------------------------------------
; write the name/attr tables for a map level
LOAD_GRAPHICS_FOR_MAP_LEVEL: ; $c5cb
        ; force even value of SCROLL_X_HI --> LO pointer
		lda     SCROLL_X_HI                             ; C5CB A5 7C                    .|
        and     #$FE                            ; C5CD 29 FE                    ).
        sta     PLAYER_MAP_TILE_LO                           ; C5CF 85 0C                    ..
        
		; high pointer on zero page
		lda     #$00                            ; C5D1 A9 00                    ..
        sta     PLAYER_MAP_TILE_HI                             ; C5D3 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; C5D5 20 54 CA                  T.
        jsr     PPU_WRITE_NAMES_AND_ATTR                           ; C5D8 20 F7 C5                  ..
        rts                                     ; C5DB 60                       `

; ----------------------------------------------------------------------------
; write the name/attr tables for shop or inn graphics
LOAD_GRAPHICS_SHOP_INN:
        lda     SCROLL_X_HI                             ; C5DC A5 7C                    .|
        and     #$FE                            ; C5DE 29 FE                    ).
        sta     PLAYER_MAP_TILE_LO                           ; C5E0 85 0C                    ..
        lda     #$00                            ; C5E2 A9 00                    ..
        sta     PLAYER_MAP_TILE_HI                             ; C5E4 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; C5E6 20 54 CA                  T.
        
		; convert the RAM location of TILE_HI (starting at $05) to the relevant location on the ROM
		; this is b/c shop/inn tiles are never buffered into the CUR_MAP_TILES_START RAM like they are for normal maps
		; see CALC_MAP_POINTERS
		lda     PLAYER_MAP_TILE_HI                             ; C5E9 A5 0D                    ..
        sec                                     ; C5EB 38                       8
        sbc     #$05                            ; C5EC E9 05                    ..
        clc                                     ; C5EE 18                       .
        adc     ROM_MAP_START_HI                             ; C5EF 65 76                    ev
        sta     PLAYER_MAP_TILE_HI                             ; C5F1 85 0D                    ..
        jsr     PPU_WRITE_NAMES_AND_ATTR                           ; C5F3 20 F7 C5                  ..
        rts                                     ; C5F6 60                       `

; ----------------------------------------------------------------------------
; the dirty work of writing all our map's graphics to the PPU; handles both map/dungeon levels and shop/inn
; first write 16 columns of 12 tiles (4 names/tile) to nametable (a screen's worth)
; then write attribute table
; note the bottom of the nametable/attr table isn't written here - that's where the status bar graphics are kept 
; see https://www.nesdev.org/wiki/PPU_nametables
PPU_WRITE_NAMES_AND_ATTR:
		; various PPU values loaded here and saved on stack
		; disable nmi, vertical VRAM advancement
        lda     PPU_CTRL_COPY                             ; C5F7 A5 23                    .#
        pha                                     ; C5F9 48                       H
        and     #$7F                            ; C5FA 29 7F                    ).
        ora     #$04                            ; C5FC 09 04                    ..
        sta     PPU_CTRL                           ; C5FE 8D 00 20                 .. 
        
		; push the flag and clear it
		lda     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; C601 A5 29                    .)
        pha                                     ; C603 48                       H
        lda     #$00                            ; C604 A9 00                    ..
        sta     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; C606 85 29                    .)
        
		; push the existing mask and clear bits 3-4 (disable sprite/bg rendering)
		lda     PPU_MASK_COPY                             ; C608 A5 24                    .$
        pha                                     ; C60A 48                       H
        and     #$E7                            ; C60B 29 E7                    ).
        sta     PPU_MASK                           ; C60D 8D 01 20                 .. 
        
		; remember our tile ptr
		lda     PLAYER_MAP_TILE_LO                           ; C610 A5 0C                    ..
        pha                                     ; C612 48                       H
        lda     PLAYER_MAP_TILE_HI                             ; C613 A5 0D                    ..
        pha                                     ; C615 48                       H
        
		; calc PPU write addresses from scroll
		; will be $2000 if SCROLL_X_HI = 0 (top/left of nametable 0)
		lda     SCROLL_X_HI                             ; C616 A5 7C                    .|
        asl     a                               ; C618 0A                       .
        and     #$1C                            ; C619 29 1C                    ).
        sta     PPU_WRITE_LO                             ; C61B 85 16                    ..
        lda     SCROLL_X_HI                             ; C61D A5 7C                    .|
        and     #$10                            ; C61F 29 10                    ).
        lsr     a                               ; C621 4A                       J
        lsr     a                               ; C622 4A                       J
        sta     PPU_WRITE_HI                             ; C623 85 17                    ..
        
		; base address is $2000 - any values above added to it
		clc                                     ; C625 18                       .
        lda     #$00                            ; C626 A9 00                    ..
        adc     PPU_WRITE_LO                             ; C628 65 16                    e.
        sta     PPU_WRITE_LO                             ; C62A 85 16                    ..
        lda     #$20                            ; C62C A9 20                    . 
        adc     PPU_WRITE_HI                             ; C62E 65 17                    e.
        sta     PPU_WRITE_HI                             ; C630 85 17                    ..
        
		; 18 loops on x0A - each column of tile data
		lda     #$12                            ; C632 A9 12                    ..
        sta     LOOP_COUNTER_0A                             ; C634 85 0A                    ..
LC636:
		; 12 loops on inner counter SCRATCH_0B - each tile within a column
        lda     #$0C                            ; C636 A9 0C                    ..
        sta     SCRATCH_0B                             ; C638 85 0B                    ..
        
		; config PPU for write address
		lda     PPU_WRITE_HI                             ; C63A A5 17                    ..
        sta     PPU_ADDRESS                           ; C63C 8D 06 20                 .. 
        lda     PPU_WRITE_LO                             ; C63F A5 16                    ..
        sta     PPU_ADDRESS                           ; C641 8D 06 20                 .. 
        
		; SCRATCH_08 = used to track offset in y
		ldy     #$00                            ; C644 A0 00                    ..
        sty     SCRATCH_08                             ; C646 84 08                    ..
LC648:
        ; load the tile id, mult by 4 for index into TILE_DEFS_LO
		ldy     SCRATCH_08                             ; C648 A4 08                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; C64A B1 0C                    ..
        asl     a                               ; C64C 0A                       .
        asl     a                               ; C64D 0A                       .
        tay                                     ; C64E A8                       .
        
		; load 2 names and write them vertically to the nametable
		lda     (TILE_DEFS_LO),y                         ; C64F B1 79                    .y
        sta     PPU_DATA_RW                           ; C651 8D 07 20                 .. 
        iny                                     ; C654 C8                       .
        lda     (TILE_DEFS_LO),y                         ; C655 B1 79                    .y
        sta     PPU_DATA_RW                           ; C657 8D 07 20                 .. 
        
		; update offset and loop counters; loop if SCRATCH_0B <> 0
		inc     SCRATCH_08                             ; C65A E6 08                    ..
        dec     SCRATCH_0B                             ; C65C C6 0B                    ..
        bne     LC648                           ; C65E D0 E8                    ..
        
		; outer loop continues; update PPU_ADDRESS and ready a x0B as counter for another inner loop
		lda     #$0C                            ; C660 A9 0C                    ..
        sta     SCRATCH_0B                             ; C662 85 0B                    ..
        lda     PPU_WRITE_HI                             ; C664 A5 17                    ..
        sta     PPU_ADDRESS                           ; C666 8D 06 20                 .. 
        ldy     PPU_WRITE_LO                             ; C669 A4 16                    ..
        iny                                     ; C66B C8                       .
        sty     PPU_ADDRESS                           ; C66C 8C 06 20                 .. 
        ldy     #$00                            ; C66F A0 00                    ..
        sty     SCRATCH_08                             ; C671 84 08                    ..
LC673:
        ; similar to above, but this time we inc the y offset to TILE_DEFS_LO by 2
		; to get the names for the right side of each tile
		ldy     SCRATCH_08                             ; C673 A4 08                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; C675 B1 0C                    ..
        asl     a                               ; C677 0A                       .
        asl     a                               ; C678 0A                       .
        tay                                     ; C679 A8                       .
        iny                                     ; C67A C8                       .
        iny                                     ; C67B C8                       .
        lda     (TILE_DEFS_LO),y                         ; C67C B1 79                    .y
        sta     PPU_DATA_RW                           ; C67E 8D 07 20                 .. 
        iny                                     ; C681 C8                       .
        lda     (TILE_DEFS_LO),y                         ; C682 B1 79                    .y
        sta     PPU_DATA_RW                           ; C684 8D 07 20                 .. 
        
		; update offset and loop counters; loop if SCRATCH_0B <> 0
		inc     SCRATCH_08                             ; C687 E6 08                    ..
        dec     SCRATCH_0B                             ; C689 C6 0B                    ..
        bne     LC673                           ; C68B D0 E6                    ..
        
		; outer loop continues; we've now written 48 names, or a column of 12 2x2 tiles
		; advance LO address, branch if bit 5=0
		inc     PPU_WRITE_LO                             ; C68D E6 16                    ..
        inc     PPU_WRITE_LO                             ; C68F E6 16                    ..
        lda     PPU_WRITE_LO                             ; C691 A5 16                    ..
        and     #$20                            ; C693 29 20                    ) 
        beq     LC6A1                           ; C695 F0 0A                    ..
        
		; else if bit 5 <> 0 we reset LO and flip HI bit 2, swapping nametables between $20xx and $24xx
		lda     #$00                            ; C697 A9 00                    ..
        sta     PPU_WRITE_LO                             ; C699 85 16                    ..
        lda     PPU_WRITE_HI                             ; C69B A5 17                    ..
        eor     #$04                            ; C69D 49 04                    I.
        sta     PPU_WRITE_HI                             ; C69F 85 17                    ..
LC6A1:
        ; advance tile ptr to the top of the next column
		clc                                     ; C6A1 18                       .
        lda     #$0C                            ; C6A2 A9 0C                    ..
        adc     PLAYER_MAP_TILE_LO                           ; C6A4 65 0C                    e.
        sta     PLAYER_MAP_TILE_LO                           ; C6A6 85 0C                    ..
        lda     #$00                            ; C6A8 A9 00                    ..
        adc     PLAYER_MAP_TILE_HI                             ; C6AA 65 0D                    e.
        sta     PLAYER_MAP_TILE_HI                             ; C6AC 85 0D                    ..
        
		; loop if outer loop ctr <> 0
		dec     LOOP_COUNTER_0A                             ; C6AE C6 0A                    ..
        bne     LC636                           ; C6B0 D0 84                    ..
        
		; outer loop is done, restore the prior tile ptr's
		pla                                     ; C6B2 68                       h
        sta     PLAYER_MAP_TILE_HI                             ; C6B3 85 0D                    ..
        pla                                     ; C6B5 68                       h
        sta     PLAYER_MAP_TILE_LO                           ; C6B6 85 0C                    ..
        
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Now we write the attribute table
		; value = (bottomright << 6) | (bottomleft << 4) | (topright << 2) | (topleft << 0)
		; see https://www.nesdev.org/wiki/PPU_attribute_tables
		; offset into attr table based on SCROLL_X_HI
		lda     SCROLL_X_HI                             ; C6B8 A5 7C                    .|
        lsr     a                               ; C6BA 4A                       J
        and     #$07                            ; C6BB 29 07                    ).
        sta     PPU_WRITE_LO                             ; C6BD 85 16                    ..
        lda     SCROLL_X_HI                             ; C6BF A5 7C                    .|
        and     #$10                            ; C6C1 29 10                    ).
        lsr     a                               ; C6C3 4A                       J
        lsr     a                               ; C6C4 4A                       J
        sta     PPU_WRITE_HI                             ; C6C5 85 17                    ..
        
		; base address: $23c0 (attr table 0 is $23c0-ff, 64 bytes)
		clc                                     ; C6C7 18                       .
        lda     #$C0                            ; C6C8 A9 C0                    ..
        adc     PPU_WRITE_LO                             ; C6CA 65 16                    e.
        sta     PPU_WRITE_LO                             ; C6CC 85 16                    ..
        lda     #$23                            ; C6CE A9 23                    .#
        adc     PPU_WRITE_HI                             ; C6D0 65 17                    e.
        sta     PPU_WRITE_HI                             ; C6D2 85 17                    ..

; new outer loop on LOOP_COUNTER_0A (8 loops) - each loop is a column of attr values, 2x6 bytes for a 4x12 column of tiles
; note the bottom of the nametable/attr table isn't written here - that's where the status bar graphics are kept 
        lda     #$09                            ; C6D4 A9 09                    ..
        sta     LOOP_COUNTER_0A                             ; C6D6 85 0A                    ..
LC6D8:

; new inner loop on x  (6 loops) - 6 bytes covering a 2x2 square of tiles
        ldx     #$06                            ; C6D8 A2 06                    ..
LC6DA:
		; rotate the attribute data into SCRATCH_08 - top 2 bits of each tile
		; get rotated (via carry) into the bottom 2 bits of SCRATCH_08
		; when we're done we have a byte with 2 bits for each tile at offsets y=x0D, x01, x0C, x00
		; so 2x2
        ldy     #$0D                            ; C6DA A0 0D                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; C6DC B1 0C                    ..
        rol     a                               ; C6DE 2A                       *
        rol     SCRATCH_08                             ; C6DF 26 08                    &.
        rol     a                               ; C6E1 2A                       *
        rol     SCRATCH_08                             ; C6E2 26 08                    &.
        ldy     #$01                            ; C6E4 A0 01                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; C6E6 B1 0C                    ..
        rol     a                               ; C6E8 2A                       *
        rol     SCRATCH_08                             ; C6E9 26 08                    &.
        rol     a                               ; C6EB 2A                       *
        rol     SCRATCH_08                             ; C6EC 26 08                    &.
        ldy     #$0C                            ; C6EE A0 0C                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; C6F0 B1 0C                    ..
        rol     a                               ; C6F2 2A                       *
        rol     SCRATCH_08                             ; C6F3 26 08                    &.
        rol     a                               ; C6F5 2A                       *
        rol     SCRATCH_08                             ; C6F6 26 08                    &.
        ldy     #$00                            ; C6F8 A0 00                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; C6FA B1 0C                    ..
        rol     a                               ; C6FC 2A                       *
        rol     SCRATCH_08                             ; C6FD 26 08                    &.
        rol     a                               ; C6FF 2A                       *
        rol     SCRATCH_08                             ; C700 26 08                    &.
        
		; write the attribute
		lda     PPU_WRITE_HI                             ; C702 A5 17                    ..
        sta     PPU_ADDRESS                           ; C704 8D 06 20                 .. 
        lda     PPU_WRITE_LO                             ; C707 A5 16                    ..
        sta     PPU_ADDRESS                           ; C709 8D 06 20                 .. 
        lda     SCRATCH_08                             ; C70C A5 08                    ..
        sta     PPU_DATA_RW                           ; C70E 8D 07 20                 .. 
        
		; advance the tile ptr
		clc                                     ; C711 18                       .
        lda     #$02                            ; C712 A9 02                    ..
        adc     PLAYER_MAP_TILE_LO                           ; C714 65 0C                    e.
        sta     PLAYER_MAP_TILE_LO                           ; C716 85 0C                    ..
        lda     #$00                            ; C718 A9 00                    ..
        adc     PLAYER_MAP_TILE_HI                             ; C71A 65 0D                    e.
        sta     PLAYER_MAP_TILE_HI                             ; C71C 85 0D                    ..
        
		; advance the PPU write addr
		clc                                     ; C71E 18                       .
        lda     #$08                            ; C71F A9 08                    ..
        adc     PPU_WRITE_LO                             ; C721 65 16                    e.
        sta     PPU_WRITE_LO                             ; C723 85 16                    ..
        lda     #$00                            ; C725 A9 00                    ..
        adc     PPU_WRITE_HI                             ; C727 65 17                    e.
        sta     PPU_WRITE_HI                             ; C729 85 17                    ..
        
		; dec and loop
		dex                                     ; C72B CA                       .
        bne     LC6DA                           ; C72C D0 AC                    ..
        
		; outer loop continues; advance tile ptr's to next column
		clc                                     ; C72E 18                       .
        lda     #$0C                            ; C72F A9 0C                    ..
        adc     PLAYER_MAP_TILE_LO                           ; C731 65 0C                    e.
        sta     PLAYER_MAP_TILE_LO                           ; C733 85 0C                    ..
        lda     #$00                            ; C735 A9 00                    ..
        adc     PLAYER_MAP_TILE_HI                             ; C737 65 0D                    e.
        sta     PLAYER_MAP_TILE_HI                             ; C739 85 0D                    ..
        
		; advance ppu addr 
		clc                                     ; C73B 18                       .
        lda     #$D1                            ; C73C A9 D1                    ..
        adc     PPU_WRITE_LO                             ; C73E 65 16                    e.
        sta     PPU_WRITE_LO                             ; C740 85 16                    ..
        lda     #$FF                            ; C742 A9 FF                    ..
        adc     PPU_WRITE_HI                             ; C744 65 17                    e.
        sta     PPU_WRITE_HI                             ; C746 85 17                    ..
        
		; branch if LO bit 3 clear
		lda     PPU_WRITE_LO                             ; C748 A5 16                    ..
        and     #$08                            ; C74A 29 08                    ).
        beq     LC758                           ; C74C F0 0A                    ..
        
		; otherwise, LO --> xC0 and toggle nametable ($2000 <--> $2400)
		lda     #$C0                            ; C74E A9 C0                    ..
        sta     PPU_WRITE_LO                             ; C750 85 16                    ..
        lda     PPU_WRITE_HI                             ; C752 A5 17                    ..
        eor     #$04                            ; C754 49 04                    I.
        sta     PPU_WRITE_HI                             ; C756 85 17                    ..
LC758:
		; loop while LOOP_COUNTER_0A > 0
        dec     LOOP_COUNTER_0A                             ; C758 C6 0A                    ..
		beq     RESTORE_PPU_VALUES_FROM_STACK                           ; C75A F0 03                    ..
        jmp     LC6D8                           ; C75C 4C D8 C6                 L..

; ----------------------------------------------------------------------------
RESTORE_PPU_VALUES_FROM_STACK:
        pla                                     ; C75F 68                       h
        sta     PPU_MASK_COPY                             ; C760 85 24                    .$
        pla                                     ; C762 68                       h
        sta     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; C763 85 29                    .)
        pla                                     ; C765 68                       h
        sta     PPU_CTRL_COPY                             ; C766 85 23                    .#
        sta     PPU_CTRL                           ; C768 8D 00 20                 .. 
        rts                                     ; C76B 60                       `

; ----------------------------------------------------------------------------
; waits for an nmi then updates PPU
UPDATE_PPU_ADDRESS_FROM_SCROLL: ; $c76c
        jsr     WAIT_FOR_NEXT_NMI_ROUTINE_CLEAR                           ; C76C 20 97 CC                  ..
        
		; convert SCROLL_X_HI to PPU addresses
		lda     SCROLL_X_HI                             ; C76F A5 7C                    .|
        asl     a                               ; C771 0A                       .
        and     #$1F                            ; C772 29 1F                    ).
        sta     PPU_WRITE_LO                             ; C774 85 16                    ..
        lda     SCROLL_X_HI                             ; C776 A5 7C                    .|
        and     #$10                            ; C778 29 10                    ).
        lsr     a                               ; C77A 4A                       J
        lsr     a                               ; C77B 4A                       J
        sta     PPU_WRITE_HI                             ; C77C 85 17                    ..
        
		; no idea why we do this?
		clc                                     ; C77E 18                       .
        lda     #$00                            ; C77F A9 00                    ..
        adc     PPU_WRITE_LO                             ; C781 65 16                    e.
        sta     PPU_WRITE_LO                             ; C783 85 16                    ..
        
		; advance PPU_WRITE_HI by x20 (1 column) - load the next bit of map
		lda     #$20                            ; C785 A9 20                    . 
        adc     PPU_WRITE_HI                             ; C787 65 17                    e.
        sta     PPU_WRITE_HI                             ; C789 85 17                    ..
        
		; SCRATCH_08 tracks the tile we're on
		lda     SCROLL_X_HI                             ; C78B A5 7C                    .|
        sta     SCRATCH_08                             ; C78D 85 08                    ..
        
		; set loop counter
		lda     #$10                            ; C78F A9 10                    ..
        sta     SCRATCH_09                             ; C791 85 09                    ..
LC793:
        ; load the graphics for this tile
		lda     SCRATCH_08                             ; C793 A5 08                    ..
        sta     PLAYER_MAP_TILE_LO                           ; C795 85 0C                    ..
        jsr     UPDATE_MAP_DATA_FROM_SCROLL                           ; C797 20 33 C8                  3.
        
		; advance to next tile
		inc     PPU_WRITE_LO                             ; C79A E6 16                    ..
        inc     PPU_WRITE_LO                             ; C79C E6 16                    ..
        lda     PPU_WRITE_LO                             ; C79E A5 16                    ..
        and     #$20                            ; C7A0 29 20                    ) 
        
		; branch  if PPU_WRITE_LO < x20
		beq     LC7AE                           ; C7A2 F0 0A                    ..
        
		; else, clear LO address, flip bit 2 on HI
		lda     #$00                            ; C7A4 A9 00                    ..
        sta     PPU_WRITE_LO                             ; C7A6 85 16                    ..
        lda     PPU_WRITE_HI                             ; C7A8 A5 17                    ..
        eor     #$04                            ; C7AA 49 04                    I.
        sta     PPU_WRITE_HI                             ; C7AC 85 17                    ..
LC7AE:
		; advance to next tile for UPDATE_MAP_DATA_FROM_SCROLL
		inc     SCRATCH_08                             ; C7AE E6 08                    ..
        
		; loop until SCRATCH_09 = 0 (16 loops)
		dec     SCRATCH_09                             ; C7B0 C6 09                    ..
		bne     LC793                           ; C7B2 D0 DF                    ..
        rts                                     ; C7B4 60                       `

; ----------------------------------------------------------------------------
; 
PREP_PASSWORD_SCREEN:
        jsr     WAIT_FOR_NEXT_NMI_ROUTINE_CLEAR                           ; C7B5 20 97 CC                  ..
        
		; convert SCROLL_X_HI to PPU addresses
		; HI bottom nibble * 2 --> LO
		; HI bit 4 manipulated such that HI will be 0 or 4, pointing to $2000 or $2400 or which nametable to point to
		lda     SCROLL_X_HI                             ; C7B8 A5 7C                    .|
        asl     a                               ; C7BA 0A                       .
        and     #$1F                            ; C7BB 29 1F                    ).
        sta     PPU_WRITE_LO                             ; C7BD 85 16                    ..
        lda     SCROLL_X_HI                             ; C7BF A5 7C                    .|
        and     #$10                            ; C7C1 29 10                    ).
        lsr     a                               ; C7C3 4A                       J
        lsr     a                               ; C7C4 4A                       J
        sta     PPU_WRITE_HI                             ; C7C5 85 17                    ..
        
		; offsets above added to base PPU address of $2000
		; think they add PPU_WRITE_LO to x00 just for consistency or flexibility if they wanted
		; the base value to be non-zero later. It shouldn't affect the outcome
		clc                                     ; C7C7 18                       .
        lda     #$00                            ; C7C8 A9 00                    ..
        adc     PPU_WRITE_LO                             ; C7CA 65 16                    e.
        sta     PPU_WRITE_LO                             ; C7CC 85 16                    ..
        lda     #$20                            ; C7CE A9 20                    . 
        adc     PPU_WRITE_HI                             ; C7D0 65 17                    e.
        sta     PPU_WRITE_HI                             ; C7D2 85 17                    ..
        
		; SCROLL_X_HI --> SCRATCH_08
		lda     SCROLL_X_HI                             ; C7D4 A5 7C                    .|
        sta     SCRATCH_08                             ; C7D6 85 08                    ..
        lda     #$10                            ; C7D8 A9 10                    ..
        sta     SCRATCH_09                             ; C7DA 85 09                    ..
LC7DC:
		; 16 loops; until SCRATCH_09 = 0
        lda     SCRATCH_08                             ; C7DC A5 08                    ..
        sta     PLAYER_MAP_TILE_LO                           ; C7DE 85 0C                    ..
        jsr     LOAD_COLUMN_MAP_GRAPHICS_FROM_ROM                           ; C7E0 20 5C C8                  \.
        inc     PPU_WRITE_LO                             ; C7E3 E6 16                    ..
        inc     PPU_WRITE_LO                             ; C7E5 E6 16                    ..
        lda     PPU_WRITE_LO                             ; C7E7 A5 16                    ..
        and     #$20                            ; C7E9 29 20                    ) 
        beq     LC7F7                           ; C7EB F0 0A                    ..
        lda     #$00                            ; C7ED A9 00                    ..
        sta     PPU_WRITE_LO                             ; C7EF 85 16                    ..
        lda     PPU_WRITE_HI                             ; C7F1 A5 17                    ..
        eor     #$04                            ; C7F3 49 04                    I.
        sta     PPU_WRITE_HI                             ; C7F5 85 17                    ..
LC7F7:
        inc     SCRATCH_08                             ; C7F7 E6 08                    ..
        dec     SCRATCH_09                             ; C7F9 C6 09                    ..
        
		; loop while SCRATCH_09 <> 0 
		bne     LC7DC                           ; C7FB D0 DF                    ..
        rts                                     ; C7FD 60                       `

; ----------------------------------------------------------------------------
UPDATE_PPU_FOR_X_SCROLL:
        jsr     WAIT_FOR_NEXT_NMI_ROUTINE_CLEAR                           ; C7FE 20 97 CC                  ..
        
		; branch if scrolling left
		lda     SCROLL_X_DIR                             ; C801 A5 7F                    ..
        bmi     LC80F                           ; C803 30 0A                    0.
        
		; scrolling right - add x10 to ptr
		lda     SCROLL_X_HI                             ; C805 A5 7C                    .|
        clc                                     ; C807 18                       .
        adc     #$10                            ; C808 69 10                    i.
        sta     PLAYER_MAP_TILE_LO                           ; C80A 85 0C                    ..
        jmp     LC813                           ; C80C 4C 13 C8                 L..

; ----------------------------------------------------------------------------
LC80F:
        lda     SCROLL_X_HI                             ; C80F A5 7C                    .|
        sta     PLAYER_MAP_TILE_LO                           ; C811 85 0C                    ..
LC813:
        ; lower nibble of LO * 2 --> PPU_WRITE_LO
		; bit 4 of LO determines which nametable to point to, base value HI of x04 or x00
		lda     PLAYER_MAP_TILE_LO                           ; C813 A5 0C                    ..
        asl     a                               ; C815 0A                       .
        and     #$1F                            ; C816 29 1F                    ).
        sta     PPU_WRITE_LO                             ; C818 85 16                    ..
        lda     PLAYER_MAP_TILE_LO                           ; C81A A5 0C                    ..
        and     #$10                            ; C81C 29 10                    ).
        lsr     a                               ; C81E 4A                       J
        lsr     a                               ; C81F 4A                       J
        sta     PPU_WRITE_HI                             ; C820 85 17                    ..
        
		; add offsets above to $2000 base
		clc                                     ; C822 18                       .
        lda     #$00                            ; C823 A9 00                    ..
        adc     PPU_WRITE_LO                             ; C825 65 16                    e.
        sta     PPU_WRITE_LO                             ; C827 85 16                    ..
        lda     #$20                            ; C829 A9 20                    . 
        adc     PPU_WRITE_HI                             ; C82B 65 17                    e.
        sta     PPU_WRITE_HI                             ; C82D 85 17                    ..
        jsr     UPDATE_MAP_DATA_FROM_SCROLL                           ; C82F 20 33 C8                  3.
        rts                                     ; C832 60                       `

; ----------------------------------------------------------------------------

; loads graphics for 1 column of tiles
; input - PLAYER_MAP_TILE_LO = location of interest
UPDATE_MAP_DATA_FROM_SCROLL:
        ; save the upper swappable bank on stack, swap to bank 9, where tile defs are stored
		lda     PRG_BANK_A000                             ; C833 A5 31                    .1
        pha                                     ; C835 48                       H
        lda     #$07                            ; C836 A9 07                    ..
        sta     LAST_BANK_UPDATED                             ; C838 85 25                    .%
        sta     MAPPER_BANK_SELECT                           ; C83A 8D 00 80                 ...
        lda     #$09                            ; C83D A9 09                    ..
        sta     PRG_BANK_A000                             ; C83F 85 31                    .1
        sta     MAPPER_BANK_VALUE                           ; C841 8D 01 80                 ...
        
		; update 
		lda     #$00                            ; C844 A9 00                    ..
        sta     PLAYER_MAP_TILE_HI                             ; C846 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; C848 20 54 CA                  T.
        jsr     LOAD_COLUMN_MAP_GRAPHICS                           ; C84B 20 71 C8                  q.
       
		; restore the former bank
	    lda     #$07                            ; C84E A9 07                    ..
        sta     LAST_BANK_UPDATED                             ; C850 85 25                    .%
        sta     MAPPER_BANK_SELECT                           ; C852 8D 00 80                 ...
        pla                                     ; C855 68                       h
        sta     PRG_BANK_A000                             ; C856 85 31                    .1
        sta     MAPPER_BANK_VALUE                           ; C858 8D 01 80                 ...
        rts                                     ; C85B 60                       `

; ----------------------------------------------------------------------------
; Loads a column of map graphics from the ROM, rather than the RAM tiles. This is only
; called to restore the home's original graphics when clearing the password screen.
; input - PLAYER_MAP_TILE_LO = location of interest
LOAD_COLUMN_MAP_GRAPHICS_FROM_ROM:
        lda     #$00                            ; C85C A9 00                    ..
        sta     PLAYER_MAP_TILE_HI                             ; C85E 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; C860 20 54 CA                  T.
        
		; convert tile RAM (CUR_MAP_TILES_START) address to equivalent ROM address (see CALC_MAP_POINTERS)
		lda     PLAYER_MAP_TILE_HI                             ; C863 A5 0D                    ..
        sec                                     ; C865 38                       8
        sbc     #$05                            ; C866 E9 05                    ..
        clc                                     ; C868 18                       .
        adc     ROM_MAP_START_HI                             ; C869 65 76                    ev
        sta     PLAYER_MAP_TILE_HI                             ; C86B 85 0D                    ..
        jsr     LOAD_COLUMN_MAP_GRAPHICS                           ; C86D 20 71 C8                  q.
        rts                                     ; C870 60                       `

; ----------------------------------------------------------------------------
; Loads graphics for a column of map tiles into the name/attr tables
; input - PLAYER_MAP_TILE_PTR = location of interest
LOAD_COLUMN_MAP_GRAPHICS:
        ; SCRATCH_0B is the # tile we're on, starting at 0
		; x is the offset to the write buffers for our pattern id's
		lda     #$00                            ; C871 A9 00                    ..
        sta     SCRATCH_0B                             ; C873 85 0B                    ..
        ldx     #$16                            ; C875 A2 16                    ..
LC877:
        ; read the tile ID for this location
		ldy     SCRATCH_0B                             ; C877 A4 0B                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; C879 B1 0C                    ..
        asl     a                               ; C87B 0A                       .
        asl     a                               ; C87C 0A                       .
        tay                                     ; C87D A8                       .
        
		; loops 12 times to copy pairs of bytes to SCROLL_NAME_BUFFER_LEFT_COL-157 and SCROLL_NAME_BUFFER_RIGHT_COL-16f; buffering
		; the patterns for each tile
		; bottom/left
		lda     (TILE_DEFS_LO),y                         ; C87E B1 79                    .y
        sta     SCROLL_NAME_BUFFER_LEFT_COL+1,x                         ; C880 9D 41 01                 .A.
        iny                                     ; C883 C8                       .
        ; top/left
		lda     (TILE_DEFS_LO),y                         ; C884 B1 79                    .y
        sta     SCROLL_NAME_BUFFER_LEFT_COL,x                         ; C886 9D 40 01                 .@.
        iny                                     ; C889 C8                       .
        ; bottom/right
		lda     (TILE_DEFS_LO),y                         ; C88A B1 79                    .y
        sta     SCROLL_NAME_BUFFER_RIGHT_COL+1,x                         ; C88C 9D 59 01                 .Y.
        iny                                     ; C88F C8                       .
        ; top right
		lda     (TILE_DEFS_LO),y                         ; C890 B1 79                    .y
        sta     SCROLL_NAME_BUFFER_RIGHT_COL,x                         ; C892 9D 58 01                 .X.
        
		; advance to next tile (y) and write buffer offset (x)
		inc     SCRATCH_0B                             ; C895 E6 0B                    ..
        dex                                     ; C897 CA                       .
        dex                                     ; C898 CA                       .
        
		; loop while x >= 0
		bpl     LC877                           ; C899 10 DC                    ..
        
		; TILE_PPU_WRITE_HI = PPU_WRITE_HI + 3
		lda     PPU_WRITE_HI                             ; C89B A5 17                    ..
        clc                                     ; C89D 18                       .
        adc     #$03                            ; C89E 69 03                    i.
        sta     TILE_PPU_WRITE_HI                             ; C8A0 85 19                    ..
        
		; SCRATCH_0B = PPU_WRITE_LO / 4 + xC0
		lda     PPU_WRITE_LO                             ; C8A2 A5 16                    ..
        lsr     a                               ; C8A4 4A                       J
        lsr     a                               ; C8A5 4A                       J
        clc                                     ; C8A6 18                       .
        adc     #$C0                            ; C8A7 69 C0                    i.
        sta     SCRATCH_0B                             ; C8A9 85 0B                    ..
        
		; alternate x values between x33 and xCC 
		ldx     #$33                            ; C8AB A2 33                    .3
        lda     PPU_WRITE_LO                             ; C8AD A5 16                    ..
        and     #$02                            ; C8AF 29 02                    ).
        bne     LC8B5                           ; C8B1 D0 02                    ..
        ldx     #$CC                            ; C8B3 A2 CC                    ..
LC8B5:
        stx     TILE_PPU_WRITE_LO                             ; C8B5 86 18                    ..
        ldy     #$00                            ; C8B7 A0 00                    ..

		; now we write 6 pairs of bytes for updates to the Attribute table
        ldx     #$0A                            ; C8B9 A2 0A                    ..
LC8BB:
        ; SCRATCH_0B --> SCROLL_ATTR_BUFFER_ADDR,x then += 8
		lda     SCRATCH_0B                             ; C8BB A5 0B                    ..
        sta     SCROLL_ATTR_BUFFER_ADDR,x                         ; C8BD 9D 70 01                 .p.
        clc                                     ; C8C0 18                       .
        adc     #$08                            ; C8C1 69 08                    i.
        sta     SCRATCH_0B                             ; C8C3 85 0B                    ..
        
		; load the tile and advance; bits 6-7 moved to bits 2-3 and --> SCROLL_ATTR_BUFFER_VALUE,x
		lda     (PLAYER_MAP_TILE_PTR),y                       ; C8C5 B1 0C                    ..
        iny                                     ; C8C7 C8                       .
        and     #$C0                            ; C8C8 29 C0                    ).
        lsr     a                               ; C8CA 4A                       J
        lsr     a                               ; C8CB 4A                       J
        lsr     a                               ; C8CC 4A                       J
        lsr     a                               ; C8CD 4A                       J
        sta     SCROLL_ATTR_BUFFER_VALUE,x                         ; C8CE 9D 71 01                 .q.
        
		; load the tile and advance; upper 2 bits only ORA to SCROLL_ATTR_BUFFER_VALUE,x
		lda     (PLAYER_MAP_TILE_PTR),y                       ; C8D1 B1 0C                    ..
        iny                                     ; C8D3 C8                       .
        and     #$C0                            ; C8D4 29 C0                    ).
        ora     SCROLL_ATTR_BUFFER_VALUE,x                         ; C8D6 1D 71 01                 .q.
        sta     SCROLL_ATTR_BUFFER_VALUE,x                         ; C8D9 9D 71 01                 .q.
        
		; SCROLL_ATTR_BUFFER_VALUE,x /= 4 if PPU_WRITE_LO is odd (moves data from bits 2/3 and 6/7 to 0/1 and 4/5
		lda     PPU_WRITE_LO                             ; C8DC A5 16                    ..
        and     #$02                            ; C8DE 29 02                    ).
        bne     LC8E8                           ; C8E0 D0 06                    ..
        lsr     SCROLL_ATTR_BUFFER_VALUE,x                         ; C8E2 5E 71 01                 ^q.
        lsr     SCROLL_ATTR_BUFFER_VALUE,x                         ; C8E5 5E 71 01                 ^q.
LC8E8:
        ; create write buffer offset, loop while x>=0
		dex                                     ; C8E8 CA                       .
        dex                                     ; C8E9 CA                       .
        bpl     LC8BB                           ; C8EA 10 CF                    ..
        
		; now update the PPU - NMI 3 / LOAD_TILE_GRAPHICS_FOR_SCROLL
		lda     #$03                            ; C8EC A9 03                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; C8EE 20 8F CC                  ..
        rts                                     ; C8F1 60                       `

; ----------------------------------------------------------------------------
; loads map tiles, metadata, and palettes
; used to fully load a regular gameplay level e.g. dungeon, boss, dragon
LOAD_MAP_FULL: ; $c8f2
        jsr     CALC_MAP_POINTERS                           ; C8F2 20 D2 C9                  ..
        jsr     LOAD_MAP_TILES                           ; C8F5 20 A9 C9                  ..
        jsr     INIT_MAP                           ; C8F8 20 09 C9                  ..
        jsr     SET_PLAYER_AND_MAP_PALETTES                           ; C8FB 20 FB C9                  ..
        rts                                     ; C8FE 60                       `

; ----------------------------------------------------------------------------
; loads just map metadata, and palettes
; used for transitions between a regular gameplay level and e.g. shop/inn/item screen
; that don't use a full map level's worth of tiles
LOAD_MAP_NO_TILES:
        jsr     CALC_MAP_POINTERS                           ; C8FF 20 D2 C9                  ..
        jsr     INIT_MAP                           ; C902 20 09 C9                  ..
        jsr     SET_PLAYER_AND_MAP_PALETTES                           ; C905 20 FB C9                  ..
        rts                                     ; C908 60                       `

; ----------------------------------------------------------------------------
; reads a map's meta data and prepares it for use
; see CALC_MAP_POINTERS, which also sets the right bank 6 value ($8000-9fff)
; tiles are loaded separately via LOAD_MAP_TILES
; input: MAP_DATA_LO and MAP_DATA_HI point to the 256 byte map config at e.g. $8300, 8700, 8b00, 8e00
INIT_MAP:


		; x00: tile definitions
        ldy     #MAP_CFG_TILE_DEFS                            ; C909 A0 00                    ..
		lda     (MAP_DATA_LO),y                         ; C90B B1 77                    .w
        adc     #$A0                            ; C90D 69 A0                    i.
        
		sta     TILE_DEFS_HI                             ; C90F 85 7A                    .z
        lda     #$00                            ; C911 A9 00                    ..
        sta     TILE_DEFS_LO                             ; C913 85 79                    .y
        
		; x01: enemy sprite pattern table
		iny                                     ; C915 C8                       .
        lda     (MAP_DATA_LO),y                         ; C916 B1 77                    .w
        sta     CHR_BANK_ENEMY_SPRITES                             ; C918 85 2D                    .-
        
		; next 2 bytes - replacement blocks
		; x02-3
		iny                                     ; C91A C8                       .
        lda     (MAP_DATA_LO),y                         ; C91B B1 77                    .w
        sta     MAP_FAKE_TILE_ID                             ; C91D 85 70                    .p
        iny                                     ; C91F C8                       .
        lda     (MAP_DATA_LO),y                         ; C920 B1 77                    .w
        sta     MAP_REPLACEMENT_TILE_ID                             ; C922 85 71                    .q
        
		; x04: sprite that replaces moveable blocks when mattock/crossbow/glove used
		iny                                     ; C924 C8                       .
        lda     (MAP_DATA_LO),y                         ; C925 B1 77                    .w
        sta     MOVEABLE_BLOCK_REPLACEMENT_TILE_ID                             ; C927 85 74                    .t
        
		; x05-6: bg pattern tables
		iny                                     ; C929 C8                       .
        lda     (MAP_DATA_LO),y                         ; C92A B1 77                    .w
        ora     #$00                            ; C92C 09 00                    ..
        sta     CHR_BANK_BG_0                             ; C92E 85 2A                    .*
        iny                                     ; C930 C8                       .
        lda     (MAP_DATA_LO),y                         ; C931 B1 77                    .w
        ora     #$00                            ; C933 09 00                    ..
        sta     CHR_BANK_BG_1                             ; C935 85 2B                    .+
        	
		; branch if carry clear - item already collected / set to blank
		ldy     #MAP_CFG_HAS_TREASURE                            ; C937 A0 07                    ..
        jsr     CHECK_MAP_ITEM_EXTANT                           ; C939 20 1E CA                  ..
        lda     #$00                            ; C93C A9 00                    ..
        bcc     LC942                           ; C93E 90 02                    ..
        
		; carry set - item still there - use byte x07 instead.
		lda     (MAP_DATA_LO),y                         ; C940 B1 77                    .w
LC942:
        ; set treasure item gen type; this is a bit confusing but before opening the chests are 
		; technically enemies (OBJ_GEN_TYPE_ENEMY) so this value will always be the same for maps that
		; have treasure (i.e. not overworld, boss map)
		sta     MAP_ITEM_GEN_TYPE                           ; C942 8D A1 04                 ...
        
		; branch if no treasure item
		beq     LC973                           ; C945 F0 2C                    .,
        
		; we have an item, configure its location/contents
		lda     #$01                            ; C947 A9 01                    ..
        sta     MAP_ITEM_SPRITE_FLAGS                           ; C949 8D A2 04                 ...
        
		; x08 - treasure x hi
		iny                                     ; C94C C8                       .
        lda     (MAP_DATA_LO),y                         ; C94D B1 77                    .w
        sta     MAP_ITEM_X_HI                           ; C94F 8D AD 04                 ...
        lda     #$00                            ; C952 A9 00                    ..
        sta     MAP_ITEM_X_LO                           ; C954 8D AC 04                 ...
        
		; x09 - treasure y
		iny                                     ; C957 C8                       .
        lda     (MAP_DATA_LO),y                         ; C958 B1 77                    .w
        sta     MAP_ITEM_Y                           ; C95A 8D AE 04                 ...
        
		; x0a - treasure gen type
		iny                                     ; C95D C8                       .
        lda     (MAP_DATA_LO),y                         ; C95E B1 77                    .w
        cmp     #OBJ_GEN_TYPE_DRAGON_SLAYER                            ; C960 C9 17                    ..
        
		; branch if not the dragon slayer
		; different values for MAP_ITEM_SPRITE,1
		bne     LC96E                           ; C962 D0 0A                    ..
        
		; it is the dragonslayer - add 2 to convert treasure obj gen type
		; to the map item scale and save as MAP_ITEM_GEN_TYPE. This makes
		; the Dragon Slayer always appear out in the open rather than inside
		; a chest.
		lda     #MAP_ITEM_DRAGON_SLAYER                            ; C964 A9 19                    ..
        sta     MAP_ITEM_GEN_TYPE                           ; C966 8D A1 04                 ...
        
		; give it the dragonslayer sprite!
		lda     #$DD                            ; C969 A9 DD                    ..
        jmp     LC970                           ; C96B 4C 70 C9                 Lp.

; ----------------------------------------------------------------------------
LC96E:
		; assign treasure sprite for everything but the dragon slayer
        lda     #$E9                            ; C96E A9 E9                    ..
LC970:
        sta     MAP_ITEM_SPRITE                           ; C970 8D A0 04                 ...
LC973:
		; branch if MUSIC_ID >= 5, i.e. not one of the core dungeon sections
        ldx     MUSIC_ID                             ; C973 A6 8E                    ..
        cpx     #MUSIC_DRAGON_FIGHT                            ; C975 E0 05                    ..
		bcs     LC986                           ; C977 B0 0D                    ..
        
		; MUSIC_ID < 5 - section music for each player is the same as their PLAYER_ID
		; ROL A that # of times to move the carry into a bit location
		lda     #$00                            ; C979 A9 00                    ..
        sec                                     ; C97B 38                       8
LC97C:
        rol     a                               ; C97C 2A                       *
        dex                                     ; C97D CA                       .
        bpl     LC97C                           ; C97E 10 FC                    ..
        
		; branch (no music change) if current music compatible with this map
		ldy     #MAP_CFG_MUSIC_CONTROL                            ; C980 A0 15                    ..
        and     (MAP_DATA_LO),y                         ; C982 31 77                    1w
		bne     LC98D                           ; C984 D0 07                    ..
LC986:
        ; else, load the music specified in byte SCRATCH_0B
		ldy     #MAP_CFG_MUSIC_ID                            ; C986 A0 0B                    ..
        lda     (MAP_DATA_LO),y                         ; C988 B1 77                    .w
        jsr     LOAD_MUSIC_DATA_IF_NEC                           ; C98A 20 2E D0                  ..
LC98D:
		; shop info bytes x10-3
        ldy     #MAP_CFG_SHOP_LEFT_ITEM                         ; C98D A0 10                    ..
        lda     (MAP_DATA_LO),y                         ; C98F B1 77                    .w
        sta     SHOP_LEFT_ITEM_ID                             ; C991 85 80                    ..
        iny                                     ; C993 C8                       .
        lda     (MAP_DATA_LO),y                         ; C994 B1 77                    .w
        sta     SHOP_LEFT_ITEM_COST                             ; C996 85 81                    ..
        iny                                     ; C998 C8                       .
        lda     (MAP_DATA_LO),y                         ; C999 B1 77                    .w
        sta     SHOP_RIGHT_ITEM_ID                             ; C99B 85 82                    ..
        iny                                     ; C99D C8                       .
        lda     (MAP_DATA_LO),y                         ; C99E B1 77                    .w
        sta     SHOP_RIGHT_ITEM_COST                             ; C9A0 85 83                    ..
        
		; which players avoid extra damage on this map
		ldy     #MAP_CFG_PREFERRED_PLAYERS                            ; C9A2 A0 14                    ..
        lda     (MAP_DATA_LO),y                         ; C9A4 B1 77                    .w
        sta     MAP_PREFERRED_PLAYERS                             ; C9A6 85 41                    .A
        rts                                     ; C9A8 60                       `

; ----------------------------------------------------------------------------
; tiles for a map are copied from ROM to $500-7ff, 768 bytes
; inputs: ROM_MAP_START_LO/HI - see CALC_MAP_POINTERS, which also sets the right bank 6 value
; 64 columns of 12 rows = 768; data is written down each column and columns from left to right
; MAP_DATA_HI is advanced with each page that is written and ends up +3, pointing to the 
; map meta data (e.g. $8300, $8700, etc.) which is processed via INIT_MAP.
; for map 0,0 data is from $8000-82ff; for map 1,0 it's $8400-86ff 
LOAD_MAP_TILES:
		; copy ROM_MAP_START_LO to MAP_DATA_LO and ROM_MAP_START_HI to MAP_DATA_HI
        lda     ROM_MAP_START_LO                             ; C9A9 A5 75                    .u
        sta     MAP_DATA_LO                             ; C9AB 85 77                    .w
        lda     ROM_MAP_START_HI                             ; C9AD A5 76                    .v
        sta     MAP_DATA_HI                             ; C9AF 85 78                    .x
        ; copy 256 bytes from (MAP_DATA_LO) to CUR_MAP_TILES_START
		ldy     #$00                            ; C9B1 A0 00                    ..
LC9B3:
        lda     (MAP_DATA_LO),y                         ; C9B3 B1 77                    .w
        sta     CUR_MAP_TILES_START,y                         ; C9B5 99 00 05                 ...
        iny                                     ; C9B8 C8                       .
        bne     LC9B3                           ; C9B9 D0 F8                    ..
        
		; advance read location to next page
		inc     MAP_DATA_HI                             ; C9BB E6 78                    .x
LC9BD:
		; copy 256 bytes from (MAP_DATA_LO) to CUR_MAP_TILES_START+$0100
        lda     (MAP_DATA_LO),y                         ; C9BD B1 77                    .w
        sta     CUR_MAP_TILES_START+$0100,y                         ; C9BF 99 00 06                 ...
        iny                                     ; C9C2 C8                       .
        bne     LC9BD                           ; C9C3 D0 F8                    ..
        
		; advance read location to next page
		inc     MAP_DATA_HI                             ; C9C5 E6 78                    .x
LC9C7:
		; copy 256 bytes from (MAP_DATA_LO) to CUR_MAP_TILES_START+$0200
        lda     (MAP_DATA_LO),y                         ; C9C7 B1 77                    .w
        sta     CUR_MAP_TILES_START+$0200,y                         ; C9C9 99 00 07                 ...
        iny                                     ; C9CC C8                       .
        bne     LC9C7                           ; C9CD D0 F8                    ..
        
		; advance read location to next page
		inc     MAP_DATA_HI                             ; C9CF E6 78                    .x
        rts                                     ; C9D1 60                       `

; ----------------------------------------------------------------------------
; sets ROM_MAP_START_HI and MAP_DATA_HI based on map location; clears ROM_MAP_START_LO and MAP_DATA_LO
; looks like map data will always be read via the lower swappable bank (PRG_BANK_8000, $8000-$9fff) with the 
; bank id being MAP_Y / 2, so:
; Map Y:
; 0,1 --> bank 0 
; 2,3 --> bank 1
; 4,5 --> bank 2 
; 6,7 --> bank 3
; 8,9 --> bank 4 
; a,b --> bank 5
; c,d --> bank 6 
; e,f --> bank 7
; x10 (overworld) --> bank 8 
; x12,13 (boss, dragon) --> bank 9 
CALC_MAP_POINTERS:
        lda     MAP_Y                             ; C9D2 A5 48                    .H
        lsr     a                               ; C9D4 4A                       J
        cmp     PRG_BANK_8000                             ; C9D5 C5 30                    .0
        beq     LC9E0                           ; C9D7 F0 07                    ..
        sta     PRG_BANK_8000                             ; C9D9 85 30                    .0
        
		; xFF is just a stub routine in NMI
		lda     #$FF                            ; C9DB A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; C9DD 20 8F CC                  ..
LC9E0:
        ; HI byte calculation:
		; bits 0-1: 0 for ROM_MAP_START_HI, 3 for MAP_DATA_HI
		; bits 2-3: map x (0-3)
		; bit 4: 0 for even MAP_Y, 1 for odd
		; bit 7: 1
        ; so, for map 0,0 data at $8000 written starting at CUR_MAP_TILES_START
		; overworld x10,x03 = %10001100 = $8C00
		; boss levels x11,0-3 = $9000, $9400, $9800, $9C00
		lda     MAP_Y                             ; C9E0 A5 48                    .H
        and     #$01                            ; C9E2 29 01                    ).
        asl     a                               ; C9E4 0A                       .
        asl     a                               ; C9E5 0A                       .
        ora     MAP_X                             ; C9E6 05 47                    .G
        asl     a                               ; C9E8 0A                       .
        asl     a                               ; C9E9 0A                       .
        clc                                     ; C9EA 18                       .
        adc     #$80                            ; C9EB 69 80                    i.
        sta     ROM_MAP_START_HI                             ; C9ED 85 76                    .v
        clc                                     ; C9EF 18                       .
        adc     #$03                            ; C9F0 69 03                    i.
        sta     MAP_DATA_HI                             ; C9F2 85 78                    .x
        lda     #$00                            ; C9F4 A9 00                    ..
        sta     MAP_DATA_LO                             ; C9F6 85 77                    .w
        sta     ROM_MAP_START_LO                             ; C9F8 85 75                    .u
        rts                                     ; C9FA 60                       `

; ----------------------------------------------------------------------------
; PALETTE_BUFFER_PLAYER,x lies within the 32 byte buffer starting at $0180,x
; indirect read to copy 32 bytes from MAP_DATA_LO-8 address to $a0-bf
SET_PLAYER_AND_MAP_PALETTES:
        ldy     #$E0                            ; C9FB A0 E0                    ..
LC9FD:
		; likely copying palette data
		; write is actually to $0180-19f, 32 bytes 
        lda     (MAP_DATA_LO),y                         ; C9FD B1 77                    .w
        sta     DATA_BUFFER_0180-$e0,y                            ; C9FF 99 A0 00                 ...
        iny                                     ; CA02 C8                       .
        
		; loop while y is negative, 32 loops
		bmi     LC9FD                           ; CA03 30 F8                    0.
        
		; branch (rts) if PLAYER_ID >= 6
		lda     PLAYER_ID                             ; CA05 A5 40                    .@
        cmp     #PLAYER_NONE                            ; CA07 C9 06                    ..
		bcs     LCA1D                           ; CA09 B0 12                    ..
        
		; we have a valid player selected; mult by 4 converting PLAYER_ID to index in x for table TBL_PLAYER_PALETTES
		; which is stored in PALETTE_BUFFER_PLAYER
		asl     a                               ; CA0B 0A                       .
        asl     a                               ; CA0C 0A                       .
        clc                                     ; CA0D 18                       .
        adc     #$03                            ; CA0E 69 03                    i.
        tax                                     ; CA10 AA                       .
        ldy     #$03                            ; CA11 A0 03                    ..
LCA13:
        lda     TBL_PLAYER_PALETTES,x                         ; CA13 BD C5 FF                 ...
        sta     PALETTE_BUFFER_PLAYER,y                         ; CA16 99 90 01                 ...
        dex                                     ; CA19 CA                       .
        dey                                     ; CA1A 88                       .
        
		; loop while y>=0
		bpl     LCA13                           ; CA1B 10 F6                    ..
LCA1D:
        rts                                     ; CA1D 60                       `

; ----------------------------------------------------------------------------
; uses bit shifting to move a bit indicating whether the map item for the current
; map is still available to collect - sets carry if so, clears it if it's gone
CHECK_MAP_ITEM_EXTANT:
        ; use map coord to make an index and put it in x; load some data from CURRENT_STATE_EXTANT_TREASURES,x
		; bit 2 = Y even/odd; bits 0-1 = map x
		lda     MAP_Y                             ; CA1E A5 48                    .H
        asl     a                               ; CA20 0A                       .
        asl     a                               ; CA21 0A                       .
        and     #$04                            ; CA22 29 04                    ).
        ora     MAP_X                             ; CA24 05 47                    .G
        tax                                     ; CA26 AA                       .
        lda     CURRENT_STATE_EXTANT_TREASURES,x                         ; CA27 BD 00 03                 ...
        
		; save the looked up data
		pha                                     ; CA2A 48                       H
        
		; map y/2 + 1 = how many loops to do below
		lda     MAP_Y                             ; CA2B A5 48                    .H
        lsr     a                               ; CA2D 4A                       J
        tax                                     ; CA2E AA                       .
        inx                                     ; CA2F E8                       .
        
		; restore the looked up data
		pla                                     ; CA30 68                       h
LCA31:
        asl     a                               ; CA31 0A                       .
        dex                                     ; CA32 CA                       .
        
		; loop until x=0
		bne     LCA31                           ; CA33 D0 FC                    ..
        rts                                     ; CA35 60                       `

; ----------------------------------------------------------------------------
; when the item in a chest has been collected, we come here to make sure it can'table
; be collected again. The 4x16 dungeon has 64 screens, so 8 bytes are used for the data.
MARK_TREASURE_COLLECTED:
		; x = map y/2 + 1, range 1-8
        lda     MAP_Y                             ; CA36 A5 48                    .H
        lsr     a                               ; CA38 4A                       J
        tax                                     ; CA39 AA                       .
        inx                                     ; CA3A E8                       .
        
		; 
		lda     #$FF                            ; CA3B A9 FF                    ..
        clc                                     ; CA3D 18                       .
LCA3E:
		; loop until x=0; this will shift the cleared carry to bit (8-x) with the 
		; other bits all set. Result is a bit mask with a single clear bit corresponding
		; to the map location the item was collected from.
        ror     a                               ; CA3E 6A                       j
        dex                                     ; CA3F CA                       .
        bne     LCA3E                           ; CA40 D0 FC                    ..
        
		; save a, use MAP_Y and MAP_X to make an index into CURRENT_STATE_EXTANT_TREASURES
		pha                                     ; CA42 48                       H
        lda     MAP_Y                             ; CA43 A5 48                    .H
        asl     a                               ; CA45 0A                       .
        asl     a                               ; CA46 0A                       .
        and     #$04                            ; CA47 29 04                    ).
        ora     MAP_X                             ; CA49 05 47                    .G
        tax                                     ; CA4B AA                       .
        
		; retrieve the bitmask and clear the treasure, save the result
		pla                                     ; CA4C 68                       h
        and     CURRENT_STATE_EXTANT_TREASURES,x                         ; CA4D 3D 00 03                 =..
        sta     CURRENT_STATE_EXTANT_TREASURES,x                         ; CA50 9D 00 03                 ...
        rts                                     ; CA53 60                       `

; ----------------------------------------------------------------------------
; updates the various map tile/data pointers in sync with where the player is so that everything
; works with scrolling, the nametables, etc.
; this was hard to puzzle out b/c in addition to maintaining PLAYER_MAP_TILE_HI/LO pointing to 
; where the tiles are in RAM, it calculates the equivalent ROM_MAP_TILE_ pointers, which are 
; written here but not used anywhere.
UPDATE_MAP_TILE_PTRS:
        lda     PLAYER_MAP_TILE_HI                             ; CA54 A5 0D                    ..
        pha                                     ; CA56 48                       H
        jsr     TILE_LO_MULT_BY_12                           ; CA57 20 85 CA                  ..
        
		; high ptr --> ROM_MAP_TILE_HI; restore original hi ptr --> a
		lda     PLAYER_MAP_TILE_HI                             ; CA5A A5 0D                    ..
        sta     ROM_MAP_TILE_HI                             ; CA5C 85 11                    ..
        pla                                     ; CA5E 68                       h
        
		; divide the original PLAYER_MAP_TILE_HI by 16 and add lo value --> ROM_MAP_TILE_LO
		lsr     a                               ; CA5F 4A                       J
        lsr     a                               ; CA60 4A                       J
        lsr     a                               ; CA61 4A                       J
        lsr     a                               ; CA62 4A                       J
        clc                                     ; CA63 18                       .
        adc     PLAYER_MAP_TILE_LO                           ; CA64 65 0C                    e.
        sta     PLAYER_MAP_TILE_LO                           ; CA66 85 0C                    ..
        sta     ROM_MAP_TILE_LO                             ; CA68 85 10                    ..
        bcc     LCA70                           ; CA6A 90 04                    ..
        
		; handle carry
		inc     PLAYER_MAP_TILE_HI                             ; CA6C E6 0D                    ..
        inc     ROM_MAP_TILE_HI                             ; CA6E E6 11                    ..
LCA70:
        ; above value for PLAYER_MAP_TILE_HI is the offset to the current location of interest; 
		; add x05 because the tile data starts at CUR_MAP_TILES_START (see CALC_MAP_POINTERS)
		; ROM_MAP_TILE_HI is written/incremented in a few places but don't appear to be used for anything
        clc                                     ; CA70 18                       .
        lda     PLAYER_MAP_TILE_HI                             ; CA71 A5 0D                    ..
        adc     #$05                            ; CA73 69 05                    i.
        sta     PLAYER_MAP_TILE_HI                             ; CA75 85 0D                    ..
        clc                                     ; CA77 18                       .
        
		; update the ROM pointers, but as far as I can tell it's never used for anything
		lda     ROM_MAP_TILE_LO                             ; CA78 A5 10                    ..
        adc     ROM_MAP_START_LO                             ; CA7A 65 75                    eu
        sta     ROM_MAP_TILE_LO                             ; CA7C 85 10                    ..
        lda     ROM_MAP_TILE_HI                             ; CA7E A5 11                    ..
        adc     ROM_MAP_START_HI                             ; CA80 65 76                    ev
        sta     ROM_MAP_TILE_HI                             ; CA82 85 11                    ..
        rts                                     ; CA84 60                       `

; ----------------------------------------------------------------------------
; 16-bit multiply by 12 of PLAYER_MAP_TILE_LO; since maps are stored in columns of 12 blocks
; this converts between LO and HI values.
TILE_LO_MULT_BY_12:
        ; clear HI
		lda     #$00                            ; CA85 A9 00                    ..
        
		; mult LO by 4 and save
		sta     PLAYER_MAP_TILE_HI                             ; CA87 85 0D                    ..
        asl     PLAYER_MAP_TILE_LO                           ; CA89 06 0C                    ..
        rol     PLAYER_MAP_TILE_HI                             ; CA8B 26 0D                    &.
        asl     PLAYER_MAP_TILE_LO                           ; CA8D 06 0C                    ..
        rol     PLAYER_MAP_TILE_HI                             ; CA8F 26 0D                    &.
        ldx     PLAYER_MAP_TILE_HI                             ; CA91 A6 0D                    ..
        ldy     PLAYER_MAP_TILE_LO                           ; CA93 A4 0C                    ..
        
		; mult by another 2 (8 total) then add the original x4 result = mult by 12
		asl     PLAYER_MAP_TILE_LO                           ; CA95 06 0C                    ..
        rol     PLAYER_MAP_TILE_HI                             ; CA97 26 0D                    &.
        tya                                     ; CA99 98                       .
        clc                                     ; CA9A 18                       .
        adc     PLAYER_MAP_TILE_LO                           ; CA9B 65 0C                    e.
        sta     PLAYER_MAP_TILE_LO                           ; CA9D 85 0C                    ..
        txa                                     ; CA9F 8A                       .
        adc     PLAYER_MAP_TILE_HI                             ; CAA0 65 0D                    e.
        sta     PLAYER_MAP_TILE_HI                             ; CAA2 85 0D                    ..
        rts                                     ; CAA4 60                       `

; ----------------------------------------------------------------------------
; called when STATUS_BAR_UPDATE_FLAG flag is set and then cleared
; waits for NMI, sets PPU_WRITE_LO and PPU_WRITE_HI, then runs NMI routine 4
; PPU $2360 = player life/magic/golds/keys on status bar
QUEUE_NMI_ROUTINE_STATUS_BAR_UPDATE:
        jsr     WAIT_FOR_NEXT_NMI_ROUTINE_CLEAR                           ; CAA5 20 97 CC                  ..
        lda     #$60                            ; CAA8 A9 60                    .`
        sta     PPU_WRITE_LO                             ; CAAA 85 16                    ..
        lda     #$23                            ; CAAC A9 23                    .#
        sta     PPU_WRITE_HI                             ; CAAE 85 17                    ..
        lda     #$04                            ; CAB0 A9 04                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; CAB2 20 8F CC                  ..
        rts                                     ; CAB5 60                       `

; ----------------------------------------------------------------------------
; handles bounds checking and flags for status bar update when life changes
EVENT_PLAYER_LIFE_CHANGE:
		; cap player life and copy it to SCRATCH_08
        lda     PLAYER_LIFE                             ; CAB6 A5 58                    .X
        cmp     #MAX_PLAYER_STAT                            ; CAB8 C9 6D                    .m
        bcc     LCABE                           ; CABA 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; CABC A9 6D                    .m
LCABE:
        sta     PLAYER_LIFE                             ; CABE 85 58                    .X
        sta     SCRATCH_08                             ; CAC0 85 08                    ..
        ldx     #$00                            ; CAC2 A2 00                    ..
        jsr     CALC_PLAYER_STAT_BAR_SPRITES                           ; CAC4 20 0E CB                  ..
        
		; flag the update
		lda     #$01                            ; CAC7 A9 01                    ..
        sta     STATUS_BAR_UPDATE_FLAG                             ; CAC9 85 3C                    .<
        rts                                     ; CACB 60                       `

; ----------------------------------------------------------------------------
; handles bounds checking and flags for status bar update when magic changes
EVENT_PLAYER_MAGIC_CHANGE:
        ; cap player magic and copy it to SCRATCH_08
        lda     PLAYER_MAGIC                             ; CACC A5 59                    .Y
        cmp     #MAX_PLAYER_STAT                            ; CACE C9 6D                    .m
        bcc     LCAD4                           ; CAD0 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; CAD2 A9 6D                    .m
LCAD4:
        sta     PLAYER_MAGIC                             ; CAD4 85 59                    .Y
        sta     SCRATCH_08                             ; CAD6 85 08                    ..
        ldx     #$06                            ; CAD8 A2 06                    ..
        jsr     CALC_PLAYER_STAT_BAR_SPRITES                           ; CADA 20 0E CB                  ..
        
		; flag the update
		lda     #$01                            ; CADD A9 01                    ..
        sta     STATUS_BAR_UPDATE_FLAG                             ; CADF 85 3C                    .<
        rts                                     ; CAE1 60                       `

; ----------------------------------------------------------------------------
; handles bounds checking and flags for status bar update when key changes
EVENT_PLAYER_KEY_CHANGE:
        ; cap player keys and copy it to SCRATCH_08
		lda     PLAYER_KEYS                             ; CAE2 A5 5B                    .[
        cmp     #MAX_PLAYER_STAT                            ; CAE4 C9 6D                    .m
        
		; branch if keys < max player stat
		bcc     LCAEA                           ; CAE6 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; CAE8 A9 6D                    .m
LCAEA:
        sta     PLAYER_KEYS                             ; CAEA 85 5B                    .[
        sta     SCRATCH_08                             ; CAEC 85 08                    ..
        ldx     #$0C                            ; CAEE A2 0C                    ..
        jsr     CALC_PLAYER_STAT_BAR_SPRITES                           ; CAF0 20 0E CB                  ..
        
		; flag the update
		lda     #$01                            ; CAF3 A9 01                    ..
        sta     STATUS_BAR_UPDATE_FLAG                             ; CAF5 85 3C                    .<
        rts                                     ; CAF7 60                       `

; ----------------------------------------------------------------------------
; handles bounds checking and flags for status bar update when golds changes
EVENT_PLAYER_GOLDS_CHANGE:
		; cap player golds and copy it to SCRATCH_08
        lda     PLAYER_GOLDS                             ; CAF8 A5 5A                    .Z
        cmp     #MAX_PLAYER_STAT                            ; CAFA C9 6D                    .m
        bcc     LCB00                           ; CAFC 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; CAFE A9 6D                    .m
LCB00:
        sta     PLAYER_GOLDS                             ; CB00 85 5A                    .Z
        sta     SCRATCH_08                             ; CB02 85 08                    ..
        ldx     #$12                            ; CB04 A2 12                    ..
        jsr     CALC_PLAYER_STAT_BAR_SPRITES                           ; CB06 20 0E CB                  ..
        
		; flag the update
		lda     #$01                            ; CB09 A9 01                    ..
        sta     STATUS_BAR_UPDATE_FLAG                             ; CB0B 85 3C                    .<
        rts                                     ; CB0D 60                       `

; ----------------------------------------------------------------------------
; 
; input x set based on player stat just capped and copied to SCRATCH_08
; life = 0
; magic = 6
; keys = xC
; gold = x12
; 5 sprites to represent ones values at PLAYER_STAT_BAR_ONES,x
; 5 sprites to represent tens values at PLAYER_STAT_BAR_TENS,x
; sprite DA = full, DE = one, DF = none; FB=border sprite in between stat types
CALC_PLAYER_STAT_BAR_SPRITES:
		; save a copy of x on stack
        txa                                     ; CB0E 8A                       .
        pha                                     ; CB0F 48                       H
        ldy     #$05                            ; CB10 A0 05                    ..
        lda     #$DC                            ; CB12 A9 DC                    ..
LCB14:
		; writing xDC to low stack; loop until y=0
        sta     PLAYER_STAT_BAR_TENS,x                         ; CB14 9D 01 01                 ...
        inx                                     ; CB17 E8                       .
        dey                                     ; CB18 88                       .
        bne     LCB14                           ; CB19 D0 F9                    ..

		; retrieve a and save it again, put it in x
        pla                                     ; CB1B 68                       h
        pha                                     ; CB1C 48                       H
        tax                                     ; CB1D AA                       .
        ldy     #$05                            ; CB1E A0 05                    ..
        lda     #$DF                            ; CB20 A9 DF                    ..
LCB22:
		; now write xDF to the low stack starting at PLAYER_STAT_BAR_ONES,x
        sta     PLAYER_STAT_BAR_ONES,x                         ; CB22 9D 21 01                 .!.
        inx                                     ; CB25 E8                       .
        dey                                     ; CB26 88                       .
        bne     LCB22                           ; CB27 D0 F9                    ..
        
		; restore the original x
		pla                                     ; CB29 68                       h
        tax                                     ; CB2A AA                       .
        jsr     GET_TENS_FROM_08_HEX                           ; CB2B 20 FA CB                  ..
        
		; compute the decimal tens and ones values
		txa                                     ; CB2E 8A                       .
LCB2F:
        dey                                     ; CB2F 88                       .
        beq     LCB3F                           ; CB30 F0 0D                    ..
        dec     PLAYER_STAT_BAR_TENS,x                         ; CB32 DE 01 01                 ...
        dey                                     ; CB35 88                       .
        beq     LCB3F                           ; CB36 F0 07                    ..
        dec     PLAYER_STAT_BAR_TENS,x                         ; CB38 DE 01 01                 ...
        inx                                     ; CB3B E8                       .
        jmp     LCB2F                           ; CB3C 4C 2F CB                 L/.

; ----------------------------------------------------------------------------
LCB3F:
        tax                                     ; CB3F AA                       .
        ldy     SCRATCH_08                             ; CB40 A4 08                    ..
LCB42:
        dey                                     ; CB42 88                       .
        beq     LCB52                           ; CB43 F0 0D                    ..
        dec     PLAYER_STAT_BAR_ONES,x                         ; CB45 DE 21 01                 .!.
        dey                                     ; CB48 88                       .
        beq     LCB52                           ; CB49 F0 07                    ..
        dec     PLAYER_STAT_BAR_ONES,x                         ; CB4B DE 21 01                 .!.
        inx                                     ; CB4E E8                       .
        jmp     LCB42                           ; CB4F 4C 42 CB                 LB.

; ----------------------------------------------------------------------------
LCB52:
        rts                                     ; CB52 60                       `

; ----------------------------------------------------------------------------
; same as below but using different sprite IDs for the life bar
DRAW_CROWN_BOSS_LIFE_BAR:
        lda     OBJ_HP                           ; CB53 AD 05 04                 ...
        cmp     #MAX_PLAYER_STAT                            ; CB56 C9 6D                    .m
        bcc     LCB5C                           ; CB58 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; CB5A A9 6D                    .m
LCB5C:
        sta     SCRATCH_08                             ; CB5C 85 08                    ..
        lda     #$00                            ; CB5E A9 00                    ..
        sta     SCRATCH_09                             ; CB60 85 09                    ..
        ldx     #$A5                            ; CB62 A2 A5                    ..
        ldy     #$AB                            ; CB64 A0 AB                    ..
        jmp     LCB94                           ; CB66 4C 94 CB                 L..

; ----------------------------------------------------------------------------
; label and life bars drawn as 16 sprites from BOSS_LIFE_BAR_SPRITE_Y
DRAW_DRAGON_LIFE_BAR:
        lda     OBJ_HP                           ; CB69 AD 05 04                 ...
        cmp     #MAX_PLAYER_STAT                            ; CB6C C9 6D                    .m
        bcc     LCB72                           ; CB6E 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; CB70 A9 6D                    .m
LCB72:
        sta     SCRATCH_08                             ; CB72 85 08                    ..
        lda     #$00                            ; CB74 A9 00                    ..
        sta     SCRATCH_09                             ; CB76 85 09                    ..
        ldx     #$65                            ; CB78 A2 65                    .e
        ldy     #$6B                            ; CB7A A0 6B                    .k
        jmp     LCB94                           ; CB7C 4C 94 CB                 L..

; ----------------------------------------------------------------------------
; label and life bars drawn as 16 sprites from PLAYER_LIFE_BAR_SPRITE_Y
DRAW_PLAYER_LIFE_BAR:
        lda     PLAYER_LIFE                             ; CB7F A5 58                    .X
        cmp     #MAX_PLAYER_STAT                            ; CB81 C9 6D                    .m
        bcc     LCB87                           ; CB83 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; CB85 A9 6D                    .m
LCB87:
        sta     SCRATCH_08                             ; CB87 85 08                    ..
        
		; positions separately in sprite RAM from dragon life bar
		lda     #$80                            ; CB89 A9 80                    ..
        sta     SCRATCH_09                             ; CB8B 85 09                    ..
        ldx     #$65                            ; CB8D A2 65                    .e
        ldy     #$6B                            ; CB8F A0 6B                    .k
        jmp     LCB94                           ; CB91 4C 94 CB                 L..

; ----------------------------------------------------------------------------
; draws a life bar and label
; inputs:
; SCRATCH_09: offset from sprite positions, transferred to x for use
; x: the sprite ID for the first 5 sprites (tens bar of life)
; y: the sprite ID for the second 5 sprites (ones bar)
LCB94:
		; x --> a; SCRATCH_09 --> x (0 or x80) and used as index into sprite data
        ; tens bar
		txa                                     ; CB94 8A                       .
        ldx     SCRATCH_09                             ; CB95 A6 09                    ..
        sta     $0259,x                         ; CB97 9D 59 02                 .Y.
        sta     $025D,x                         ; CB9A 9D 5D 02                 .].
        sta     $0261,x                         ; CB9D 9D 61 02                 .a.
        sta     $0265,x                         ; CBA0 9D 65 02                 .e.
        sta     $0269,x                         ; CBA3 9D 69 02                 .i.
        
		; ones bar
		tya                                     ; CBA6 98                       .
        sta     $026D,x                         ; CBA7 9D 6D 02                 .m.
        sta     $0271,x                         ; CBAA 9D 71 02                 .q.
        sta     $0275,x                         ; CBAD 9D 75 02                 .u.
        sta     $0279,x                         ; CBB0 9D 79 02                 .y.
        sta     $027D,x                         ; CBB3 9D 7D 02                 .}.
        
		; convert SCRATCH_08 to remainder, y=tens value+1
		jsr     GET_TENS_FROM_08_HEX                           ; CBB6 20 FA CB                  ..
        lda     SCRATCH_09                             ; CBB9 A5 09                    ..
        clc                                     ; CBBB 18                       .
        adc     #$18                            ; CBBC 69 18                    i.
        tax                                     ; CBBE AA                       .

; loop here to modify sprites for the correct # of tens to show
; decrementing the sprite ID by 2 will give the next higher appearance
; 0 bars --> 1 bar --> 2 bars
; note whenever y hits zero we branch below to hit up the ones
LCBBF:
        dey                                     ; CBBF 88                       .
        beq     LCBD8                           ; CBC0 F0 16                    ..
        dec     $0241,x                         ; CBC2 DE 41 02                 .A.
        dec     $0241,x                         ; CBC5 DE 41 02                 .A.
        dey                                     ; CBC8 88                       .
        beq     LCBD8                           ; CBC9 F0 0D                    ..
        dec     $0241,x                         ; CBCB DE 41 02                 .A.
        dec     $0241,x                         ; CBCE DE 41 02                 .A.
        inx                                     ; CBD1 E8                       .
        inx                                     ; CBD2 E8                       .
        inx                                     ; CBD3 E8                       .
        inx                                     ; CBD4 E8                       .
        jmp     LCBBF                           ; CBD5 4C BF CB                 L..

; ----------------------------------------------------------------------------
; now show the ones. at the start, SCRATCH_08 = ones value + 1 
; decrementing the sprite ID by 2 will give the next higher appearance
; 0 bars --> 1 bar --> 2 bars
; so, note that if life=1, SCRATCH_08=2 and 1 set of decrements will be applied to sprites
LCBD8:
        ; adjust x for the ones bar position
		lda     SCRATCH_09                             ; CBD8 A5 09                    ..
        clc                                     ; CBDA 18                       .
        adc     #$2C                            ; CBDB 69 2C                    i,
        tax                                     ; CBDD AA                       .
        
		
		ldy     SCRATCH_08                             ; CBDE A4 08                    ..
LCBE0:
        dey                                     ; CBE0 88                       .
        beq     LCBF9                           ; CBE1 F0 16                    ..
        dec     $0241,x                         ; CBE3 DE 41 02                 .A.
        dec     $0241,x                         ; CBE6 DE 41 02                 .A.
        dey                                     ; CBE9 88                       .
        beq     LCBF9                           ; CBEA F0 0D                    ..
        dec     $0241,x                         ; CBEC DE 41 02                 .A.
        dec     $0241,x                         ; CBEF DE 41 02                 .A.
        inx                                     ; CBF2 E8                       .
        inx                                     ; CBF3 E8                       .
        inx                                     ; CBF4 E8                       .
        inx                                     ; CBF5 E8                       .
        jmp     LCBE0                           ; CBF6 4C E0 CB                 L..

; ----------------------------------------------------------------------------
LCBF9:
        rts                                     ; CBF9 60                       `

; ----------------------------------------------------------------------------
; subtract 10s serially from SCRATCH_08 until below zero. 
; output: y = # of subtractions that occurred
GET_TENS_FROM_08_HEX:
        lda     SCRATCH_08                             ; CBFA A5 08                    ..
        ldy     #$00                            ; CBFC A0 00                    ..
        sec                                     ; CBFE 38                       8
LCBFF:
        iny                                     ; CBFF C8                       .
        sbc     #$0A                            ; CC00 E9 0A                    ..
        bcs     LCBFF                           ; CC02 B0 FB                    ..
        adc     #$0B                            ; CC04 69 0B                    i.
        sta     SCRATCH_08                             ; CC06 85 08                    ..
        rts                                     ; CC08 60                       `

; ----------------------------------------------------------------------------
; holds until player not presseing anything
; then waits for them to press something and release
; artificially restores what they pressed (so it can have its regular action)
; used e.g. after elixir healing
HOLD_FOR_JOYPAD_ACKNOWLEDGE:
		; wait for release
        jsr     HOLD_UNTIL_NO_PLAYER_INPUT                           ; CC09 20 17 CC                  ..
        
		; wait for input and save it
		jsr     HOLD_UNTIL_PLAYER_INPUT                           ; CC0C 20 2D CC                  -.
        pha                                     ; CC0F 48                       H
        
		; wait for another release
		jsr     HOLD_UNTIL_NO_PLAYER_INPUT                           ; CC10 20 17 CC                  ..
        
		; restore the earlier input so it takes effect, but only once released
		pla                                     ; CC13 68                       h
        sta     JOYPAD_INPUT                             ; CC14 85 20                    . 
        rts                                     ; CC16 60                       `

; ----------------------------------------------------------------------------
; strange holding loop redrawing things on pause until the player gives no JOYPAD input
; called e.g. after elixir healing
HOLD_UNTIL_NO_PLAYER_INPUT:
        lda     #$01                            ; CC17 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; CC19 85 36                    .6
        jsr     DRAW_PLAYER                           ; CC1B 20 D8 C1                  ..
        jsr     DRAW_OBJECTS                           ; CC1E 20 B1 C2                  ..
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; CC21 20 34 C2                  4.
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; CC24 20 35 C1                  5.
        jsr     READ_JOYPADS                           ; CC27 20 43 CC                  C.
        
		; loop if joypad input not 0; else rts
		bne     HOLD_UNTIL_NO_PLAYER_INPUT                           ; CC2A D0 EB                    ..
        rts                                     ; CC2C 60                       `

; ----------------------------------------------------------------------------
; strange holding loop redrawing things on pause until the player gives JOYPAD input
; called e.g. after elixir healing
HOLD_UNTIL_PLAYER_INPUT:
        lda     #$01                            ; CC2D A9 01                    ..
        sta     NMI_WAIT_CTR                             ; CC2F 85 36                    .6
        jsr     DRAW_PLAYER                           ; CC31 20 D8 C1                  ..
        jsr     DRAW_OBJECTS                           ; CC34 20 B1 C2                  ..
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; CC37 20 34 C2                  4.
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; CC3A 20 35 C1                  5.
        jsr     READ_JOYPADS                           ; CC3D 20 43 CC                  C.
        
		; loop if joypad input 0; else rts
		beq     HOLD_UNTIL_PLAYER_INPUT                           ; CC40 F0 EB                    ..
        rts                                     ; CC42 60                       `

; ----------------------------------------------------------------------------
; read the joypad registers and store them in JOYPAD_INPUT
READ_JOYPADS:
        ldx     #$01                            ; CC43 A2 01                    ..
        stx     JOY_1_REG                           ; CC45 8E 16 40                 ..@
        dex                                     ; CC48 CA                       .
        stx     JOY_1_REG                           ; CC49 8E 16 40                 ..@
        ldx     #$08                            ; CC4C A2 08                    ..
LCC4E:
        ; loop reading joypad registers - combine input from both controllers
		lda     JOY_1_REG                           ; CC4E AD 16 40                 ..@
        ora     JOY_2_REG                           ; CC51 0D 17 40                 ..@
        
		; bit 0 of register values is rolled into JOYPAD_INPUT
		lsr     a                               ; CC54 4A                       J
        rol     JOYPAD_INPUT                             ; CC55 26 20                    & 
        
		; now bit 1 is rolled into JOYPAD_INPUT_TMP - apparently only works with
		; a famicom expansion controller; used to enable one of the cheats but 
		; doesn't seem to work on NES emulator
		lsr     a                               ; CC57 4A                       J
        rol     JOYPAD_INPUT_TMP                             ; CC58 26 21                    &!
        dex                                     ; CC5A CA                       .
        bne     LCC4E                           ; CC5B D0 F1                    ..
        
		; all controllers are combined into JOYPAD_INPUT
		lda     JOYPAD_INPUT                             ; CC5D A5 20                    . 
        ora     JOYPAD_INPUT_TMP                             ; CC5F 05 21                    .!
        sta     JOYPAD_INPUT                             ; CC61 85 20                    . 
        rts                                     ; CC63 60                       `

; ----------------------------------------------------------------------------
; Update the RNG! 
; It's only updated when values are requested; this can happen multiple times for a single 
; enemy action, or never depending on the enemy. So, some screens rarely/never update RNG,
; while others do so very frequently.
; input  - a = max value; if 0 we just return 0
; output - a = RNG value:  0 <= value < max
; otherwise, a is used as max value for RNG_3
UPDATE_RNG:
        ; save our max value to RNG_0; rts if 0
		sta     RNG_0                             ; CC64 85 38                    .8
        beq     LCC8E                           ; CC66 F0 26                    .&
        
		; here's where the bit-shifting magic happens...
		ldx     RNG_3                             ; CC68 A6 3B                    .;
        ldy     RNG_2                             ; CC6A A4 3A                    .:
LCC6C:
        sty     RNG_1                             ; CC6C 84 39                    .9
        tya                                     ; CC6E 98                       .
        asl     a                               ; CC6F 0A                       .
        tay                                     ; CC70 A8                       .
        txa                                     ; CC71 8A                       .
        rol     a                               ; CC72 2A                       *
        tax                                     ; CC73 AA                       .
        iny                                     ; CC74 C8                       .
        bne     LCC78                           ; CC75 D0 01                    ..
        inx                                     ; CC77 E8                       .
LCC78:
        clc                                     ; CC78 18                       .
        tya                                     ; CC79 98                       .
        adc     RNG_2                             ; CC7A 65 3A                    e:
        tay                                     ; CC7C A8                       .
        txa                                     ; CC7D 8A                       .
        adc     RNG_3                             ; CC7E 65 3B                    e;
        clc                                     ; CC80 18                       .
        adc     RNG_1                             ; CC81 65 39                    e9
        
		; enforce max value of 0x7f
		and     #$7F                            ; CC83 29 7F                    ).
        tax                                     ; CC85 AA                       .
        stx     RNG_3                             ; CC86 86 3B                    .;
        sty     RNG_2                             ; CC88 84 3A                    .:
        
		; RNG output now in a and RNG_3 - loop if >= max
		cmp     RNG_0                             ; CC8A C5 38                    .8
        bcs     LCC6C                           ; CC8C B0 DE                    ..
LCC8E:
		; otherwise, we have our value!
        rts                                     ; CC8E 60                       `

; ----------------------------------------------------------------------------
; waits for NEXT_NMI_ROUTINE to clear
; a is then queued as NEXT_NMI_ROUTINE
QUEUE_NEXT_NMI_ROUTINE:
        pha                                     ; CC8F 48                       H
LCC90:
        lda     NEXT_NMI_ROUTINE                             ; CC90 A5 28                    .(
        
		; branch if NEXT_NMI_ROUTINE set
		bne     LCC90                           ; CC92 D0 FC                    ..
        
		; NEXT_NMI_ROUTINE = 0; queue routine specified by a
		pla                                     ; CC94 68                       h
        sta     NEXT_NMI_ROUTINE                             ; CC95 85 28                    .(

; wait for NEXT_NMI_ROUTINE to be set to 0
WAIT_FOR_NEXT_NMI_ROUTINE_CLEAR:
        lda     NEXT_NMI_ROUTINE                             ; CC97 A5 28                    .(
        bne     WAIT_FOR_NEXT_NMI_ROUTINE_CLEAR                           ; CC99 D0 FC                    ..
        rts                                     ; CC9B 60                       `

; ----------------------------------------------------------------------------
; set swappable banks to banks C-D (start screen/player death/dragon fight)
USE_PRG_CD:
		; save copies of bank values
        lda     PRG_BANK_8000                             ; CC9C A5 30                    .0
        sta     COPY_PRG_BANK_8000                             ; CC9E 85 32                    .2
        lda     PRG_BANK_A000                             ; CCA0 A5 31                    .1
        sta     COPY_PRG_BANK_A000                             ; CCA2 85 33                    .3
 
		; push new return value to stack ($c7cc)
		lda     #$CC                            ; CCA4 A9 CC                    ..
        pha                                     ; CCA6 48                       H
        lda     #$C7                            ; CCA7 A9 C7                    ..
        pha                                     ; CCA9 48                       H
        ldy     #$06                            ; CCAA A0 06                    ..
        sty     LAST_BANK_UPDATED                             ; CCAC 84 25                    .%
        sty     MAPPER_BANK_SELECT                           ; CCAE 8C 00 80                 ...
        lda     #$0C                            ; CCB1 A9 0C                    ..
        sta     PRG_BANK_8000                             ; CCB3 85 30                    .0
        sta     MAPPER_BANK_VALUE                           ; CCB5 8D 01 80                 ...
        iny                                     ; CCB8 C8                       .
        sty     LAST_BANK_UPDATED                             ; CCB9 84 25                    .%
        sty     MAPPER_BANK_SELECT                           ; CCBB 8C 00 80                 ...
        lda     #$0D                            ; CCBE A9 0D                    ..
        sta     PRG_BANK_A000                             ; CCC0 85 31                    .1
        sta     MAPPER_BANK_VALUE                           ; CCC2 8D 01 80                 ...
        
		; jump to address at JMP_DEST_0E_LO-f
		jmp     (JMP_DEST_0E_LO)                         ; CCC5 6C 0E 00                 l..

; ----------------------------------------------------------------------------
; appears to be unused function just to revert banks 6-7, a stripped down version of the one below
		; restore prior bank values from copies
		ldy     #$07                            ; CCC8 A0 07                    ..
        sty     LAST_BANK_UPDATED                             ; CCCA 84 25                    .%
        sty     MAPPER_BANK_SELECT                           ; CCCC 8C 00 80                 ...
        lda     COPY_PRG_BANK_A000                             ; CCCF A5 33                    .3
        sta     PRG_BANK_A000                             ; CCD1 85 31                    .1
        sta     MAPPER_BANK_VALUE                           ; CCD3 8D 01 80                 ...
        dey                                     ; CCD6 88                       .
        sty     LAST_BANK_UPDATED                             ; CCD7 84 25                    .%
        sty     MAPPER_BANK_SELECT                           ; CCD9 8C 00 80                 ...
        lda     COPY_PRG_BANK_8000                             ; CCDC A5 32                    .2
        sta     PRG_BANK_8000                             ; CCDE 85 30                    .0
        sta     MAPPER_BANK_VALUE                           ; CCE0 8D 01 80                 ...
        rts                                     ; CCE3 60                       `

; ----------------------------------------------------------------------------
; restore banks 6 ($8000-$9FFF) and 7 ($A000-$BFFF) to prior copied values
; then jump to the destination in $0e-f
; $cd07 is pushed to stack, so will eventually return to $cd08
REVERT_PRG_AND_JUMP:
 
		; push return value onto stack - will execute $CD08 after rts
		lda     #$CD                            ; CCE4 A9 CD                    ..
        pha                                     ; CCE6 48                       H
        lda     #$07                            ; CCE7 A9 07                    ..
        pha                                     ; CCE9 48                       H
        ldy     #$07                            ; CCEA A0 07                    ..
        sty     LAST_BANK_UPDATED                             ; CCEC 84 25                    .%
        sty     MAPPER_BANK_SELECT                           ; CCEE 8C 00 80                 ...
        lda     COPY_PRG_BANK_A000                             ; CCF1 A5 33                    .3
        sta     PRG_BANK_A000                             ; CCF3 85 31                    .1
        sta     MAPPER_BANK_VALUE                           ; CCF5 8D 01 80                 ...
        dey                                     ; CCF8 88                       .
        sty     LAST_BANK_UPDATED                             ; CCF9 84 25                    .%
        sty     MAPPER_BANK_SELECT                           ; CCFB 8C 00 80                 ...
        lda     COPY_PRG_BANK_8000                             ; CCFE A5 32                    .2
        sta     PRG_BANK_8000                             ; CD00 85 30                    .0
        sta     MAPPER_BANK_VALUE                           ; CD02 8D 01 80                 ...
        jmp     (JMP_DEST_0E_LO)                         ; CD05 6C 0E 00                 l..

; ----------------------------------------------------------------------------
; similar to USE_PRG_CD but instead of jumping elsewhere, RTS at end
USE_PRG_CD_AND_RETURN:
        lda     PRG_BANK_8000                             ; CD08 A5 30                    .0
        sta     COPY_PRG_BANK_8000                             ; CD0A 85 32                    .2
        lda     PRG_BANK_A000                             ; CD0C A5 31                    .1
        sta     COPY_PRG_BANK_A000                             ; CD0E 85 33                    .3
        ldy     #$06                            ; CD10 A0 06                    ..
        sty     LAST_BANK_UPDATED                             ; CD12 84 25                    .%
        sty     MAPPER_BANK_SELECT                           ; CD14 8C 00 80                 ...
        lda     #$0C                            ; CD17 A9 0C                    ..
        sta     PRG_BANK_8000                             ; CD19 85 30                    .0
        sta     MAPPER_BANK_VALUE                           ; CD1B 8D 01 80                 ...
        iny                                     ; CD1E C8                       .
        sty     LAST_BANK_UPDATED                             ; CD1F 84 25                    .%
        sty     MAPPER_BANK_SELECT                           ; CD21 8C 00 80                 ...
        lda     #$0D                            ; CD24 A9 0D                    ..
        sta     PRG_BANK_A000                             ; CD26 85 31                    .1
        sta     MAPPER_BANK_VALUE                           ; CD28 8D 01 80                 ...
        rts                                     ; CD2B 60                       `

; ----------------------------------------------------------------------------
; calc the player's move vector based on speed and dpad input
; input: Y = player speed
NORMAL_PLAY_CALC_PLAYER_MOVE_VECTOR:
        sty     SCRATCH_09                             ; CD2C 84 09                    ..
        ldy     SCRATCH_09                             ; CD2E A4 09                    ..
        
		; branch (kill movement) if Y=0
		beq     LCD67                           ; CD30 F0 35                    .5
        
		; otherwise, multiply d-pad input by 2 and save to x
		lda     JOYPAD_INPUT                             ; CD32 A5 20                    . 
        and     #$0F                            ; CD34 29 0F                    ).
        asl     a                               ; CD36 0A                       .
        tax                                     ; CD37 AA                       .
        lda     #$00                            ; CD38 A9 00                    ..
LCD3A:
		; loop to add table value once for each Y
        clc                                     ; CD3A 18                       .
        adc     TBL_DPAD_TO_DX,x                         ; CD3B 7D 8B FE                 }..
        dey                                     ; CD3E 88                       .
        bne     LCD3A                           ; CD3F D0 F9                    ..
        
		; save value, write 0-15 to dx
		pha                                     ; CD41 48                       H
        and     #$0F                            ; CD42 29 0F                    ).
        sta     PLAYER_DX                             ; CD44 85 49                    .I
        ldy     #$00                            ; CD46 A0 00                    ..
        pla                                     ; CD48 68                       h
        
		; branch if dx positive: 0 --> SCRATCH_08
		bpl     LCD4D                           ; CD49 10 02                    ..
        
		; dx negative: 0xF0 --> SCRATCH_08
		ldy     #$F0                            ; CD4B A0 F0                    ..
LCD4D:
        sty     SCRATCH_08                             ; CD4D 84 08                    ..
        
		; move upper nibble dx to lower nibble, and ORA with SCRATCH_08
		and     #$F0                            ; CD4F 29 F0                    ).
        lsr     a                               ; CD51 4A                       J
        lsr     a                               ; CD52 4A                       J
        lsr     a                               ; CD53 4A                       J
        lsr     a                               ; CD54 4A                       J
        ora     SCRATCH_08                             ; CD55 05 08                    ..
        
		; result is PLAYER_HORIZ_DIR = xFF if dx negative/left, or x00 if dx positive/right/zero
		; seems more complicated than necessary...?
		sta     PLAYER_HORIZ_DIR                             ; CD57 85 4A                    .J
        ldy     SCRATCH_09                             ; CD59 A4 09                    ..
        lda     #$00                            ; CD5B A9 00                    ..
LCD5D:
		; loop to mult dy value from table by speed
        clc                                     ; CD5D 18                       .
        adc     TBL_DPAD_TO_DY,x                         ; CD5E 7D 8C FE                 }..
        dey                                     ; CD61 88                       .
        bne     LCD5D                           ; CD62 D0 F9                    ..
        sta     PLAYER_DY                             ; CD64 85 4B                    .K
        rts                                     ; CD66 60                       `

; ----------------------------------------------------------------------------
LCD67:
		; player not moving
        lda     #$00                            ; CD67 A9 00                    ..
        sta     PLAYER_DX                             ; CD69 85 49                    .I
        sta     PLAYER_HORIZ_DIR                             ; CD6B 85 4A                    .J
        sta     PLAYER_DY                             ; CD6D 85 4B                    .K
        rts                                     ; CD6F 60                       `

; ----------------------------------------------------------------------------
; similar to above, but for the current object instead of player
; input - a = joypad input
; y = speed
CALC_CUR_OBJ_MOVE_VECTOR:
        ; branch (no movement) if speed = 0
		sty     SCRATCH_09                             ; CD70 84 09                    ..
        ldy     SCRATCH_09                             ; CD72 A4 09                    ..
        beq     LCDA9                           ; CD74 F0 33                    .3
        
		; limit joypad input to dpad, mult by 2 for idx into TBL_DPAD_TO_DX
		and     #$0F                            ; CD76 29 0F                    ).
        asl     a                               ; CD78 0A                       .
        tax                                     ; CD79 AA                       .
        lda     #$00                            ; CD7A A9 00                    ..
LCD7C:
        clc                                     ; CD7C 18                       .
        adc     TBL_DPAD_TO_DX,x                         ; CD7D 7D 8B FE                 }..
        
		; loop to mult dx by speed
		dey                                     ; CD80 88                       .
        bne     LCD7C                           ; CD81 D0 F9                    ..
        
		; push dx and save lower nibble to CUR_OBJ_DX
		pha                                     ; CD83 48                       H
        and     #$0F                            ; CD84 29 0F                    ).
        sta     CUR_OBJ_DX                             ; CD86 85 F5                    ..
        
		; set SCRATCH_08 = 0 if dx positive, xF0 if negative
		ldy     #$00                            ; CD88 A0 00                    ..
        pla                                     ; CD8A 68                       h
        bpl     LCD8F                           ; CD8B 10 02                    ..
        ldy     #$F0                            ; CD8D A0 F0                    ..
LCD8F:
        sty     SCRATCH_08                             ; CD8F 84 08                    ..
        
		; move bit 7 (sign) of dx to bit 3 and ORA with dx lower nibble
		; result is 4 bit signed value of dx, +/- 7 which is stored as F6
		and     #$F0                            ; CD91 29 F0                    ).
        lsr     a                               ; CD93 4A                       J
        lsr     a                               ; CD94 4A                       J
        lsr     a                               ; CD95 4A                       J
        lsr     a                               ; CD96 4A                       J
        ora     SCRATCH_08                             ; CD97 05 08                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; CD99 85 F6                    ..
        
		; loop to multiple dy from table by speed
		ldy     SCRATCH_09                             ; CD9B A4 09                    ..
        lda     #$00                            ; CD9D A9 00                    ..
LCD9F:
        clc                                     ; CD9F 18                       .
        adc     TBL_DPAD_TO_DY,x                         ; CDA0 7D 8C FE                 }..
        dey                                     ; CDA3 88                       .
        bne     LCD9F                           ; CDA4 D0 F9                    ..
        
		; save dy
		sta     CUR_OBJ_DY                             ; CDA6 85 F7                    ..
        rts                                     ; CDA8 60                       `

; ----------------------------------------------------------------------------
LCDA9:
		; not moving
        lda     #$00                            ; CDA9 A9 00                    ..
        sta     CUR_OBJ_DX                             ; CDAB 85 F5                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; CDAD 85 F6                    ..
        sta     CUR_OBJ_DY                             ; CDAF 85 F7                    ..
        rts                                     ; CDB1 60                       `

; ----------------------------------------------------------------------------
; checks the TEMP_NEXT positions for collision with certain objects (items, enemies, moveable blocks)
; if there is a current object, we won't check for self-hit
; output:
; carry - set if collision, clear if not
; SCRATCH_08 - slot # of object we hit
; SCRATCH_09 - offset to object we hit (slot # * 0x10)
CHECK_TEMP_POS_HIT_OBJECT:
        ldy     #$09                            ; CDB2 A0 09                    ..
        ldx     #$90                            ; CDB4 A2 90                    ..
LCDB6:
        ; branch (no collision) if y=CUR_OBJ_SLOT_NUM - don't check for a collision with yourself!
		cpy     CUR_OBJ_SLOT_NUM                             ; CDB6 C4 E3                    ..
        beq     LCE0A                           ; CDB8 F0 50                    .P
        
		; branch (no collision) if object x is dead
		lda     OBJ_GENERAL_TYPE,x                         ; CDBA BD 01 04                 ...
        bmi     LCE0A                           ; CDBD 30 4B                    0K
        
		; not dead; branch if enemy or temp object (moveable block)
		cmp     #OBJ_GEN_TYPE_ENEMY                            ; CDBF C9 01                    ..
        beq     LCDC7                           ; CDC1 F0 04                    ..
        
		; not an enemy; branch (no collision) if < x1A (item)
		cmp     #$1A                            ; CDC3 C9 1A                    ..
        bcc     LCE0A                           ; CDC5 90 43                    .C
LCDC7:
		; x is an enemy, item, or projectile - branch (no collision) if sprite = treasure chest
        lda     OBJ_SPRITE,x                         ; CDC7 BD 00 04                 ...
        and     #$F9                            ; CDCA 29 F9                    ).
        cmp     #$E1                            ; CDCC C9 E1                    ..
        beq     LCE0A                           ; CDCE F0 3A                    .:
        
		; branch (no collision) if sprite priority = 1 (behind bg) 
		lda     OBJ_SPRITE_FLAGS,x                         ; CDD0 BD 02 04                 ...
        and     #$20                            ; CDD3 29 20                    ) 
        bne     LCE0A                           ; CDD5 D0 33                    .3
        
		; check object x / cur obj y diff
		lda     TEMP_NEXT_Y                             ; CDD7 A5 0A                    ..
        sec                                     ; CDD9 38                       8
        sbc     OBJ_Y,x                         ; CDDA FD 0E 04                 ...
        
		; go to LCDE5 if y diff +/- 0x10
		; branch (no collision) if greater than that
		cmp     #$10                            ; CDDD C9 10                    ..
        bcc     LCDE5                           ; CDDF 90 04                    ..
        cmp     #$F1                            ; CDE1 C9 F1                    ..
        bcc     LCE0A                           ; CDE3 90 25                    .%
LCDE5:
        ; object y's are close enough to hit
		; check the x
		lda     TEMP_NEXT_X_HI                             ; CDE5 A5 0F                    ..
        sec                                     ; CDE7 38                       8
        sbc     OBJ_X_HI,x                         ; CDE8 FD 0D 04                 ...
        
		; hit if they're on the same x block
		beq     LCE14                           ; CDEB F0 27                    .'
        
		; check x low if the difference was <2 blocks plus or minus
		cmp     #$02                            ; CDED C9 02                    ..
        bcc     LCE02                           ; CDEF 90 11                    ..
		cmp     #$FF                            ; CDF1 C9 FF                    ..
        bcc     LCE0A                           ; CDF3 90 15                    ..
        lda     TEMP_NEXT_X_LO                           ; CDF5 A5 0E                    ..
        sec                                     ; CDF7 38                       8
        sbc     OBJ_X_LO,x                         ; CDF8 FD 0C 04                 ...
        
		; no hit - object is 1 block to our left and X LO less than or equal to ours
		beq     LCE0A                           ; CDFB F0 0D                    ..
        bmi     LCE0A                           ; CDFD 30 0B                    0.
        
		; hit - object is 1 block to our left and X LO greater than ours
		jmp     LCE14                           ; CDFF 4C 14 CE                 L..

; ----------------------------------------------------------------------------
LCE02:
		; comparison if objects are 1 block off in x - checks pixel to see if 
		; they are close enough
        lda     TEMP_NEXT_X_LO                           ; CE02 A5 0E                    ..
        sec                                     ; CE04 38                       8
        sbc     OBJ_X_LO,x                         ; CE05 FD 0C 04                 ...
        
		; branch (hit) if minus - object is 1 block to our right with X LO less than ours
		bmi     LCE14                           ; CE08 30 0A                    0.
LCE0A:
        txa                                     ; CE0A 8A                       .
        sec                                     ; CE0B 38                       8
        sbc     #$10                            ; CE0C E9 10                    ..
        tax                                     ; CE0E AA                       .
        dey                                     ; CE0F 88                       .
        
		; loop until y=0
		bpl     LCDB6                           ; CE10 10 A4                    ..
        clc                                     ; CE12 18                       .
        rts                                     ; CE13 60                       `

; ----------------------------------------------------------------------------
LCE14:
		; collision! SCRATCH_08 = slot we collided with, x=offset to that object (y*16)
        sty     SCRATCH_08                             ; CE14 84 08                    ..
        stx     SCRATCH_09                             ; CE16 86 09                    ..
        sec                                     ; CE18 38                       8
        rts                                     ; CE19 60                       `

; ----------------------------------------------------------------------------
; check if the temp pos values would be touching a "solid" sprite - e.g. moveable block, opening door, etc.
; return - carry set if touching, clear if not
; this function is key to the glove block clip b/c once the block has 0 hp, it's general type is
; set to x80 (newly killed object). Since the game isn't expecting blocks to be killed, the type isn't 
; further changed from there (it would be set to x81 as the death sprite was placed for enemies). The block
; being "dead" makes it fail the OBJ_GENERAL_TYPE check below and therefore skip collision detection. 
; the carry returns clear 
CHECK_TOUCH_SOLID_SPRITE:
        ldy     #$0A                            ; CE1A A0 0A                    ..
        ldx     #$A0                            ; CE1C A2 A0                    ..
LCE1E:
        ; branch if CUR_OBJ_SLOT_NUM = y (skip slot for current object)
		cpy     CUR_OBJ_SLOT_NUM                             ; CE1E C4 E3                    ..
        beq     LCE6C                           ; CE20 F0 4A                    .J
        
		; branch if empty or dead
		lda     OBJ_GENERAL_TYPE,x                         ; CE22 BD 01 04                 ...
        beq     LCE6C                           ; CE25 F0 45                    .E
        bmi     LCE6C                           ; CE27 30 43                    0C
        
		; looks like these are the chest mimics
		; glove block sprite = x32; &xF9 = x30 so <> $e1 and we check it here
		lda     OBJ_SPRITE,x                         ; CE29 BD 00 04                 ...
        and     #$F9                            ; CE2C 29 F9                    ).
        cmp     #$E1                            ; CE2E C9 E1                    ..
        beq     LCE6C                           ; CE30 F0 3A                    .:
        
		; skip if behind the bg 
		lda     OBJ_SPRITE_FLAGS,x                         ; CE32 BD 02 04                 ...
        and     #$20                            ; CE35 29 20                    ) 
        bne     LCE6C                           ; CE37 D0 33                    .3
        
		; skip unless y is +/- 16 of this object
		lda     TEMP_NEXT_Y                             ; CE39 A5 0A                    ..
        sec                                     ; CE3B 38                       8
        sbc     OBJ_Y,x                         ; CE3C FD 0E 04                 ...
        cmp     #$10                            ; CE3F C9 10                    ..
        bcc     LCE47                           ; CE41 90 04                    ..
        cmp     #$F1                            ; CE43 C9 F1                    ..
        bcc     LCE6C                           ; CE45 90 25                    .%
LCE47:
		; then check for x collision
		; wind up at LCE76 if there's a collsision we care about
        lda     TEMP_NEXT_X_HI                             ; CE47 A5 0F                    ..
        sec                                     ; CE49 38                       8
        sbc     OBJ_X_HI,x                         ; CE4A FD 0D 04                 ...
        beq     LCE76                           ; CE4D F0 27                    .'
        cmp     #$02                            ; CE4F C9 02                    ..
        bcc     LCE64                           ; CE51 90 11                    ..
        cmp     #$FF                            ; CE53 C9 FF                    ..
        bcc     LCE6C                           ; CE55 90 15                    ..
        lda     TEMP_NEXT_X_LO                           ; CE57 A5 0E                    ..
        sec                                     ; CE59 38                       8
        sbc     OBJ_X_LO,x                         ; CE5A FD 0C 04                 ...
        beq     LCE6C                           ; CE5D F0 0D                    ..
        bmi     LCE6C                           ; CE5F 30 0B                    0.
        jmp     LCE76                           ; CE61 4C 76 CE                 Lv.

; ----------------------------------------------------------------------------
LCE64:
        lda     TEMP_NEXT_X_LO                           ; CE64 A5 0E                    ..
        sec                                     ; CE66 38                       8
        sbc     OBJ_X_LO,x                         ; CE67 FD 0C 04                 ...
        bmi     LCE76                           ; CE6A 30 0A                    0.
LCE6C:
		; advance to the next slot
        txa                                     ; CE6C 8A                       .
        sec                                     ; CE6D 38                       8
        sbc     #$10                            ; CE6E E9 10                    ..
        tax                                     ; CE70 AA                       .
        dey                                     ; CE71 88                       .
        bpl     LCE1E                           ; CE72 10 AA                    ..
        clc                                     ; CE74 18                       .
        rts                                     ; CE75 60                       `

; ----------------------------------------------------------------------------
LCE76:
		; player is touching a chest - save the slot/offset
        sty     SCRATCH_08                             ; CE76 84 08                    ..
        stx     SCRATCH_09                             ; CE78 86 09                    ..
        sec                                     ; CE7A 38                       8
        rts                                     ; CE7B 60                       `

; ----------------------------------------------------------------------------

; set carry and proximity flag if object collides with player
CHECK_OBJ_COLLIDE_WITH_PLAYER:
        ; clear flag
		lda     #$00                            ; CE7C A9 00                    ..
        sta     CUR_OBJ_PLAYER_PROXIMITY_FLAG                             ; CE7E 85 EA                    ..
        jsr     CHECK_OBJ_PLAYER_COLLIDE_Y                           ; CE80 20 B6 CE                  ..
        bcc     LCE8F                           ; CE83 90 0A                    ..
        jsr     CHECK_OBJ_PLAYER_COLLIDE_X                           ; CE85 20 90 CE                  ..
        bcc     LCE8F                           ; CE88 90 05                    ..
        
		; set flag
		lda     #$01                            ; CE8A A9 01                    ..
        sta     CUR_OBJ_PLAYER_PROXIMITY_FLAG                             ; CE8C 85 EA                    ..
        sec                                     ; CE8E 38                       8
LCE8F:
        rts                                     ; CE8F 60                       `

; ----------------------------------------------------------------------------
; set carry if player/object collide in x, clear carry if not
CHECK_OBJ_PLAYER_COLLIDE_X:
        sec                                     ; CE90 38                       8
        lda     TEMP_NEXT_X_HI                             ; CE91 A5 0F                    ..
        sbc     PX_HI                             ; CE93 E5 44                    .D
        beq     LCEB4                           ; CE95 F0 1D                    ..
        cmp     #$02                            ; CE97 C9 02                    ..
        bcc     LCEAB                           ; CE99 90 10                    ..
        cmp     #$FF                            ; CE9B C9 FF                    ..
        bcc     LCEB2                           ; CE9D 90 13                    ..
        sec                                     ; CE9F 38                       8
        lda     TEMP_NEXT_X_LO                           ; CEA0 A5 0E                    ..
        sbc     PX_LO                             ; CEA2 E5 43                    .C
        beq     LCEB2                           ; CEA4 F0 0C                    ..
        bmi     LCEB2                           ; CEA6 30 0A                    0.
        jmp     LCEB4                           ; CEA8 4C B4 CE                 L..

; ----------------------------------------------------------------------------
LCEAB:
        lda     TEMP_NEXT_X_LO                           ; CEAB A5 0E                    ..
        sec                                     ; CEAD 38                       8
        sbc     PX_LO                             ; CEAE E5 43                    .C
        bmi     LCEB4                           ; CEB0 30 02                    0.
LCEB2:
        ; no overlap
        clc                                     ; CEB2 18                       .
        rts                                     ; CEB3 60                       `

; ----------------------------------------------------------------------------
LCEB4:
        ; overlap
		sec                                     ; CEB4 38                       8
        rts                                     ; CEB5 60                       `

; ----------------------------------------------------------------------------
; return - carry set if player and object overlap in y; clear carry if not
CHECK_OBJ_PLAYER_COLLIDE_Y:
        lda     TEMP_NEXT_Y                             ; CEB6 A5 0A                    ..
        sec                                     ; CEB8 38                       8
        sbc     PY                             ; CEB9 E5 45                    .E
        
		; branch if y-py < x10
		cmp     #$10                            ; CEBB C9 10                    ..
        bcc     LCEC3                           ; CEBD 90 04                    ..
        
		; branch if y-py < -x10
		; otherwise y-py = -x0F to -1 and we have a collision
		cmp     #$F1                            ; CEBF C9 F1                    ..
        bcc     LCEC5                           ; CEC1 90 02                    ..
LCEC3:
		; overlap
        sec                                     ; CEC3 38                       8
        rts                                     ; CEC4 60                       `

; ----------------------------------------------------------------------------
LCEC5:
		; no overlap
        clc                                     ; CEC5 18                       .
        rts                                     ; CEC6 60                       `

; ----------------------------------------------------------------------------
; sets flag and carry if within 1 block of or hitting player
; sets the same flag as CHECK_OBJ_COLLIDE_WITH_PLAYER but is somewhat looser
; in that we mark a collision if the y is compatible and we are within 1 block
; left of player, not necessarily colliding
CHECK_BOSS_PLAYER_PROXIMITY:
		; clear collision flag
        lda     #$00                            ; CEC7 A9 00                    ..
        sta     CUR_OBJ_PLAYER_PROXIMITY_FLAG                             ; CEC9 85 EA                    ..
        
		; branch if definitely close enough y
		lda     TEMP_NEXT_Y                             ; CECB A5 0A                    ..
        sec                                     ; CECD 38                       8
        sbc     PY                             ; CECE E5 45                    .E
        cmp     #$10                            ; CED0 C9 10                    ..
        bcc     LCED8                           ; CED2 90 04                    ..
        
		; branch if definitely too far y
		cmp     #$E1                            ; CED4 C9 E1                    ..
        bcc     LCF00                           ; CED6 90 28                    .(
LCED8:
		; y is overlapping; now check x
		; branch (collision) if on the same x hi
        sec                                     ; CED8 38                       8
        lda     TEMP_NEXT_X_HI                             ; CED9 A5 0F                    ..
        sbc     PX_HI                             ; CEDB E5 44                    .D
        beq     LCF02                           ; CEDD F0 23                    .#
        
		; branch (collision) if we are one to left of player
		cmp     #$FF                            ; CEDF C9 FF                    ..
        beq     LCF02                           ; CEE1 F0 1F                    ..
        
		; branch (check x lo) if we are 1 block right of player
		cmp     #$02                            ; CEE3 C9 02                    ..
        bcc     LCEF8                           ; CEE5 90 11                    ..
        
		; branch (no collision) if we are > 2 blocks left of player
		cmp     #$FE                            ; CEE7 C9 FE                    ..
        bcc     LCF00                           ; CEE9 90 15                    ..
        
		; we are 2 blocks left of the player; check x lo
		; no collision if px is >= ours
		; collision if < ours (we are less than 1 full block distant)
		sec                                     ; CEEB 38                       8
        lda     TEMP_NEXT_X_LO                           ; CEEC A5 0E                    ..
        sbc     a:PX_LO                           ; CEEE ED 43 00                 .C.
        beq     LCF00                           ; CEF1 F0 0D                    ..
        bmi     LCF00                           ; CEF3 30 0B                    0.
        jmp     LCF02                           ; CEF5 4C 02 CF                 L..

; ----------------------------------------------------------------------------
LCEF8:
		; we are 1 block right of player
		; collide if our x lo is < player's, else no collision
        lda     TEMP_NEXT_X_LO                           ; CEF8 A5 0E                    ..
        sec                                     ; CEFA 38                       8
        sbc     a:PX_LO                           ; CEFB ED 43 00                 .C.
        bmi     LCF02                           ; CEFE 30 02                    0.
LCF00:
        clc                                     ; CF00 18                       .
        rts                                     ; CF01 60                       `

; ----------------------------------------------------------------------------
LCF02:
        lda     #$01                            ; CF02 A9 01                    ..
        sta     CUR_OBJ_PLAYER_PROXIMITY_FLAG                             ; CF04 85 EA                    ..
        sec                                     ; CF06 38                       8
        rts                                     ; CF07 60                       `

; ----------------------------------------------------------------------------
; detects when objects go offscreen
; return - carry set if offscreen, clear if onscreen
; used for player to check scroll
; for dead enemies to drop items
; for boss to flag end of fight
CHECK_OBJECT_OFFSCREEN:
		; branch (set carry) if TEMP_NEXT_Y >= xC0 - fell off bottom
        lda     TEMP_NEXT_Y                             ; CF08 A5 0A                    ..
        cmp     #$C0                            ; CF0A C9 C0                    ..
        bcs     LCF18                           ; CF0C B0 0A                    ..
        
		; branch (clear carry) if TEMP_NEXT_X_HI < x3F - not too far right
		lda     TEMP_NEXT_X_HI                             ; CF0E A5 0F                    ..
        cmp     #$3F                            ; CF10 C9 3F                    .?
        bcc     LCF1A                           ; CF12 90 06                    ..
        
		; branch (clear carry) if $0E = 0; else set carry
		lda     TEMP_NEXT_X_LO                           ; CF14 A5 0E                    ..
        beq     LCF1A                           ; CF16 F0 02                    ..
LCF18:
        ; offscreen
		sec                                     ; CF18 38                       8
        rts                                     ; CF19 60                       `

; ----------------------------------------------------------------------------
LCF1A:
		; onscreen
        clc                                     ; CF1A 18                       .
        rts                                     ; CF1B 60                       `

; ----------------------------------------------------------------------------
; set carry if moveable block attempting to go oob
; clear carry if all good
CHECK_BLOCK_MOVING_OOB:
        lda     TEMP_NEXT_Y                             ; CF1C A5 0A                    ..
        cmp     #$B0                            ; CF1E C9 B0                    ..
        bcs     LCF2C                           ; CF20 B0 0A                    ..
        
		lda     TEMP_NEXT_X_HI                             ; CF22 A5 0F                    ..
        cmp     #$3F                            ; CF24 C9 3F                    .?
        bcc     LCF2E                           ; CF26 90 06                    ..
        
		lda     TEMP_NEXT_X_LO                           ; CF28 A5 0E                    ..
        beq     LCF2E                           ; CF2A F0 02                    ..
LCF2C:
        ; going offscreen
		sec                                     ; CF2C 38                       8
        rts                                     ; CF2D 60                       `

; ----------------------------------------------------------------------------
LCF2E:
		; staying onscreen
        clc                                     ; CF2E 18                       .
        rts                                     ; CF2F 60                       `

; ----------------------------------------------------------------------------
; draw the qty of items in inventory for the item selection screen
DRAW_ALL_INV_ITEM_QTY:
        ldx     #$0F                            ; CF30 A2 0F                    ..
LCF32:
        txa                                     ; CF32 8A                       .
        pha                                     ; CF33 48                       H
        ldy     PLAYER_INVENTORY,x                           ; CF34 B4 60                    .`
        jsr     DRAW_INV_ITEM_QTY                           ; CF36 20 3F CF                  ?.
        pla                                     ; CF39 68                       h
        tax                                     ; CF3A AA                       .
        dex                                     ; CF3B CA                       .
        bpl     LCF32                           ; CF3C 10 F4                    ..
        rts                                     ; CF3E 60                       `

; ----------------------------------------------------------------------------
; item qty on start screen, with color based on usability
; input: y=quantity of item
; x=item slot
DRAW_INV_ITEM_QTY:
        txa                                     ; CF3F 8A                       .
        pha                                     ; CF40 48                       H
        txa                                     ; CF41 8A                       .
        and     #$07                            ; CF42 29 07                    ).
        asl     a                               ; CF44 0A                       .
        asl     a                               ; CF45 0A                       .
        sta     PPU_WRITE_LO                             ; CF46 85 16                    ..
        txa                                     ; CF48 8A                       .
        and     #$08                            ; CF49 29 08                    ).
        asl     a                               ; CF4B 0A                       .
        asl     a                               ; CF4C 0A                       .
        asl     a                               ; CF4D 0A                       .
        asl     a                               ; CF4E 0A                       .
        ora     PPU_WRITE_LO                             ; CF4F 05 16                    ..
        sta     PPU_WRITE_LO                             ; CF51 85 16                    ..
        lda     #$00                            ; CF53 A9 00                    ..
        sta     PPU_WRITE_HI                             ; CF55 85 17                    ..
        
		; offsets above added to base address $20c2, nametable 0
		clc                                     ; CF57 18                       .
        lda     #$C2                            ; CF58 A9 C2                    ..
        adc     PPU_WRITE_LO                             ; CF5A 65 16                    e.
        sta     PPU_WRITE_LO                             ; CF5C 85 16                    ..
        lda     #$20                            ; CF5E A9 20                    . 
        adc     PPU_WRITE_HI                             ; CF60 65 17                    e.
        sta     PPU_WRITE_HI                             ; CF62 85 17                    ..
        
		; draw the qty
		tya                                     ; CF64 98                       .
        jsr     DRAW_VALUE_DECIMAL                           ; CF65 20 F9 CF                  ..
        pla                                     ; CF68 68                       h
        
		; branch if item is usable for player
		jsr     CHECK_ITEM_USABLE_FOR_PLAYER                           ; CF69 20 17 D0                  ..
        bcs     LCF7C                           ; CF6C B0 0E                    ..
        
		; subtract x40 from DECIMAL_ONES_NAME and DECIMAL_TENS_NAME if item not usable - changes color of text
		; because the pattern table has separate entries for each letter/number 
		lda     DECIMAL_ONES_NAME                             ; CF6E A5 18                    ..
        sec                                     ; CF70 38                       8
        sbc     #$40                            ; CF71 E9 40                    .@
        sta     DECIMAL_ONES_NAME                             ; CF73 85 18                    ..
        lda     DECIMAL_TENS_NAME                             ; CF75 A5 19                    ..
        sec                                     ; CF77 38                       8
        sbc     #$40                            ; CF78 E9 40                    .@
        sta     DECIMAL_TENS_NAME                             ; CF7A 85 19                    ..
LCF7C:
		; nmi route 6 - writes DECIMAL_ONES_NAME and DECIMAL_TENS_NAME to the PPU write address
        lda     #$06                            ; CF7C A9 06                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; CF7E 20 8F CC                  ..
        rts                                     ; CF81 60                       `

; ----------------------------------------------------------------------------
; player stats on start screen
DRAW_START_SCR_PLAYER_STATS:
		; shot power
        ; set PPU location, calc the value, draw it, update/nmi
		lda     #$DE                            ; CF82 A9 DE                    ..
        sta     PPU_WRITE_LO                             ; CF84 85 16                    ..
        lda     #$21                            ; CF86 A9 21                    .!
        sta     PPU_WRITE_HI                             ; CF88 85 17                    ..
        jsr     CALC_PLAYER_SHOT_POWER                           ; CF8A 20 51 D0                  Q.
        jsr     DRAW_VALUE_DECIMAL                           ; CF8D 20 F9 CF                  ..
        lda     #$06                            ; CF90 A9 06                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; CF92 20 8F CC                  ..
        
		; as above for jump height/frames
		lda     #$1E                            ; CF95 A9 1E                    ..
        sta     PPU_WRITE_LO                             ; CF97 85 16                    ..
        lda     #$22                            ; CF99 A9 22                    ."
        sta     PPU_WRITE_HI                             ; CF9B 85 17                    ..
        jsr     CALC_PLAYER_JUMP_FRAMES                           ; CF9D 20 38 D0                  8.
        jsr     DRAW_VALUE_DECIMAL                           ; CFA0 20 F9 CF                  ..
        lda     #$06                            ; CFA3 A9 06                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; CFA5 20 8F CC                  ..
        
		; as above for shot length/frames
		lda     #$5E                            ; CFA8 A9 5E                    .^
        sta     PPU_WRITE_LO                             ; CFAA 85 16                    ..
        lda     #$22                            ; CFAC A9 22                    ."
        sta     PPU_WRITE_HI                             ; CFAE 85 17                    ..
        jsr     CALC_PLAYER_SHOT_LENGTH                           ; CFB0 20 67 D0                  g.
        jsr     DRAW_VALUE_DECIMAL                           ; CFB3 20 F9 CF                  ..
		lda     #$06                            ; CFB6 A9 06                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; CFB8 20 8F CC                  ..
        rts                                     ; CFBB 60                       `

; ----------------------------------------------------------------------------
DRAW_SHOP_PRICES:
		; set PPU write location
        lda     #$47                            ; CFBC A9 47                    .G
        sta     PPU_WRITE_LO                             ; CFBE 85 16                    ..
        lda     #$22                            ; CFC0 A9 22                    ."
        sta     PPU_WRITE_HI                             ; CFC2 85 17                    ..
        lda     SCROLL_X_HI                             ; CFC4 A5 7C                    .|
        and     #$10                            ; CFC6 29 10                    ).
        beq     LCFD7                           ; CFC8 F0 0D                    ..
        clc                                     ; CFCA 18                       .
        lda     #$00                            ; CFCB A9 00                    ..
        adc     PPU_WRITE_LO                             ; CFCD 65 16                    e.
        sta     PPU_WRITE_LO                             ; CFCF 85 16                    ..
        lda     #$04                            ; CFD1 A9 04                    ..
        adc     PPU_WRITE_HI                             ; CFD3 65 17                    e.
        sta     PPU_WRITE_HI                             ; CFD5 85 17                    ..
LCFD7:
		; write left item
        lda     SHOP_LEFT_ITEM_COST                             ; CFD7 A5 81                    ..
        jsr     DRAW_VALUE_DECIMAL                           ; CFD9 20 F9 CF                  ..
        lda     #$06                            ; CFDC A9 06                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; CFDE 20 8F CC                  ..
        
		; right item is x0E half-tiles to the right
		clc                                     ; CFE1 18                       .
        lda     #$0E                            ; CFE2 A9 0E                    ..
        adc     PPU_WRITE_LO                             ; CFE4 65 16                    e.
        sta     PPU_WRITE_LO                             ; CFE6 85 16                    ..
        lda     #$00                            ; CFE8 A9 00                    ..
        adc     PPU_WRITE_HI                             ; CFEA 65 17                    e.
        sta     PPU_WRITE_HI                             ; CFEC 85 17                    ..
        lda     SHOP_RIGHT_ITEM_COST                             ; CFEE A5 83                    ..
		jsr     DRAW_VALUE_DECIMAL                           ; CFF0 20 F9 CF                  ..
			
		; routine 6 / NMI_ROUTINE_DRAW_DECIMAL
		lda     #$06                            ; CFF3 A9 06                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; CFF5 20 8F CC                  ..
        rts                                     ; CFF8 60                       `

; ----------------------------------------------------------------------------
; input a = qty
; output - DECIMAL_ONES_NAME = graphic for the ones value
;          DECIMAL_TENS_NAME = graphic for the tens value
; see NMI_ROUTINE_DRAW_DECIMAL
DRAW_VALUE_DECIMAL:
        ldx     #$D0                            ; CFF9 A2 D0                    ..
        stx     DECIMAL_TENS_NAME                             ; CFFB 86 19                    ..
LCFFD:
        cmp     #$0A                            ; CFFD C9 0A                    ..
        bcc     LD008                           ; CFFF 90 07                    ..
        sbc     #$0A                            ; D001 E9 0A                    ..
        inc     DECIMAL_TENS_NAME                             ; D003 E6 19                    ..
        jmp     LCFFD                           ; D005 4C FD CF                 L..

; ----------------------------------------------------------------------------
LD008:
        adc     #$D0                            ; D008 69 D0                    i.
        sta     DECIMAL_ONES_NAME                             ; D00A 85 18                    ..
        lda     DECIMAL_TENS_NAME                             ; D00C A5 19                    ..
        cmp     #$D0                            ; D00E C9 D0                    ..
        bne     LD016                           ; D010 D0 04                    ..
        lda     #$C0                            ; D012 A9 C0                    ..
        sta     DECIMAL_TENS_NAME                             ; D014 85 19                    ..
LD016:
        rts                                     ; D016 60                       `

; ----------------------------------------------------------------------------
; input: a=inventory item id (0-15)
; a is used to shift values from TBL_PLAYER_USABLE_ITEMS table
; output is the carry value: set if item is usable, clear if not
CHECK_ITEM_USABLE_FOR_PLAYER:
		; save a, player_id*2-->x
        pha                                     ; D017 48                       H
        lda     PLAYER_ID                             ; D018 A5 40                    .@
        asl     a                               ; D01A 0A                       .
        tax                                     ; D01B AA                       .
        pla                                     ; D01C 68                       h
        cmp     #$08                            ; D01D C9 08                    ..
        
		; branch if a<8
		bcc     LD022                           ; D01F 90 01                    ..
        
		; a >= 8; inc x - use player's 2nd byte in the table b/c item is in bottom row
		inx                                     ; D021 E8                       .
LD022:
        ; y=a%8+1 starting value; basically the item ID % 8 (0-7) is the position of the 
		; relevant bit that tells us if we can use that item. So we loop to left shift 
		; that bit into the carry for use by the caller
		and     #$07                            ; D022 29 07                    ).
        tay                                     ; D024 A8                       .
        iny                                     ; D025 C8                       .
        
		; grab player-indexed table info
		lda     TBL_PLAYER_USABLE_ITEMS,x                         ; D026 BD BB FF                 ...
LD029:
		; y=# of shifts on table info
        asl     a                               ; D029 0A                       .
        dey                                     ; D02A 88                       .
        
		; loop while y>0
		bne     LD029                           ; D02B D0 FC                    ..
        rts                                     ; D02D 60                       `

; ----------------------------------------------------------------------------
; input a=new MUSIC_ID; only load if it's changed
LOAD_MUSIC_DATA_IF_NEC:
		; branch (rts) if a = MUSIC_ID
        cmp     MUSIC_ID                             ; D02E C5 8E                    ..
        beq     LD037                           ; D030 F0 05                    ..
        
		; else, save it and call fn
		sta     MUSIC_ID                             ; D032 85 8E                    ..
        jsr     LOAD_MUSIC_DATA                           ; D034 20 08 FC                  ..
LD037:
        rts                                     ; D037 60                       `

; ----------------------------------------------------------------------------
; return - carry clear if magic used due to high jump boots
CALC_PLAYER_JUMP_FRAMES:
        ldx     CUR_EQUIP_SLOT_SELECTED                             ; D038 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; D03A B5 51                    .Q
        cmp     #INV_ITEM_JUMP_BOOTS                            ; D03C C9 06                    ..
        
		; branch if not wearing high jump boots
		bne     LD04D                           ; D03E D0 0D                    ..
        
		; wearing boots, but check magic...
		lda     PLAYER_MAGIC                             ; D040 A5 59                    .Y
        
		; branch if no magic - normal jump for you!
		beq     LD04D                           ; D042 F0 09                    ..
        
		; we have magic - higher jump
		lda     PLAYER_JUMP_FRAMES                             ; D044 A5 5C                    .\
        lsr     a                               ; D046 4A                       J
        lsr     a                               ; D047 4A                       J
        
		; high jump - use magic
		clc                                     ; D048 18                       .
        adc     PLAYER_JUMP_FRAMES                             ; D049 65 5C                    e\
        clc                                     ; D04B 18                       .
        rts                                     ; D04C 60                       `

; ----------------------------------------------------------------------------
LD04D:
        ; normal jump - don't use magic
		lda     PLAYER_JUMP_FRAMES                             ; D04D A5 5C                    .\
        sec                                     ; D04F 38                       8
        rts                                     ; D050 60                       `

; ----------------------------------------------------------------------------
; return - carry clear if magic used due to knuckle
CALC_PLAYER_SHOT_POWER:
		; check for knuckle selected
		ldx     CUR_EQUIP_SLOT_SELECTED                             ; D051 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; D053 B5 51                    .Q
        cmp     #INV_ITEM_KNUCKLE                            ; D055 C9 08                    ..
        
		; branch if not using knuckle
		bne     LD063                           ; D057 D0 0A                    ..
        
		; branch if no magic
		lda     PLAYER_MAGIC                             ; D059 A5 59                    .Y
		beq     LD063                           ; D05B F0 06                    ..
        
		; we have magic; shot power *= 4
		lda     PLAYER_SHOT_POWER                             ; D05D A5 5D                    .]
        asl     a                               ; D05F 0A                       .
        asl     a                               ; D060 0A                       .
        
		; use magic
		clc                                     ; D061 18                       .
        rts                                     ; D062 60                       `

; ----------------------------------------------------------------------------
LD063:
		; don't use magic
        lda     PLAYER_SHOT_POWER                             ; D063 A5 5D                    .]
        sec                                     ; D065 38                       8
        rts                                     ; D066 60                       `

; ----------------------------------------------------------------------------
; return - carry clear if magic used due to rod
;          a = shot length
CALC_PLAYER_SHOT_LENGTH:
		; check for rod - double shot length
        ldx     CUR_EQUIP_SLOT_SELECTED                             ; D067 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; D069 B5 51                    .Q
        cmp     #INV_ITEM_ROD                            ; D06B C9 09                    ..
        
		; branch if rod not equipped or magic empty
		bne     LD078                           ; D06D D0 09                    ..
        lda     PLAYER_MAGIC                             ; D06F A5 59                    .Y
        beq     LD078                           ; D071 F0 05                    ..
        
		; rod equipped, we have magic, shot length *= 2
		lda     PLAYER_SHOT_LENGTH                             ; D073 A5 5F                    ._
        asl     a                               ; D075 0A                       .
        
		; long shot - use magic
		clc                                     ; D076 18                       .
        rts                                     ; D077 60                       `

; ----------------------------------------------------------------------------
LD078:
        ; normal length - no magic use
		lda     PLAYER_SHOT_LENGTH                             ; D078 A5 5F                    ._
        sec                                     ; D07A 38                       8
        rts                                     ; D07B 60                       `

; ----------------------------------------------------------------------------
; hide all sprites from $0280 above
HIDE_SPRITES_280_UP:
        lda     #OFFSCREEN_Y                            ; D07C A9 EF                    ..
        ldx     #$80                            ; D07E A2 80                    ..
LD080:
        sta     SPRITE_0_Y,x                         ; D080 9D 00 02                 ...
        inx                                     ; D083 E8                       .
        inx                                     ; D084 E8                       .
        inx                                     ; D085 E8                       .
        inx                                     ; D086 E8                       .
        bne     LD080                           ; D087 D0 F7                    ..
        rts                                     ; D089 60                       `

; ----------------------------------------------------------------------------
; sets each OBJ_GENERAL_TYPE to 0 (empty), and OBJ_MISC_CTR to 2; resets CTR_E9 to 0
CLEAR_ALL_OBJECTS:
        ldy     #$10                            ; D08A A0 10                    ..
        ldx     #$00                            ; D08C A2 00                    ..
LD08E:
        lda     #OBJ_GEN_TYPE_BLANK                            ; D08E A9 00                    ..
        sta     OBJ_GENERAL_TYPE,x                         ; D090 9D 01 04                 ...
        lda     #$02                            ; D093 A9 02                    ..
        sta     OBJ_MISC_CTR,x                         ; D095 9D 06 04                 ...
        
		; x incr by 0x10 each loop, y dec by 1
		txa                                     ; D098 8A                       .
        clc                                     ; D099 18                       .
        adc     #$10                            ; D09A 69 10                    i.
        tax                                     ; D09C AA                       .
        dey                                     ; D09D 88                       .
        
		; loop while y>0
		bne     LD08E                           ; D09E D0 EE                    ..
        lda     #$00                            ; D0A0 A9 00                    ..
        sta     CTR_E9                             ; D0A2 85 E9                    ..
        rts                                     ; D0A4 60                       `

; ----------------------------------------------------------------------------
; save the player's items, gold & keys for later restoration if they die
SAVE_PLAYER_HOME_STATE:
        ldx     #$07                            ; D0A5 A2 07                    ..
LD0A7:
        lda     CURRENT_STATE_EXTANT_TREASURES,x                         ; D0A7 BD 00 03                 ...
        sta     HOME_STATE_EXTANT_TREASURES,x                         ; D0AA 9D 08 03                 ...
        dex                                     ; D0AD CA                       .
        bpl     LD0A7                           ; D0AE 10 F7                    ..
        ldx     #$0F                            ; D0B0 A2 0F                    ..
LD0B2:
        lda     PLAYER_INVENTORY,x                           ; D0B2 B5 60                    .`
        sta     HOME_STATE_INVENTORY,x                         ; D0B4 9D 10 03                 ...
        dex                                     ; D0B7 CA                       .
        bpl     LD0B2                           ; D0B8 10 F8                    ..
        lda     PLAYER_GOLDS                             ; D0BA A5 5A                    .Z
        sta     HOME_STATE_GOLDS                           ; D0BC 8D 21 03                 .!.
        lda     PLAYER_KEYS                             ; D0BF A5 5B                    .[
        sta     HOME_STATE_KEYS                           ; D0C1 8D 20 03                 . .
        rts                                     ; D0C4 60                       `

; ----------------------------------------------------------------------------
; restore items, gold, keys the player last had on a home visit
RESTORE_PLAYER_HOME_STATE:
        ldx     #$07                            ; D0C5 A2 07                    ..
LD0C7:
        lda     HOME_STATE_EXTANT_TREASURES,x                         ; D0C7 BD 08 03                 ...
        sta     CURRENT_STATE_EXTANT_TREASURES,x                         ; D0CA 9D 00 03                 ...
        dex                                     ; D0CD CA                       .
        bpl     LD0C7                           ; D0CE 10 F7                    ..
        ldx     #$0F                            ; D0D0 A2 0F                    ..
LD0D2:
        lda     HOME_STATE_INVENTORY,x                         ; D0D2 BD 10 03                 ...
        sta     PLAYER_INVENTORY,x                           ; D0D5 95 60                    .`
        dex                                     ; D0D7 CA                       .
        bpl     LD0D2                           ; D0D8 10 F8                    ..
        lda     HOME_STATE_GOLDS                           ; D0DA AD 21 03                 .!.
        sta     PLAYER_GOLDS                             ; D0DD 85 5A                    .Z
        lda     HOME_STATE_KEYS                           ; D0DF AD 20 03                 . .
        sta     PLAYER_KEYS                             ; D0E2 85 5B                    .[
        rts                                     ; D0E4 60                       `

; ----------------------------------------------------------------------------
; loops through the buffered password data 4 bytes at a time and convert the password
; bytes into bytes in the graphics buffer for display
DRAW_PASSWORD_SCREEN:
        ldy     #$1F                            ; D0E5 A0 1F                    ..
        ldx     #$26                            ; D0E7 A2 26                    .&
LD0E9:
        lda     PASSWORD_BUFFER,y                         ; D0E9 B9 22 03                 .".
        ora     #$80                            ; D0EC 09 80                    ..
        cmp     #$A0                            ; D0EE C9 A0                    ..
        bcc     LD0F4                           ; D0F0 90 02                    ..
        lda     #$7F                            ; D0F2 A9 7F                    ..
LD0F4:
        sta     PASSWORD_GRAPHICS_BUFFER,x                         ; D0F4 9D 62 03                 .b.
        dex                                     ; D0F7 CA                       .
        dey                                     ; D0F8 88                       .
        lda     PASSWORD_BUFFER,y                         ; D0F9 B9 22 03                 .".
        ora     #$80                            ; D0FC 09 80                    ..
        cmp     #$A0                            ; D0FE C9 A0                    ..
        bcc     LD104                           ; D100 90 02                    ..
        lda     #$7F                            ; D102 A9 7F                    ..
LD104:
        sta     PASSWORD_GRAPHICS_BUFFER,x                         ; D104 9D 62 03                 .b.
        dex                                     ; D107 CA                       .
        dey                                     ; D108 88                       .
        lda     PASSWORD_BUFFER,y                         ; D109 B9 22 03                 .".
        ora     #$80                            ; D10C 09 80                    ..
        cmp     #$A0                            ; D10E C9 A0                    ..
        bcc     LD114                           ; D110 90 02                    ..
        lda     #$7F                            ; D112 A9 7F                    ..
LD114:
        sta     PASSWORD_GRAPHICS_BUFFER,x                         ; D114 9D 62 03                 .b.
        dex                                     ; D117 CA                       .
        dey                                     ; D118 88                       .
        lda     PASSWORD_BUFFER,y                         ; D119 B9 22 03                 .".
        ora     #$80                            ; D11C 09 80                    ..
        cmp     #$A0                            ; D11E C9 A0                    ..
        bcc     LD124                           ; D120 90 02                    ..
        lda     #$7F                            ; D122 A9 7F                    ..
LD124:
        sta     PASSWORD_GRAPHICS_BUFFER,x                         ; D124 9D 62 03                 .b.
        dex                                     ; D127 CA                       .
        dey                                     ; D128 88                       .
        dex                                     ; D129 CA                       .
        
		; loop while x positive
		bpl     LD0E9                           ; D12A 10 BD                    ..
        
		lda     #$13                            ; D12C A9 13                    ..
        sta     PPU_BUFFER_LENGTH                             ; D12E 85 1A                    ..
        
		; not clear what this is for; only place it's directly accessed but may be in a $00 buffer write
		lda     #$00                            ; D130 A9 00                    ..
        sta     MYSTERY_1B                             ; D132 85 1B                    ..
        
		; write 19 bytes from PASSWORD_GRAPHICS_BUFFER to $24e6 (first row of password)
		lda     #$E6                            ; D134 A9 E6                    ..
        sta     PPU_WRITE_LO                             ; D136 85 16                    ..
        lda     #$24                            ; D138 A9 24                    .$
        sta     PPU_WRITE_HI                             ; D13A 85 17                    ..
        lda     #$62                            ; D13C A9 62                    .b
        sta     PPU_BUFFER_LO                             ; D13E 85 18                    ..
        lda     #$03                            ; D140 A9 03                    ..
        sta     PPU_BUFFER_HI                             ; D142 85 19                    ..
        
		; update graphics
		lda     #$05                            ; D144 A9 05                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; D146 20 8F CC                  ..
        
		; write 19 bytes from $0376 to $2506 (2nd row of password)
		lda     #$06                            ; D149 A9 06                    ..
        sta     PPU_WRITE_LO                             ; D14B 85 16                    ..
        lda     #$25                            ; D14D A9 25                    .%
        sta     PPU_WRITE_HI                             ; D14F 85 17                    ..
        lda     #$76                            ; D151 A9 76                    .v
        sta     PPU_BUFFER_LO                             ; D153 85 18                    ..
        lda     #$03                            ; D155 A9 03                    ..
        sta     PPU_BUFFER_HI                             ; D157 85 19                    ..
        
		; update graphics
		lda     #$05                            ; D159 A9 05                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; D15B 20 8F CC                  ..
        rts                                     ; D15E 60                       `

; ----------------------------------------------------------------------------
WIPE_PASSWORD_BUFFER:
        ldx     #$1F                            ; D15F A2 1F                    ..
        lda     #$7F                            ; D161 A9 7F                    ..
LD163:
        sta     PASSWORD_BUFFER,x                         ; D163 9D 22 03                 .".
        dex                                     ; D166 CA                       .
        bpl     LD163                           ; D167 10 FA                    ..
        rts                                     ; D169 60                       `

; ----------------------------------------------------------------------------
; refills player life with the accompanying sound and graphics update
ACTION_ELIXIR:
        ; save invuln ctr
		lda     INVULN_CTR                             ; D16A A5 85                    ..
        pha                                     ; D16C 48                       H
        
		; ensure player is drawn while healing
		lda     #$00                            ; D16D A9 00                    ..
        sta     INVULN_CTR                             ; D16F 85 85                    ..
        jsr     DRAW_PLAYER                           ; D171 20 D8 C1                  ..
LD174:
        ; give 1 pt life, update state bar, play sound
		inc     PLAYER_LIFE                             ; D174 E6 58                    .X
        jsr     EVENT_PLAYER_LIFE_CHANGE                           ; D176 20 B6 CA                  ..
        lda     #SOUND_STAT_FILL_TICK                            ; D179 A9 16                    ..
        sta     NEXT_SOUND_EFFECT                             ; D17B 85 8F                    ..
        
		; 2 frames per life filled
		lda     #$02                            ; D17D A9 02                    ..
        sta     NMI_WAIT_CTR                             ; D17F 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; D181 20 35 C1                  5.
        
		; loop while life not full
		ldx     PLAYER_LIFE                             ; D184 A6 58                    .X
        cpx     #$63                            ; D186 E0 63                    .c
        bcc     LD174                           ; D188 90 EA                    ..
        
		; play sound to indicate we're done
		lda     #SOUND_STAT_FILL_DONE                            ; D18A A9 17                    ..
        sta     NEXT_SOUND_EFFECT                             ; D18C 85 8F                    ..
        
		; wait 10 frames
		lda     #$10                            ; D18E A9 10                    ..
        sta     NMI_WAIT_CTR                             ; D190 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; D192 20 35 C1                  5.
        
		; restore the original invuln_ctr
		pla                                     ; D195 68                       h
        sta     INVULN_CTR                             ; D196 85 85                    ..
        rts                                     ; D198 60                       `

; ----------------------------------------------------------------------------
; refills player magic with the accompanying sound and graphics update
; logic is same as for ACTION_ELIXIR abovd
ACTION_MAGIC_BOTTLE:
        ; avoid flicker while magic filling
		lda     INVULN_CTR                             ; D199 A5 85                    ..
        pha                                     ; D19B 48                       H
        lda     #$00                            ; D19C A9 00                    ..
        sta     INVULN_CTR                             ; D19E 85 85                    ..
        jsr     DRAW_PLAYER                           ; D1A0 20 D8 C1                  ..
LD1A3:
        ; 2 frames per magic pt given
		inc     PLAYER_MAGIC                             ; D1A3 E6 59                    .Y
        jsr     EVENT_PLAYER_MAGIC_CHANGE                           ; D1A5 20 CC CA                  ..
        lda     #SOUND_STAT_FILL_TICK                            ; D1A8 A9 16                    ..
        sta     NEXT_SOUND_EFFECT                             ; D1AA 85 8F                    ..
        lda     #$02                            ; D1AC A9 02                    ..
        sta     NMI_WAIT_CTR                             ; D1AE 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; D1B0 20 35 C1                  5.
        
		; loop until magic full
		ldx     PLAYER_MAGIC                             ; D1B3 A6 59                    .Y
        cpx     #$63                            ; D1B5 E0 63                    .c
        bcc     LD1A3                           ; D1B7 90 EA                    ..
        
		; indicate finished and wait
		lda     #SOUND_STAT_FILL_DONE                            ; D1B9 A9 17                    ..
        sta     NEXT_SOUND_EFFECT                             ; D1BB 85 8F                    ..
        lda     #$10                            ; D1BD A9 10                    ..
        sta     NMI_WAIT_CTR                             ; D1BF 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; D1C1 20 35 C1                  5.
        pla                                     ; D1C4 68                       h
        sta     INVULN_CTR                             ; D1C5 85 85                    ..
        rts                                     ; D1C7 60                       `

; ----------------------------------------------------------------------------
; only called from Reset vector; using PRG CD
RESET_COPY_TABLES_1:
        ldx     #$00                            ; D1C8 A2 00                    ..
LD1CA:
        ; loop to copy 256 bytes to $00 (entire zero page!)
		lda     TBL_PLAYER_DATA_INIT,x                         ; D1CA BD 9F 9B                 ...
        sta     $00,x                           ; D1CD 95 00                    ..
        inx                                     ; D1CF E8                       .
		bne     LD1CA                           ; D1D0 D0 F8                    ..
        ldx     #$3F                            ; D1D2 A2 3F                    .?
LD1D4:
        ; loop to copy 64 bytes to $0100-$013f (values in the stat bar)
		lda     TBL_STATUS_BAR_VALUE_GRAPHICS_INIT,x                         ; D1D4 BD 9E 9C                 ...
        sta     $0100,x                         ; D1D7 9D 00 01                 ...
        dex                                     ; D1DA CA                       .
		bpl     LD1D4                           ; D1DB 10 F7                    ..
       
	    ; loop and write 32 bytes 0x0F to DATA_BUFFER_0180 (wipes palette buffers)
    	lda     #$0F                            ; D1DD A9 0F                    ..
        ldx     #$1F                            ; D1DF A2 1F                    ..
LD1E1:
        sta     DATA_BUFFER_0180,x                         ; D1E1 9D 80 01                 ...
        dex                                     ; D1E4 CA                       .
        bpl     LD1E1                           ; D1E5 10 FA                    ..
        
		ldx     #$00                            ; D1E7 A2 00                    ..
LD1E9:
		; loop and write 256 bytes to CURRENT_STATE_EXTANT_TREASURES - inits 
		; available treasures, home state, password buffers $0300-03ff
        lda     TBL_EXTANT_TREASURE_INIT,x                         ; D1E9 BD 3E 9D                 .>.
        sta     CURRENT_STATE_EXTANT_TREASURES,x                         ; D1EC 9D 00 03                 ...
        inx                                     ; D1EF E8                       .
		bne     LD1E9                           ; D1F0 D0 F7                    ..
        ldx     #$00                            ; D1F2 A2 00                    ..
LD1F4:
        ; loop and write 256 bytes to $0400 - object arrays
		lda     TBL_OBJECT_ARRAY_INIT,x                         ; D1F4 BD C9 9D                 ...
        sta     OBJ_SPRITE,x                         ; D1F7 9D 00 04                 ...
        inx                                     ; D1FA E8                       .
		bne     LD1F4                           ; D1FB D0 F7                    ..
        rts                                     ; D1FD 60                       `

; ----------------------------------------------------------------------------
; NMI and Interrupt vector
NMI_VECTOR:
        ; save a, x, y regs on stack
		pha                                     ; D1FE 48                       H
        txa                                     ; D1FF 8A                       .
        pha                                     ; D200 48                       H
        tya                                     ; D201 98                       .
        pha                                     ; D202 48                       H
        
		; save PPU status, sprite DMA address = $0200
		lda     PPU_STATUS                           ; D203 AD 02 20                 .. 
        sta     PPU_STAT_COPY                             ; D206 85 26                    .&
        lda     #$00                            ; D208 A9 00                    ..
        sta     PPU_OAM_ADDRESS                           ; D20A 8D 03 20                 .. 
        lda     #$02                            ; D20D A9 02                    ..
        sta     OAM_DMA_HI                           ; D20F 8D 14 40                 ..@
        
		; branch if NEXT_NMI_ROUTINE = 0
		lda     NEXT_NMI_ROUTINE                             ; D212 A5 28                    .(
		beq     LD21E                           ; D214 F0 08                    ..
        
		; clear NEXT_NMI_ROUTINE - which some functions wait on in infinite loops
		ldx     #$00                            ; D216 A2 00                    ..
        stx     NEXT_NMI_ROUTINE                             ; D218 86 28                    .(
        
		; branch if NEXT_NMI_ROUTINE was 1-6
		cmp     #$07                            ; D21A C9 07                    ..
		bcc     LD221                           ; D21C 90 03                    ..
LD21E:
		; otherwise, no special routine (0xFF often used for this purpose but 0 has same effect)
        jmp     NMI_FINISH                           ; D21E 4C 51 D3                 LQ.

; ----------------------------------------------------------------------------

; run a routine based on NEXT_NMI_ROUTINE; it gets converted to an index
LD221:
        asl     a                               ; D221 0A                       .
        tax                                     ; D222 AA                       .
        lda     JUMP_TBL_NMI_ROUTINE,x                         ; D223 BD 44 D2                 .D.
        sta     JMP_LO_06                           ; D226 85 06                    ..
        lda     JUMP_TBL_NMI_ROUTINE+1,x                       ; D228 BD 45 D2                 .E.
        sta     JMP_HI_07                             ; D22B 85 07                    ..
        lda     PPU_STATUS                           ; D22D AD 02 20                 .. 
        ldx     PPU_WRITE_HI                             ; D230 A6 17                    ..
        ldy     PPU_WRITE_LO                             ; D232 A4 16                    ..
        stx     PPU_ADDRESS                           ; D234 8E 06 20                 .. 
        sty     PPU_ADDRESS                           ; D237 8C 06 20                 .. 
        
		; set horizontal VRAM advancement and jump to the routine
		lda     PPU_CTRL_COPY                             ; D23A A5 23                    .#
        and     #$04                            ; D23C 29 04                    ).
        sta     PPU_CTRL                           ; D23E 8D 00 20                 .. 
        jmp     (JMP_LO_06)                         ; D241 6C 06 00                 l..

; ----------------------------------------------------------------------------
JUMP_TBL_NMI_ROUTINE:
        ; note: NMI_FINISH also called if NEXT_NMI_ROUTINE not 1-6
		; it's the common end for the NMI without any special routines
		.addr   NMI_FINISH                           ; D244 51 D3                    Q.
        .addr   UNUSED_NMI_ROUTINE_1                           ; D246 52 D2                    R.
        .addr   UPDATE_PALETTES                           ; D248 5F D2                    _.
        
		; write nametable for scrolling update
		.addr   LOAD_TILE_GRAPHICS_FOR_SCROLL                           ; D24A 90 D2                    ..
        
		; update life/magic/golds/keys
		.addr   NMI_ROUTINE_STATUS_BAR_UPDATE                           ; D24C E5 D2                    ..
        
		; used by PLAYER_DEATH_NO_ELIXIR
		.addr   NMI_ROUTINE_WRITE_CREDIT_ROLL                           ; D24E 34 D3                    4.
        
		; routine 6
		.addr   NMI_ROUTINE_DRAW_DECIMAL                           ; D250 44 D3                    D.
; ----------------------------------------------------------------------------

; writes 26 bytes of PPU_BUFFER_LO to PPU_DATA_RW
; doesn't appear to be used?
UNUSED_NMI_ROUTINE_1:
        ldx     PPU_BUFFER_LENGTH                             ; D252 A6 1A                    ..
        lda     PPU_BUFFER_LO                             ; D254 A5 18                    ..
LD256:
        sta     PPU_DATA_RW                           ; D256 8D 07 20                 .. 
        dex                                     ; D259 CA                       .
        bne     LD256                           ; D25A D0 FA                    ..
        jmp     NMI_FINISH                           ; D25C 4C 51 D3                 LQ.

; ----------------------------------------------------------------------------
; NMI routine 2
; palette data read from DATA_BUFFER_0180, 32 bytes
UPDATE_PALETTES:
        ; set write address to $3f00, palettes
		lda     PPU_STATUS                           ; D25F AD 02 20                 .. 
        lda     #$3F                            ; D262 A9 3F                    .?
        sta     PPU_ADDRESS                           ; D264 8D 06 20                 .. 
        lda     #$00                            ; D267 A9 00                    ..
        sta     PPU_ADDRESS                           ; D269 8D 06 20                 .. 

		; loop to write 32 bytes from DATA_BUFFER_0180 to PPU_DATA_RW at $3f00
        ldx     #$20                            ; D26C A2 20                    . 
        ldy     #$00                            ; D26E A0 00                    ..
LD270:
        lda     DATA_BUFFER_0180,y                         ; D270 B9 80 01                 ...
        sta     PPU_DATA_RW                           ; D273 8D 07 20                 .. 
        iny                                     ; D276 C8                       .
        dex                                     ; D277 CA                       .
        bne     LD270                           ; D278 D0 F6                    ..
        
		; write to $3f00
		lda     PPU_STATUS                           ; D27A AD 02 20                 .. 
        lda     #$3F                            ; D27D A9 3F                    .?
        sta     PPU_ADDRESS                           ; D27F 8D 06 20                 .. 
        lda     #$00                            ; D282 A9 00                    ..
        sta     PPU_ADDRESS                           ; D284 8D 06 20                 .. 
        sta     PPU_ADDRESS                           ; D287 8D 06 20                 .. 
        sta     PPU_ADDRESS                           ; D28A 8D 06 20                 .. 
        jmp     NMI_FINISH                           ; D28D 4C 51 D3                 LQ.

; ----------------------------------------------------------------------------
; NMI routine 3
; writes data from buffers at:
; SCROLL_NAME_BUFFER_LEFT_COL,x
; SCROLL_NAME_BUFFER_RIGHT_COL,x
; SCROLL_ATTR_BUFFER_ADDR,x (pairs of bytes)
; inputs: SCROLL_ATTR_BUFFER_ADDR,x is used as PUU LO addr
;         TILE_PPU_WRITE_LO - used as AND for existing VRAM byte, which is then ORA with SCROLL_ATTR_BUFFER_VALUE,x
;         TILE_PPU_WRITE_HI - PPU Hi addr
; called when horiz scroll requires loading some new bg graphics
LOAD_TILE_GRAPHICS_FOR_SCROLL:
        ; VRAM advance vertically (by 32)
		lda     PPU_CTRL_COPY                             ; D290 A5 23                    .#
        ora     #$04                            ; D292 09 04                    ..
        sta     PPU_CTRL                           ; D294 8D 00 20                 .. 
        
		; loop and write 24 bytes from SCROLL_NAME_BUFFER_LEFT_COL,x
		ldx     #$17                            ; D297 A2 17                    ..
LD299:
        lda     SCROLL_NAME_BUFFER_LEFT_COL,x                         ; D299 BD 40 01                 .@.
        sta     PPU_DATA_RW                           ; D29C 8D 07 20                 .. 
        dex                                     ; D29F CA                       .
        bpl     LD299                           ; D2A0 10 F7                    ..
        
		; now write 24 bytes from SCROLL_NAME_BUFFER_RIGHT_COL,x
		ldx     PPU_WRITE_HI                             ; D2A2 A6 17                    ..
        stx     PPU_ADDRESS                           ; D2A4 8E 06 20                 .. 
        
		; use PPU_WRITE_LO+1
		ldx     PPU_WRITE_LO                             ; D2A7 A6 16                    ..
        inx                                     ; D2A9 E8                       .
        stx     PPU_ADDRESS                           ; D2AA 8E 06 20                 .. 
		ldx     #$17                            ; D2AD A2 17                    ..
LD2AF:
        lda     SCROLL_NAME_BUFFER_RIGHT_COL,x                         ; D2AF BD 58 01                 .X.
        sta     PPU_DATA_RW                           ; D2B2 8D 07 20                 .. 
        dex                                     ; D2B5 CA                       .
        bpl     LD2AF                           ; D2B6 10 F7                    ..
        
		; now write 6 pairs of bytes from SCROLL_ATTR_BUFFER_ADDR,x
		; the first (even) byte of each pair is an LO address for the PPU
		; the 2nd (odd) byte is the data byte - applied via ORA to the existing VRAM
		ldx     #$0A                            ; D2B8 A2 0A                    ..
LD2BA:
        ; set the PPU write address from TILE_PPU_WRITE_HI and SCROLL_ATTR_BUFFER_ADDR,x
		ldy     TILE_PPU_WRITE_HI                             ; D2BA A4 19                    ..
        sty     PPU_ADDRESS                           ; D2BC 8C 06 20                 .. 
        ldy     SCROLL_ATTR_BUFFER_ADDR,x                         ; D2BF BC 70 01                 .p.
        sty     PPU_ADDRESS                           ; D2C2 8C 06 20                 .. 
        
		; read current VRAM value (done twice as first read gives garbage value due to hardware/bus limitations)
		; see https://www.nesdev.org/wiki/PPU_registers#PPUDATA_-_VRAM_data_($2007_read/write)
		lda     PPU_DATA_RW                           ; D2C5 AD 07 20                 .. 
        lda     PPU_DATA_RW                           ; D2C8 AD 07 20                 .. 
        
		; anyway, whatever we see in VRAM, we AND with TILE_PPU_WRITE_LO then ORA with SCROLL_ATTR_BUFFER_VALUE,x and then write it back
		and     TILE_PPU_WRITE_LO                             ; D2CB 25 18                    %.
        ora     SCROLL_ATTR_BUFFER_VALUE,x                         ; D2CD 1D 71 01                 .q.
        
		; set the PPU address again
		ldy     TILE_PPU_WRITE_HI                             ; D2D0 A4 19                    ..
        sty     PPU_ADDRESS                           ; D2D2 8C 06 20                 .. 
        ldy     SCROLL_ATTR_BUFFER_ADDR,x                         ; D2D5 BC 70 01                 .p.
        sty     PPU_ADDRESS                           ; D2D8 8C 06 20                 .. 
        
		; write it
		sta     PPU_DATA_RW                           ; D2DB 8D 07 20                 .. 
        
		; next pair of bytes
		dex                                     ; D2DE CA                       .
        dex                                     ; D2DF CA                       .
        bpl     LD2BA                           ; D2E0 10 D8                    ..
        jmp     NMI_FINISH                           ; D2E2 4C 51 D3                 LQ.

; ----------------------------------------------------------------------------
; NMI Routine 4
NMI_ROUTINE_STATUS_BAR_UPDATE:
		; original stack pointer moved around and ends up in x0F
		; data is then pulled from $1ff on stack (which overflows to grab $0100 as the first byte) 
		; and written to the PPU - overall writes $0100-13f to the PPU: PLAYER_STAT_BAR_TENS and PLAYER_STAT_BAR_ONES
		; in 4 batches of 16; looks very strange to me but I guess it takes
		; advantage of the status bar data being on the stack
        tsx                                     ; D2E5 BA                       .
        txa                                     ; D2E6 8A                       .
        ldx     #$FF                            ; D2E7 A2 FF                    ..
        txs                                     ; D2E9 9A                       .
        tax                                     ; D2EA AA                       .
        ldy     #$04                            ; D2EB A0 04                    ..
LD2ED:
        pla                                     ; D2ED 68                       h
        sta     PPU_DATA_RW                           ; D2EE 8D 07 20                 .. 
        pla                                     ; D2F1 68                       h
        sta     PPU_DATA_RW                           ; D2F2 8D 07 20                 .. 
        pla                                     ; D2F5 68                       h
        sta     PPU_DATA_RW                           ; D2F6 8D 07 20                 .. 
        pla                                     ; D2F9 68                       h
        sta     PPU_DATA_RW                           ; D2FA 8D 07 20                 .. 
        pla                                     ; D2FD 68                       h
        sta     PPU_DATA_RW                           ; D2FE 8D 07 20                 .. 
        pla                                     ; D301 68                       h
        sta     PPU_DATA_RW                           ; D302 8D 07 20                 .. 
        pla                                     ; D305 68                       h
        sta     PPU_DATA_RW                           ; D306 8D 07 20                 .. 
        pla                                     ; D309 68                       h
        sta     PPU_DATA_RW                           ; D30A 8D 07 20                 .. 
        pla                                     ; D30D 68                       h
        sta     PPU_DATA_RW                           ; D30E 8D 07 20                 .. 
        pla                                     ; D311 68                       h
        sta     PPU_DATA_RW                           ; D312 8D 07 20                 .. 
        pla                                     ; D315 68                       h
        sta     PPU_DATA_RW                           ; D316 8D 07 20                 .. 
        pla                                     ; D319 68                       h
        sta     PPU_DATA_RW                           ; D31A 8D 07 20                 .. 
        pla                                     ; D31D 68                       h
        sta     PPU_DATA_RW                           ; D31E 8D 07 20                 .. 
        pla                                     ; D321 68                       h
        sta     PPU_DATA_RW                           ; D322 8D 07 20                 .. 
        pla                                     ; D325 68                       h
        sta     PPU_DATA_RW                           ; D326 8D 07 20                 .. 
        pla                                     ; D329 68                       h
        sta     PPU_DATA_RW                           ; D32A 8D 07 20                 .. 
        dey                                     ; D32D 88                       .
        bne     LD2ED                           ; D32E D0 BD                    ..
        
		; restore the stack ptr
		txs                                     ; D330 9A                       .
        jmp     NMI_FINISH                           ; D331 4C 51 D3                 LQ.

; ----------------------------------------------------------------------------
; NMI Routine 5 - write credit roll data to PPU
; writes 26 bytes to PPU for credit roll (NMI_ROUTINE_WRITE_CREDIT_ROLL)
NMI_ROUTINE_WRITE_CREDIT_ROLL:
        ldx     PPU_BUFFER_LENGTH                             ; D334 A6 1A                    ..
        ldy     #$00                            ; D336 A0 00                    ..
LD338:
        lda     (PPU_BUFFER_LO),y                         ; D338 B1 18                    ..
        sta     PPU_DATA_RW                           ; D33A 8D 07 20                 .. 
        iny                                     ; D33D C8                       .
        dex                                     ; D33E CA                       .
        bne     LD338                           ; D33F D0 F7                    ..
        jmp     NMI_FINISH                           ; D341 4C 51 D3                 LQ.

; ----------------------------------------------------------------------------
; NMI Routine 6 - prices for the shop, qty for items on start screen
; just writes DECIMAL_TENS_NAME and DECIMAL_ONES_NAME to PPU_DATA_RW
NMI_ROUTINE_DRAW_DECIMAL:
        lda     DECIMAL_TENS_NAME                             ; D344 A5 19                    ..
        sta     PPU_DATA_RW                           ; D346 8D 07 20                 .. 
        lda     DECIMAL_ONES_NAME                             ; D349 A5 18                    ..
        sta     PPU_DATA_RW                           ; D34B 8D 07 20                 .. 
        jmp     NMI_FINISH                           ; D34E 4C 51 D3                 LQ.

; ----------------------------------------------------------------------------
; the NMI's common final cleanup routine
NMI_FINISH:
        jsr     MMC_SET_ALL_BANKS                           ; D351 20 1D D4                  ..
        lda     PPU_STATUS                           ; D354 AD 02 20                 .. 
        jsr     WRITE_PPU_REGS_AND_PLAY_SOUND                           ; D357 20 6E D3                  n.
        
		; decrement wait ctr if non-zero
		lda     NMI_WAIT_CTR                             ; D35A A5 36                    .6
        beq     LD360                           ; D35C F0 02                    ..
        dec     NMI_WAIT_CTR                             ; D35E C6 36                    .6
LD360:
        ; update nmi-based counters
		jsr     UPDATE_FRAME_COUNTER                           ; D360 20 08 D4                  ..
        
		; restore bank, registers
		lda     LAST_BANK_UPDATED                             ; D363 A5 25                    .%
        sta     MAPPER_BANK_SELECT                           ; D365 8D 00 80                 ...
        pla                                     ; D368 68                       h
        tay                                     ; D369 A8                       .
        pla                                     ; D36A 68                       h
        tax                                     ; D36B AA                       .
        pla                                     ; D36C 68                       h
        rti                                     ; D36D 40                       @

; ----------------------------------------------------------------------------
; Called from NMI_FINISH
; restore prior values of PPU_CTRL, PPU_MASK; update the scroll registers
; update the status bar if needed
; finally, runs the sound code
WRITE_PPU_REGS_AND_PLAY_SOUND:
        lda     PPU_MASK_COPY                             ; D36E A5 24                    .$
        sta     PPU_MASK                           ; D370 8D 01 20                 .. 
        
		; restore PPU_CTRL, keeping current nametable selection
		lda     PPU_CTRL_COPY                             ; D373 A5 23                    .#
        and     #$FE                            ; D375 29 FE                    ).
        ora     PPU_NAMETABLE_SELECT                             ; D377 05 1D                    ..
        sta     PPU_CTRL_COPY                             ; D379 85 23                    .#
        sta     PPU_CTRL                           ; D37B 8D 00 20                 .. 
        
		; write scroll values
		ldx     PPU_SCROLL_X                             ; D37E A6 1C                    ..
        ldy     PPU_SCROLL_Y                             ; D380 A4 1E                    ..
        stx     PPU_SCROLL                           ; D382 8E 05 20                 .. 
        sty     PPU_SCROLL                           ; D385 8C 05 20                 .. 
        
		; branch if PPU_STATUS_BAR_GRAPHICS_FLAG = 0
		lda     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; D388 A5 29                    .)
        beq     LD3BE                           ; D38A F0 32                    .2
        
		; otherwise, set PPU_CTRL AND PPU_SCROLL for a status bar update
		lda     PPU_STATUS                           ; D38C AD 02 20                 .. 
        lda     PPU_CTRL_COPY                             ; D38F A5 23                    .#
        
		; force nametable $2000
		and     #$FE                            ; D391 29 FE                    ).
        
		; scroll at 0, xC4 - bottom of nametable below regular dungeon names
		ldx     #$00                            ; D393 A2 00                    ..
        ldy     #$C4                            ; D395 A0 C4                    ..
        sta     PPU_CTRL                           ; D397 8D 00 20                 .. 
        stx     PPU_SCROLL                           ; D39A 8E 05 20                 .. 
        sty     PPU_SCROLL                           ; D39D 8C 05 20                 .. 
        
		; set mapper banks 1, 4, 5 - background, item & misc sprites
		lda     #BANK_SELECT_BG_1                            ; D3A0 A9 01                    ..
        sta     MAPPER_BANK_SELECT                           ; D3A2 8D 00 80                 ...
        lda     #$16                            ; D3A5 A9 16                    ..
        sta     MAPPER_BANK_VALUE                           ; D3A7 8D 01 80                 ...
        lda     #BANK_SELECT_SPRITES_2                            ; D3AA A9 04                    ..
        sta     MAPPER_BANK_SELECT                           ; D3AC 8D 00 80                 ...
        lda     #$3E                            ; D3AF A9 3E                    .>
        sta     MAPPER_BANK_VALUE                           ; D3B1 8D 01 80                 ...
        lda     #BANK_SELECT_SPRITES_3                            ; D3B4 A9 05                    ..
        sta     MAPPER_BANK_SELECT                           ; D3B6 8D 00 80                 ...
        lda     #$3F                            ; D3B9 A9 3F                    .?
        sta     MAPPER_BANK_VALUE                           ; D3BB 8D 01 80                 ...
LD3BE:
		; update the sound
        jsr     SOUND_MAIN                           ; D3BE 20 9A F8                  ..
        
		; branch if PPU_STATUS_BAR_GRAPHICS_FLAG <> 0
		lda     PPU_STATUS_BAR_GRAPHICS_FLAG                             ; D3C1 A5 29                    .)
        bne     SPRITE_0_AND_RESTORE_STATE                           ; D3C3 D0 01                    ..
        rts                                     ; D3C5 60                       `

; ----------------------------------------------------------------------------

; waits for new sprite 0 hit then restores PPU/banks to state before status bar update section above
SPRITE_0_AND_RESTORE_STATE:
		; overall, looks like this waits for a new sprite 0 hit
		; loop if sprite 0 hit
        bit     PPU_STATUS                           ; D3C6 2C 02 20                 ,. 
        bvs     SPRITE_0_AND_RESTORE_STATE                           ; D3C9 70 FB                    p.
LD3CB:
		; now branch if sprite 0 is hit
        bit     PPU_STATUS                           ; D3CB 2C 02 20                 ,. 
        bvs     LD3D5                           ; D3CE 70 05                    p.
        
		; else loop while it is clear
		bit     PPU_STATUS                           ; D3D0 2C 02 20                 ,. 
        bvc     LD3CB                           ; D3D3 50 F6                    P.
LD3D5:
		; loop and waste a little time?
        ldx     #$12                            ; D3D5 A2 12                    ..
LD3D7:
        dex                                     ; D3D7 CA                       .
        bne     LD3D7                           ; D3D8 D0 FD                    ..
        
		; set PPU_CTRL and PPU_SCROLL (x then y)
		; then restore bg1 and item/misc pattern banks 
		lda     #BANK_SELECT_BG_1                            ; D3DA A9 01                    ..
        sta     MAPPER_BANK_SELECT                           ; D3DC 8D 00 80                 ...
        
		lda     PPU_CTRL_COPY                             ; D3DF A5 23                    .#
        ldx     PPU_SCROLL_X                             ; D3E1 A6 1C                    ..
        ldy     PPU_SCROLL_Y                             ; D3E3 A4 1E                    ..
        
		sta     PPU_CTRL                           ; D3E5 8D 00 20                 .. 
        stx     PPU_SCROLL                           ; D3E8 8E 05 20                 .. 
        sty     PPU_SCROLL                           ; D3EB 8C 05 20                 .. 
        
		lda     CHR_BANK_BG_1                             ; D3EE A5 2B                    .+
        sta     MAPPER_BANK_VALUE                           ; D3F0 8D 01 80                 ...
        
		lda     #BANK_SELECT_SPRITES_2                            ; D3F3 A9 04                    ..
        sta     MAPPER_BANK_SELECT                           ; D3F5 8D 00 80                 ...
        lda     CHR_BANK_SPRITES_02                             ; D3F8 A5 2E                    ..
        sta     MAPPER_BANK_VALUE                           ; D3FA 8D 01 80                 ...
        
		lda     #BANK_SELECT_SPRITES_3                            ; D3FD A9 05                    ..
        sta     MAPPER_BANK_SELECT                           ; D3FF 8D 00 80                 ...
        lda     CHR_BANK_SPRITES_03                             ; D402 A5 2F                    ./
        sta     MAPPER_BANK_VALUE                           ; D404 8D 01 80                 ...
        rts                                     ; D407 60                       `

; ----------------------------------------------------------------------------
UPDATE_FRAME_COUNTER:
        ; dec the frame ctr and branch if 0, else rts
		dec     FRAME_CTR                             ; D408 C6 84                    ..
        beq     DECREMENT_PER_SECOND_COUNTERS                           ; D40A F0 01                    ..
        rts                                     ; D40C 60                       `

; ----------------------------------------------------------------------------
; decrement the 8 counters starting with INVULN_CTR that are updated every time FRAME_CTR hits 0, i.e. 
; once per second. Things like invulnerability, scrolls, etc.
DECREMENT_PER_SECOND_COUNTERS:
		; FRAME_CTR = 0
        ldx     #$07                            ; D40D A2 07                    ..
LD40F:
        lda     INVULN_CTR,x                           ; D40F B5 85                    ..
        
		; branch if INVULN_CTR,x = 0
		beq     LD415                           ; D411 F0 02                    ..
        
		; else dec INVULN_CTR,x
		dec     INVULN_CTR,x                           ; D413 D6 85                    ..
LD415:
		; loop while x >= 0 (8 times)
        dex                                     ; D415 CA                       .
        bpl     LD40F                           ; D416 10 F7                    ..
        
		; reset frame ctr to 60
		lda     #$3C                            ; D418 A9 3C                    .<
        sta     FRAME_CTR                             ; D41A 85 84                    ..
        rts                                     ; D41C 60                       `

; ----------------------------------------------------------------------------
; set each MMC bank based on values in the MMC_BANKS array
MMC_SET_ALL_BANKS:
        ldx     #$07                            ; D41D A2 07                    ..
LD41F:
        lda     MMC_BANKS,x                           ; D41F B5 2A                    .*
        stx     MAPPER_BANK_SELECT                           ; D421 8E 00 80                 ...
        sta     MAPPER_BANK_VALUE                           ; D424 8D 01 80                 ...
        dex                                     ; D427 CA                       .
        bpl     LD41F                           ; D428 10 F5                    ..
        rts                                     ; D42A 60                       `

; ----------------------------------------------------------------------------
; process the player - respond to any input, handle item effects, take damage, etc.
UPDATE_PLAYER:
        lda     #$FF                            ; D42B A9 FF                    ..
        sta     CUR_OBJ_SLOT_NUM                             ; D42D 85 E3                    ..
        
		lda     BOSS_FIGHT_OVER_FLAG                             ; D42F A5 EB                    ..
        beq     LD436                           ; D431 F0 03                    ..
        
		; BOSS_FIGHT_OVER_FLAG <> 0 - jump
		jmp     END_BOSS_FIGHT                           ; D433 4C 41 D6                 LA.

; ----------------------------------------------------------------------------
LD436:
        jsr     CHECK_START_DRAGON_FIGHT                           ; D436 20 4F D6                  O.
      
		; note CHECK_START_DRAGON_FIGHT does NOT return here if the dragon fight starts
		; so if we reach this, we are NOT fighting the dragon
	  
		; branch if start not pressed
		lda     JOYPAD_INPUT                             ; D439 A5 20                    . 
        and     #BTN_START                            ; D43B 29 10                    ).
        beq     LD442                           ; D43D F0 03                    ..
        
		; start pressed
		jmp     GAMEPLAY_SHOW_ITEM_SCREEN                           ; D43F 4C 0F E0                 L..

; ----------------------------------------------------------------------------
; normal play, select not pressed, no special boss transitions
LD442:
		; equipped item effects
        jsr     HANDLE_EQUIPPED_ITEM                           ; D442 20 96 D5                  ..
        
		; branch if PLAYER_HARD_LANDING_CTR = 0
		lda     PLAYER_HARD_LANDING_CTR                             ; D445 A5 46                    .F
        beq     LD44F                           ; D447 F0 06                    ..
        
		; PLAYER_HARD_LANDING_CTR <> 0; decrement it and clear the joypad - ignore input during a hard landing
		dec     PLAYER_HARD_LANDING_CTR                             ; D449 C6 46                    .F
        lda     #$00                            ; D44B A9 00                    ..
        sta     JOYPAD_INPUT                             ; D44D 85 20                    . 
LD44F:
		; branch if not pochi
        lda     PLAYER_ID                             ; D44F A5 40                    .@
        cmp     #PLAYER_POCHI                            ; D451 C9 04                    ..
        bne     LD45B                           ; D453 D0 06                    ..
        
		; pochi
		lda     FRAME_CTR                             ; D455 A5 84                    ..
        and     #$07                            ; D457 29 07                    ).

		; for Pochi, every 8th frame cancel updating JOYPAD_INPUT_REFERENCE
		; this enables Pochi to rapid fire by holding down B; likely put in b/c
		; Pochi's attack is so brief it's otherwise hard to effectively use his weapon
		beq     LD45F                           ; D459 F0 04                    ..
LD45B:
        ; else test JOYPAD_INPUT 
        bit     JOYPAD_INPUT                             ; D45B 24 20                    $ 
        
		; branch if B pressed
		bvs     LD465                           ; D45D 70 06                    p.
LD45F:
		; B not pressed
		; clear upper nibble of JOYPAD_INPUT_REFERENCE
        lda     JOYPAD_INPUT_REFERENCE                             ; D45F A5 FD                    ..
        and     #$0F                            ; D461 29 0F                    ).
        sta     JOYPAD_INPUT_REFERENCE                             ; D463 85 FD                    ..
LD465:
        lda     JOYPAD_INPUT                             ; D465 A5 20                    . 
        and     #$0F                            ; D467 29 0F                    ).
        
		; branch if no d-pad input
		beq     LD475                           ; D469 F0 0A                    ..
        
		; we have d-pad input; save it in lower nibble JOYPAD_INPUT_REFERENCE
		sta     SCRATCH_08                             ; D46B 85 08                    ..
        lda     JOYPAD_INPUT_REFERENCE                             ; D46D A5 FD                    ..
        and     #$F0                            ; D46F 29 F0                    ).
        ora     SCRATCH_08                             ; D471 05 08                    ..
        sta     JOYPAD_INPUT_REFERENCE                             ; D473 85 FD                    ..
LD475:
        lda     JOYPAD_INPUT                             ; D475 A5 20                    . 
        and     #BTN_SELECT                            ; D477 29 20                    ) 
        
		; branch if select not pressed
		beq     LD47E                           ; D479 F0 03                    ..
        
		; select pressed
		jmp     GAMEPLAY_SELECT_PRESSED                           ; D47B 4C 5A D5                 LZ.

; ----------------------------------------------------------------------------
LD47E:
	    ; branch if up not pressed
		lda     JOYPAD_INPUT                             ; D47E A5 20                    . 
        and     #BTN_UP                            ; D480 29 08                    ).
        beq     LD487                           ; D482 F0 03                    ..
        jsr     CHECK_SPECIAL_ENTRANCES                           ; D484 20 E2 DC                  ..
LD487:
		; this non-intuitive bit of code calculates the player's speed!
		; start with speed 1, and loop to add 1 speed for each scroll counter that is non-zero
		; if y=5 (4 active scrolls) then it is manually set to 6, so you get extra speed with three
		; monster drop scrolls plus a chest scroll. 
        ldy     #$01                            ; D487 A0 01                    ..
LD489:
        ; starts at first scroll ctr, $88
		lda     CTR_ARMOR_MAGIC,y                           ; D489 B9 87 00                 ...
        beq     LD495                           ; D48C F0 07                    ..
        iny                                     ; D48E C8                       .
        cpy     #$05                            ; D48F C0 05                    ..
        bcc     LD489                           ; D491 90 F6                    ..
        
		; max speed: 3 monster drop scrolls and a chest scroll active!
		ldy     #$06                            ; D493 A0 06                    ..
LD495:
        ; y is input as speed for this call
		jsr     NORMAL_PLAY_CALC_PLAYER_MOVE_VECTOR                           ; D495 20 2C CD                  ,.
        
		; branch if descending
		lda     CTR_PLAYER_DESCENT                             ; D498 A5 4E                    .N
        bne     PLAYER_DESCENDING                           ; D49A D0 26                    .&
        
		; not descending; branch if a jump still ascending
		lda     JUMP_FRAMES_REMAINING                             ; D49C A5 4F                    .O
        bne     LD4A4                           ; D49E D0 04                    ..
        
		; jump neither ascending nor descending; branch if a not pressed
		lda     JOYPAD_INPUT                             ; D4A0 A5 20                    . 
        bpl     LD4AC                           ; D4A2 10 08                    ..
LD4A4:
		; a was pressed, see if we can start a jump
        jsr     PLAYER_START_OR_UPDATE_JUMP                           ; D4A4 20 DF D4                  ..
        lda     #$00                            ; D4A7 A9 00                    ..
        jmp     LD4B0                           ; D4A9 4C B0 D4                 L..

; ----------------------------------------------------------------------------
LD4AC:
		; not jumping
        lda     #$00                            ; D4AC A9 00                    ..
        sta     JUMP_FLAG                             ; D4AE 85 22                    ."
LD4B0:
        ; branch here on frame we do glove clip
		; branch if not halted or changing map levels
		sta     JUMP_FRAMES_REMAINING                             ; D4B0 85 4F                    .O
        jsr     CHECK_PLAYER_HALT_OR_SCROLL                           ; D4B2 20 91 D9                  ..
		bcc     LD4BF                           ; D4B5 90 08                    ..
        
		; we've been halted or are changing map levels
		; branch (ok to move) if neither aligned with block or straddling blocks near the middle
		jsr     CHECK_PLAYER_BLOCK_ALIGNMENT                           ; D4B7 20 90 DF                  ..       
		bcc     LD4BF                           ; D4BA 90 03                    ..
        
		; otherwise, jump
		jmp     PLAYER_KILL_JUMP                           ; D4BC 4C 4E D5                 LN.

; ----------------------------------------------------------------------------
LD4BF:
        jmp     PLAYER_MOVE_TO_TEMP_POS                           ; D4BF 4C 36 D5                 L6.

; ----------------------------------------------------------------------------
; input: a=CTR_PLAYER_DESCENT
PLAYER_DESCENDING:
        ; gravity impact=CTR_PLAYER_DESCENT/4+1
		lsr     a                               ; D4C2 4A                       J
        lsr     a                               ; D4C3 4A                       J
        clc                                     ; D4C4 18                       .
        adc     #$01                            ; D4C5 69 01                    i.
        sta     PLAYER_DY                             ; D4C7 85 4B                    .K
        
		; branch if halted or changing maps
		jsr     CHECK_PLAYER_HALT_OR_SCROLL                           ; D4C9 20 91 D9                  ..
        bcs     LD4D1                           ; D4CC B0 03                    ..
        
		; otherwise change pos
		jmp     PLAYER_MOVE_TO_TEMP_POS                           ; D4CE 4C 36 D5                 L6.

; ----------------------------------------------------------------------------
; player halted while descending; check if vetoing horizontal movement resolves the issue
; if so, accept move. If not, we are hitting something in the y direction and kill our jump
LD4D1:
        lda     #$00                            ; D4D1 A9 00                    ..
        sta     PLAYER_DX                             ; D4D3 85 49                    .I
        sta     PLAYER_HORIZ_DIR                             ; D4D5 85 4A                    .J
        jsr     CHECK_PLAYER_HALT_OR_SCROLL                           ; D4D7 20 91 D9                  ..
        bcc     PLAYER_MOVE_TO_TEMP_POS                           ; D4DA 90 5A                    .Z
        jmp     PLAYER_KILL_JUMP                           ; D4DC 4C 4E D5                 LN.

; ----------------------------------------------------------------------------
; check if we need to start or continue a jump
PLAYER_START_OR_UPDATE_JUMP:
		; branch if a jump ascent currently in progress
        ldx     JUMP_FRAMES_REMAINING                             ; D4DF A6 4F                    .O
        bne     PLAYER_UPDATE_JUMP                           ; D4E1 D0 23                    .#
        
		; branch if not currently jumping - new jump
		lda     JUMP_FLAG                             ; D4E3 A5 22                    ."
        beq     PLAYER_START_JUMP                           ; D4E5 F0 01                    ..
        
		; jump flag set but no jump frames remaining; just rts
		rts                                     ; D4E7 60                       `

; ----------------------------------------------------------------------------
; player starts a new jump
PLAYER_START_JUMP:
		; jump!
        lda     #SOUND_JUMP                            ; D4E8 A9 1B                    ..
        sta     NEXT_SOUND_EFFECT                             ; D4EA 85 8F                    ..
        lda     PLAYER_JUMP_FRAMES                             ; D4EC A5 5C                    .\
        sta     JUMP_FRAMES_REMAINING                             ; D4EE 85 4F                    .O
        ldx     CUR_EQUIP_SLOT_SELECTED                             ; D4F0 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; D4F2 B5 51                    .Q
        cmp     #INV_ITEM_JUMP_BOOTS                            ; D4F4 C9 06                    ..
        
		; branch if not wearing high jump boots
		bne     PLAYER_UPDATE_JUMP                           ; D4F6 D0 0E                    ..
        jsr     DECREMENT_PLAYER_MAGIC                           ; D4F8 20 F0 E7                  ..
        
		; branch if magic empty
		bcs     PLAYER_UPDATE_JUMP                           ; D4FB B0 09                    ..
        
		; boots selected, we had magic
		; increased jump frames by 25%
		lda     JUMP_FRAMES_REMAINING                             ; D4FD A5 4F                    .O
        lsr     a                               ; D4FF 4A                       J
        lsr     a                               ; D500 4A                       J
        clc                                     ; D501 18                       .
        adc     JUMP_FRAMES_REMAINING                             ; D502 65 4F                    eO
        sta     JUMP_FRAMES_REMAINING                             ; D504 85 4F                    .O
PLAYER_UPDATE_JUMP:
        pla                                     ; D506 68                       h
        pla                                     ; D507 68                       h
        
		; update the jump
		; we have 1 fewer frame remaining, decelerating progress upward based on frames left
		lda     #$01                            ; D508 A9 01                    ..
        sta     JUMP_FLAG                             ; D50A 85 22                    ."
        lda     JUMP_FRAMES_REMAINING                             ; D50C A5 4F                    .O
        dec     JUMP_FRAMES_REMAINING                             ; D50E C6 4F                    .O
        lsr     a                               ; D510 4A                       J
        lsr     a                               ; D511 4A                       J
        eor     #$FF                            ; D512 49 FF                    I.
        clc                                     ; D514 18                       .
        adc     #$01                            ; D515 69 01                    i.
        sta     PLAYER_DY                             ; D517 85 4B                    .K
        
		; branch if player hit something or needs to scroll
		jsr     CHECK_PLAYER_HALT_OR_SCROLL                           ; D519 20 91 D9                  ..
        bcs     LD521                           ; D51C B0 03                    ..
        jmp     PLAYER_MOVE_TO_TEMP_POS                           ; D51E 4C 36 D5                 L6.

; ----------------------------------------------------------------------------
LD521:
        ; zero out dx and if we are still hitting something, must be due to vertical movement
		lda     #$00                            ; D521 A9 00                    ..
        sta     PLAYER_DX                             ; D523 85 49                    .I
        sta     PLAYER_HORIZ_DIR                             ; D525 85 4A                    .J
        
		; accept movement if not halted or changing map levels
		jsr     CHECK_PLAYER_HALT_OR_SCROLL                           ; D527 20 91 D9                  ..
        bcc     PLAYER_MOVE_TO_TEMP_POS                           ; D52A 90 0A                    ..
        
		; interesting...not sure what we're doing here to inc jump frames
		; maybe counteract the dec that happens elsewhere, to preserve jump height if we hit edge of a ceiling?
		inc     JUMP_FRAMES_REMAINING                             ; D52C E6 4F                    .O
        jsr     CHECK_PLAYER_BLOCK_ALIGNMENT                           ; D52E 20 90 DF                  ..
        bcc     PLAYER_MOVE_TO_TEMP_POS                           ; D531 90 03                    ..
        jmp     PLAYER_KILL_JUMP                           ; D533 4C 4E D5                 LN.

; ----------------------------------------------------------------------------
; saves the temp pos values to the actual player position vars
PLAYER_MOVE_TO_TEMP_POS:
        lda     TEMP_NEXT_X_LO                           ; D536 A5 0E                    ..
        sta     PX_LO                             ; D538 85 43                    .C
        lda     TEMP_NEXT_X_HI                             ; D53A A5 0F                    ..
        sta     PX_HI                             ; D53C 85 44                    .D
        
		; branch if next y < offscreen value; otherwise set PY=0
		lda     TEMP_NEXT_Y                             ; D53E A5 0A                    ..
        cmp     #OFFSCREEN_Y                            ; D540 C9 EF                    ..
        bcc     LD546                           ; D542 90 02                    ..
        lda     #$00                         ; D544 A9 00                    ..
; ----------------------------------------------------------------------------
LD546:
        sta     PY                             ; D546 85 45                    .E
        jsr     HANDLE_PLAYER_DESCENT                           ; D548 20 DD DB                  ..
        jmp     MAKE_PLAYER_FRAME                           ; D54B 4C AF D8                 L..

; ----------------------------------------------------------------------------
PLAYER_KILL_JUMP:
        lda     #$00                            ; D54E A9 00                    ..
        sta     JUMP_FRAMES_REMAINING                             ; D550 85 4F                    .O
        sta     CTR_PLAYER_DESCENT                             ; D552 85 4E                    .N
        jsr     HANDLE_PLAYER_DESCENT                           ; D554 20 DD DB                  ..
        jmp     MAKE_PLAYER_FRAME                           ; D557 4C AF D8                 L..

; ----------------------------------------------------------------------------
; jump here when select pressed
GAMEPLAY_SELECT_PRESSED:
        lda     #SOUND_SELECT_PRESSED                            ; D55A A9 10                    ..
        sta     NEXT_SOUND_EFFECT                             ; D55C 85 8F                    ..
LD55E:
		; need to release joypad before each change
        jsr     HOLD_FOR_JOYPAD_ACKNOWLEDGE                           ; D55E 20 09 CC                  ..
        and     #$F0                            ; D561 29 F0                    ).
        bne     LD58F                           ; D563 D0 2A                    .*
        lda     JOYPAD_INPUT                             ; D565 A5 20                    . 
        and     #$03                            ; D567 29 03                    ).
        
		; branch if RL not pressed
		beq     LD55E                           ; D569 F0 F3                    ..
        
		; RL pressed
		; good lord, this is a bizarre hack
		; knowing either R/L is pressed, left shift twice to make it U/D
		; then y=1 indicates player speed of 1, and NORMAL_PLAY_CALC_PLAYER_MOVE_VECTOR is lazily used 
		; to convert the (fake) dpad input to a (fake) PLAYER_DY
		asl     JOYPAD_INPUT                             ; D56B 06 20                    . 
        asl     JOYPAD_INPUT                             ; D56D 06 20                    . 
        ldy     #$01                            ; D56F A0 01                    ..
        jsr     NORMAL_PLAY_CALC_PLAYER_MOVE_VECTOR                           ; D571 20 2C CD                  ,.
        
		; basically, if L pressed DY=-1, if R pressed DY=1
		lda     PLAYER_DY                             ; D574 A5 4B                    .K
        clc                                     ; D576 18                       .
        adc     CUR_EQUIP_SLOT_SELECTED                             ; D577 65 55                    eU
        
		; branch if dy + the current slot is negative - default to nothing selected
		; for clarity, 0-2 are the slots from left to right; 3=nothing selected. 
		; so pressing left when slot=0 makes it go negative and we set it to nothing
		; pressing right when slot=3 sets slot=4 and we select slot 0 (leftmost)
		; it all works simple enough in the game, but the code is a handful...
		bmi     EQUIP_SELECT_NOTHING                           ; D579 30 09                    0.
        cmp     #$04                            ; D57B C9 04                    ..
        
		; otherwise, branch if it's <4
		bcc     LD586                           ; D57D 90 07                    ..
        
		; otherwise, it's >=4 and we set it to 0
		lda     #$00                            ; D57F A9 00                    ..
        jmp     LD586                           ; D581 4C 86 D5                 L..

; ----------------------------------------------------------------------------
; update the equip selected and play a sound
EQUIP_SELECT_NOTHING:
        lda     #EQUIP_SLOT_NOTHING_SELECTED                            ; D584 A9 03                    ..
LD586:
        sta     CUR_EQUIP_SLOT_SELECTED                             ; D586 85 55                    .U
        lda     #SOUND_EQUIP_SELECT_TICK                            ; D588 A9 0C                    ..
        sta     NEXT_SOUND_EFFECT                             ; D58A 85 8F                    ..
        jmp     LD55E                           ; D58C 4C 5E D5                 L^.

; ----------------------------------------------------------------------------
; just play the select sound 
LD58F:
        lda     #SOUND_SELECT_PRESSED                            ; D58F A9 10                    ..
        sta     NEXT_SOUND_EFFECT                             ; D591 85 8F                    ..
        jmp     MAKE_PLAYER_FRAME                           ; D593 4C AF D8                 L..

; ----------------------------------------------------------------------------
; special effects and magic use for equipped items
; wings/armor - maintain counter for magic use
; magic bottle - refill magic if empty
; crystal - warp home if selected and not on boss level
; note, the elixir is not handled here - probably b/c the life/death determination needs to be made immediately
; so other updates, etc., don't happen if you're dead.
HANDLE_EQUIPPED_ITEM:
        ldy     CUR_EQUIP_SLOT_SELECTED                             ; D596 A4 55                    .U
        ldx     CUR_EQUIP_ITEMS,y                           ; D598 B6 51                    .Q
        cpx     #INV_ITEM_MATTOCK                            ; D59A E0 02                    ..
        
		; branch if item selected is >= 2 (not armor or wings)
		bcs     LD5BC                           ; D59C B0 1E                    ..
        
		; wearing armor or wings - these drain magic over time!
		lda     CTR_WINGS_MAGIC,x                           ; D59E B5 86                    ..
        
		; branch if counter = 0; else rts - presume to use magic, etc.
		beq     LD5A3                           ; D5A0 F0 01                    ..
        rts                                     ; D5A2 60                       `

; ----------------------------------------------------------------------------
; 0 = value of counter related to armor or wings, whichever is being worn
LD5A3:
        jsr     DECREMENT_PLAYER_MAGIC                           ; D5A3 20 F0 E7                  ..
        
		; branch (preserve armor/wings effect) if we had magic
		bcc     RESET_ARMOR_OR_WING_CTR                           ; D5A6 90 0F                    ..
        
		; carry set - we didn't have magic to maintain item!
		; branch (rts) if CHEAT_STATUS negative or zero
		lda     CHEAT_STATUS                             ; D5A8 A5 37                    .7
        beq     LD5B6                           ; D5AA F0 0A                    ..
        bmi     LD5B6                           ; D5AC 30 08                    0.
        
		; CHEAT_STATUS is positive; set CHEAT_STATUS it to xFD and play a sound
		; it is now negative so will not pass through here again
		lda     #$FD                            ; D5AE A9 FD                    ..
        sta     CHEAT_STATUS                             ; D5B0 85 37                    .7
        lda     #SOUND_CHEAT_MODE                            ; D5B2 A9 1A                    ..
        sta     NEXT_SOUND_EFFECT                             ; D5B4 85 8F                    ..
LD5B6:
        rts                                     ; D5B6 60                       `

; ----------------------------------------------------------------------------
; reset the counter that tracks magic use for armor and wings
RESET_ARMOR_OR_WING_CTR:
        lda     #$02                            ; D5B7 A9 02                    ..
        sta     CTR_WINGS_MAGIC,x                           ; D5B9 95 86                    ..
        rts                                     ; D5BB 60                       `

; ----------------------------------------------------------------------------
; x = selected equipment
LD5BC:
        cpx     #$0B                            ; D5BC E0 0B                    ..
        
		; branch if not the magic bottle
		bne     LD5D2                           ; D5BE D0 12                    ..
        
		; magic bottle - branch if magic empty, else rts
		lda     PLAYER_MAGIC                             ; D5C0 A5 59                    .Y
        beq     LD5C5                           ; D5C2 F0 01                    ..
        rts                                     ; D5C4 60                       `

; ----------------------------------------------------------------------------
; use up the magic bottle b/c we're out of magic
LD5C5:
        ; nuke the bottle from equipment
		ldx     CUR_EQUIP_SLOT_SELECTED                             ; D5C5 A6 55                    .U
        lda     #INV_ITEM_NOTHING                            ; D5C7 A9 FF                    ..
        sta     CUR_EQUIP_ITEMS,x                           ; D5C9 95 51                    .Q
        
		; redraw and then refill magic
		jsr     DRAW_EQUIP_ITEM_CURSOR                           ; D5CB 20 34 C2                  4.
        jsr     ACTION_MAGIC_BOTTLE                           ; D5CE 20 99 D1                  ..
        rts                                     ; D5D1 60                       `

; ----------------------------------------------------------------------------
LD5D2:
        cpx     #$0D                            ; D5D2 E0 0D                    ..
        
		; branch if crystal equipped, else rts
		beq     LD5D7                           ; D5D4 F0 01                    ..
        rts                                     ; D5D6 60                       `

; ----------------------------------------------------------------------------
LD5D7:
        lda     MAP_Y                             ; D5D7 A5 48                    .H
        cmp     #$11                            ; D5D9 C9 11                    ..
        
		; branch if MAP_Y < x11; ordinary dungeon level (0-f) or overworld (x10)
		; note you can use crystal from overworld but it's pretty dumb!
		bcc     LD5E2                           ; D5DB 90 05                    ..
        
		; MAP_Y >= x11; we're on boss level
		; Unselect the crystal without doing anything - rude!
		lda     #EQUIP_SLOT_NOTHING_SELECTED                            ; D5DD A9 03                    ..
        sta     CUR_EQUIP_SLOT_SELECTED                             ; D5DF 85 55                    .U
        rts                                     ; D5E1 60                       `

; ----------------------------------------------------------------------------
LD5E2:
        ; nuke the crystal
		ldx     CUR_EQUIP_SLOT_SELECTED                             ; D5E2 A6 55                    .U
        lda     #INV_ITEM_NOTHING                            ; D5E4 A9 FF                    ..
        sta     CUR_EQUIP_ITEMS,x                           ; D5E6 95 51                    .Q
        
		; redraw, play sound, jump back to overworld
		jsr     DRAW_EQUIP_ITEM_CURSOR                        
		; D5E8 20 34 C2                  4.
        lda     #SOUND_MYRNA_SHOT                            ; D5EB A9 12                    ..
        sta     NEXT_SOUND_EFFECT                             ; D5ED 85 8F                    ..
        jmp     WARP_TO_OVERWORLD                           ; D5EF 4C 66 D8                 Lf.

; ----------------------------------------------------------------------------
        rts                                     ; D5F2 60                       `

; ----------------------------------------------------------------------------
; the crown warp into princess portraits that only Roas can do
; looks up destination map and position in the map meta-data, puts the player
; there and loads the new map
PORTRAIT_WARP:
		; destination info for a map section's portraits are in bytes c-f
        ldy     #MAP_CFG_PORTRAIT_MAP_X                            ; D5F3 A0 0C                    ..
        lda     (MAP_DATA_LO),y                         ; D5F5 B1 77                    .w
        sta     MAP_X                             ; D5F7 85 47                    .G
        iny                                     ; D5F9 C8                       .
        lda     (MAP_DATA_LO),y                         ; D5FA B1 77                    .w
        sta     MAP_Y                             ; D5FC 85 48                    .H
        iny                                     ; D5FE C8                       .
        lda     (MAP_DATA_LO),y                         ; D5FF B1 77                    .w
        sta     PX_HI                             ; D601 85 44                    .D
        
		; set the x scroll based on where player will wind up
		sec                                     ; D603 38                       8
        sbc     #$08                            ; D604 E9 08                    ..
        bcs     LD60A                           ; D606 B0 02                    ..
        lda     #$00                            ; D608 A9 00                    ..
LD60A:
        cmp     #$31                            ; D60A C9 31                    .1
        bcc     LD610                           ; D60C 90 02                    ..
        lda     #$30                            ; D60E A9 30                    .0
LD610:
        sta     SCROLL_X_HI                             ; D610 85 7C                    .|
        lda     #$00                            ; D612 A9 00                    ..
        sta     PX_LO                             ; D614 85 43                    .C
        sta     SCROLL_X_LO                             ; D616 85 7B                    .{
        
		; set the y position and do the teleport!
		iny                                     ; D618 C8                       .
        lda     (MAP_DATA_LO),y                         ; D619 B1 77                    .w
        sta     PY                             ; D61B 85 45                    .E
        jmp     ENTER_MAP_LOCATION                           ; D61D 4C 95 D8                 L..

; ----------------------------------------------------------------------------
; handles the boss fight screen scrolling effect, then loads a map based on how many
; crowns are in inventory. Player then placed on the map (always at same location) and
; we jump there
ENTER_BOSS_FIGHT:
        jsr     BOSS_SCREEN_SCROLL_EFFECT                           ; D620 20 7D D6                  }.
        
		; boss maps are beneath the dungeon and overworld
		lda     #MAP_Y_CROWN_BOSS                            ; D623 A9 11                    ..
        sta     MAP_Y                             ; D625 85 48                    .H
        
		; map chosen based on # of crowns collected
		ldx     PLAYER_INVENTORY_CROWNS                             ; D627 A6 6E                    .n
        dex                                     ; D629 CA                       .
        stx     MAP_X                             ; D62A 86 47                    .G
        lda     #$12                            ; D62C A9 12                    ..
        sta     SCROLL_X_HI                             ; D62E 85 7C                    .|
        
		; place player - odd decision to spawn up on the ceiling!
		lda     #$10                            ; D630 A9 10                    ..
        sta     PY                             ; D632 85 45                    .E
        lda     #$1A                            ; D634 A9 1A                    ..
        sta     PX_HI                             ; D636 85 44                    .D
        lda     #$00                            ; D638 A9 00                    ..
        sta     PX_LO                             ; D63A 85 43                    .C
        sta     SCROLL_X_LO                             ; D63C 85 7B                    .{
        jmp     ENTER_MAP_LOCATION                           ; D63E 4C 95 D8                 L..

; ----------------------------------------------------------------------------
; do the screen scroll effect, set pattern table, jump to overworld
END_BOSS_FIGHT:
		; clear BOSS_FIGHT_OVER_FLAG
        lda     #$00                            ; D641 A9 00                    ..
        sta     BOSS_FIGHT_OVER_FLAG                             ; D643 85 EB                    ..
        jsr     BOSS_SCREEN_SCROLL_EFFECT                           ; D645 20 7D D6                  }.
        
		; set overworld sprite set
		lda     #$3E                            ; D648 A9 3E                    .>
        sta     CHR_BANK_SPRITES_02                             ; D64A 85 2E                    ..
        jmp     WARP_TO_OVERWORLD                           ; D64C 4C 66 D8                 Lf.

; ----------------------------------------------------------------------------
; check if conditions are met to start the dragon/final boss fight
; if not, rts
; if so, set DRAGON_FIGHT_FLAG and pull 2 bytes off the stack to change rts destination; 
; we will resume as if returning from UPDATE_PLAYER within PLAY_A_FRAME, which immediately
; checks the flag and starts the dragon fight. 
CHECK_START_DRAGON_FIGHT:
        ldx     CUR_EQUIP_SLOT_SELECTED                             ; D64F A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; D651 B5 51                    .Q
        cmp     #INV_ITEM_DRAGON_SLAYER                            ; D653 C9 0F                    ..
        
		; branch if dragon slayer not selected
		bne     LD675                           ; D655 D0 1E                    ..
        
		; dragon slayer selected; branch if not in map column 1
		lda     MAP_X                             ; D657 A5 47                    .G
        cmp     #$01                            ; D659 C9 01                    ..
		bne     LD675                           ; D65B D0 18                    ..
        
		; map column 1; branch if not in map row 5
		lda     MAP_Y                             ; D65D A5 48                    .H
        cmp     #$05                            ; D65F C9 05                    ..
        bne     LD675                           ; D661 D0 12                    ..
        
		; branch if SCROLL_X_HI <> x10
		lda     SCROLL_X_HI                             ; D663 A5 7C                    .|
        cmp     #$10                            ; D665 C9 10                    ..
        bne     LD675                           ; D667 D0 0C                    ..
        
		; branch if SCROLL_X_LO <> 0
		lda     SCROLL_X_LO                             ; D669 A5 7B                    .{
        cmp     #$00                            ; D66B C9 00                    ..
        bne     LD675                           ; D66D D0 06                    ..
        
		; branch if PY=xA0 (on ground)
		lda     PY                             ; D66F A5 45                    .E
        cmp     #$A0                            ; D671 C9 A0                    ..
        beq     LD676                           ; D673 F0 01                    ..
LD675:
        rts                                     ; D675 60                       `

; ----------------------------------------------------------------------------
LD676:
		; flags to start dragon fight
		; then pull from stack to return elsewhere
        lda     #$01                            ; D676 A9 01                    ..
        sta     DRAGON_FIGHT_FLAG                             ; D678 85 EC                    ..
        pla                                     ; D67A 68                       h
        pla                                     ; D67B 68                       h
        rts                                     ; D67C 60                       `

; ----------------------------------------------------------------------------
; the crazy accelerating scroll effect entering/leaving boss screens!
BOSS_SCREEN_SCROLL_EFFECT:
        ; hide everything but player, clear invuln, redraw
		jsr     WIPE_SPRITES_EXCEPT_0                           ; D67D 20 75 C3                  u.
        lda     #$00                            ; D680 A9 00                    ..
        sta     INVULN_CTR                             ; D682 85 85                    ..
        jsr     DRAW_PLAYER                           ; D684 20 D8 C1                  ..
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; D687 20 34 C2                  4.
        
		; branch if SCROLL_X_HI < x21
		lda     SCROLL_X_HI                             ; D68A A5 7C                    .|
        cmp     #$21                            ; D68C C9 21                    .!
        bcc     LD692                           ; D68E 90 02                    ..
        
		; SCROLL_X_HI >= x21; set it to 20
		lda     #$20                            ; D690 A9 20                    . 
LD692:
        sta     SCROLL_X_HI                             ; D692 85 7C                    .|
        
		; update PPU addresses, then add x10 to SCROLL_X_HI and do it again?
		jsr     UPDATE_PPU_ADDRESS_FROM_SCROLL                           ; D694 20 6C C7                  l.
        lda     SCROLL_X_HI                             ; D697 A5 7C                    .|
        clc                                     ; D699 18                       .
        adc     #$10                            ; D69A 69 10                    i.
        sta     SCROLL_X_HI                             ; D69C 85 7C                    .|
        jsr     UPDATE_PPU_ADDRESS_FROM_SCROLL                           ; D69E 20 6C C7                  l.
        
		lda     #$01                            ; D6A1 A9 01                    ..
        sta     SCRATCH_08                             ; D6A3 85 08                    ..
LD6A5:
        ldx     #$0C                            ; D6A5 A2 0C                    ..
LD6A7:
        ; increment scroll by SCATCH_08; flip toggle (to swap nametables) if we overflow
		lda     PPU_SCROLL_X                             ; D6A7 A5 1C                    ..
        clc                                     ; D6A9 18                       .
        adc     SCRATCH_08                             ; D6AA 65 08                    e.
        sta     PPU_SCROLL_X                             ; D6AC 85 1C                    ..
        bcc     LD6B6                           ; D6AE 90 06                    ..        
		lda     PPU_NAMETABLE_SELECT                             ; D6B0 A5 1D                    ..
        eor     #$01                            ; D6B2 49 01                    I.
        sta     PPU_NAMETABLE_SELECT                             ; D6B4 85 1D                    ..
LD6B6:
		; wait for an nmi and loop if x-1 <> 0
        lda     #$FF                            ; D6B6 A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; D6B8 20 8F CC                  ..
        dex                                     ; D6BB CA                       .
        bne     LD6A7                           ; D6BC D0 E9                    ..
        
		; x=0; accelerate scroll and loop if SCRATCH_08 = 20 
		inc     SCRATCH_08                             ; D6BE E6 08                    ..
        ldx     SCRATCH_08                             ; D6C0 A6 08                    ..
        cpx     #$20                            ; D6C2 E0 20                    . 
        bcc     LD6A5                           ; D6C4 90 DF                    ..
        
		; scroll speed = 20; we're done scrolling; do the flash effect
		lda     #SOUND_CROSS                            ; D6C6 A9 18                    ..
        sta     NEXT_SOUND_EFFECT                             ; D6C8 85 8F                    ..
        lda     #$FF                            ; D6CA A9 FF                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; D6CC 85 90                    ..
        ldx     #$08                            ; D6CE A2 08                    ..
        jsr     FLASH_EFFECT_C540                           ; D6D0 20 40 C5                  @.
        rts                                     ; D6D3 60                       `

; ----------------------------------------------------------------------------
; check if we need to scroll between map levels - horizontal or vertical
CHECK_MAP_SCROLL:
		; PY<x10, scroll up
        lda     PY                             ; D6D4 A5 45                    .E
        cmp     #$10                            ; D6D6 C9 10                    ..
        bcc     VERTICAL_SCROLL_UP                           ; D6D8 90 5F                    ._
        
		; PY >= xA1; scroll down
		cmp     #$A1                            ; D6DA C9 A1                    ..
        bcs     VERTICAL_SCROLL_DOWN                           ; D6DC B0 72                    .r
        
		; branch (rts) if on overworld - no horizontal scrolling
		ldx     MAP_Y                             ; D6DE A6 48                    .H
        cpx     #$10                            ; D6E0 E0 10                    ..
        beq     RTS_NO_SCROLL                           ; D6E2 F0 4D                    .M
        
		; we're horizontally scrolling; let descent occur and kill invulnerability
		jsr     HANDLE_PLAYER_DESCENT                           ; D6E4 20 DD DB                  ..
		lda     #$00                            ; D6E7 A9 00                    ..
        sta     INVULN_CTR                             ; D6E9 85 85                    ..
        
		; keep only lower 3 bits of PLAYER_FRAME (kills jumping state)
		lda     PLAYER_FRAME                             ; D6EB A5 56                    .V
        and     #$07                            ; D6ED 29 07                    ).
        sta     PLAYER_FRAME                             ; D6EF 85 56                    .V
		
		; if PX_HI = 0, we scroll left
        lda     PX_HI                             ; D6F1 A5 44                    .D
        beq     PREP_LEFT_SCROLL                           ; D6F3 F0 1F                    ..

		; else if it's < x3E, no scroll (rts)
        cmp     #$3E                            ; D6F5 C9 3E                    .>
        bcc     RTS_NO_SCROLL                           ; D6F7 90 38                    .8

		; PX_HI>= x3E; scroll right
        ; branch (no scroll) if MAP_X will be >= 4 (which is OOB)
		ldx     MAP_X                             ; D6F9 A6 47                    .G
        inx                                     ; D6FB E8                       .
        cpx     #$04                            ; D6FC E0 04                    ..
        bcs     RTS_NO_SCROLL                           ; D6FE B0 31                    .1
        
		; we're legal; update MAP_X and position player/scroll at far left side
		stx     MAP_X                             ; D700 86 47                    .G
        lda     #$40                            ; D702 A9 40                    .@
        sta     PLAYER_SPRITE_FLAGS                             ; D704 85 57                    .W
        jsr     DRAW_PLAYER                           ; D706 20 D8 C1                  ..
        lda     #$00                            ; D709 A9 00                    ..
        sta     SCROLL_X_HI                             ; D70B 85 7C                    .|
        sta     PX_LO                             ; D70D 85 43                    .C
        sta     PX_HI                             ; D70F 85 44                    .D
        jmp     HORIZONTAL_SCROLL                           ; D711 4C 72 D7                 Lr.

; ----------------------------------------------------------------------------
PREP_LEFT_SCROLL:
        ; scrolling left, decrease MAP_X and veto if < 0 
		ldx     MAP_X                             ; D714 A6 47                    .G
        dex                                     ; D716 CA                       .
        bmi     RTS_NO_SCROLL                           ; D717 30 18                    0.
        
		; we're legal; update MAP_X and position player/scroll at far right side
		stx     MAP_X                             ; D719 86 47                    .G
        lda     #$00                            ; D71B A9 00                    ..
        sta     PLAYER_SPRITE_FLAGS                             ; D71D 85 57                    .W
        jsr     DRAW_PLAYER                           ; D71F 20 D8 C1                  ..
        lda     #$30                            ; D722 A9 30                    .0
        sta     SCROLL_X_HI                             ; D724 85 7C                    .|
        lda     #$3F                            ; D726 A9 3F                    .?
        sta     PX_HI                             ; D728 85 44                    .D
        lda     #$00                            ; D72A A9 00                    ..
        sta     PX_LO                             ; D72C 85 43                    .C
        jmp     HORIZONTAL_SCROLL                           ; D72E 4C 72 D7                 Lr.

; ----------------------------------------------------------------------------
RTS_NO_SCROLL:
		; no scroll
        clc                                     ; D731 18                       .
        rts                                     ; D732 60                       `

; ----------------------------------------------------------------------------
HEADED_TO_OVERWORLD:
        jmp     WARP_TO_OVERWORLD                           ; D733 4C 66 D8                 Lf.

; ----------------------------------------------------------------------------
HEADED_TO_DUNGEON:
        jmp     ENTER_DUNGEON_FROM_OVERWORLD                           ; D736 4C 83 D8                 L..

; ----------------------------------------------------------------------------
; scrolls to the map level above, if legal
; if MAP_Y=0, handle special case where we jump to the overworld
VERTICAL_SCROLL_UP:
        ; branch (no scroll) if can't scroll up
		jsr     CHECK_CAN_SCROLL_UP                           ; D739 20 87 DC                  ..
        bcc     RTS_NO_SCROLL                           ; D73C 90 F3                    ..
        
		; if scrolling up form MAP_Y = 0 we exit to the overworld
		ldx     MAP_Y                             ; D73E A6 48                    .H
        beq     HEADED_TO_OVERWORLD                           ; D740 F0 F1                    ..
        
		; no scrolling up from the overworld (e.g. with wings?)
		cpx     #$10                            ; D742 E0 10                    ..
        beq     RTS_NO_SCROLL                           ; D744 F0 EB                    ..
        
		; otherwise, scroll up!
		dex                                     ; D746 CA                       .
        stx     MAP_Y                             ; D747 86 48                    .H
        lda     #$B0                            ; D749 A9 B0                    ..
        sta     PY                             ; D74B 85 45                    .E
        jmp     LD761                           ; D74D 4C 61 D7                 La.

; ----------------------------------------------------------------------------
; scrolls to the map level below, if legal
; if in overworld, handle special case where we jump to the dungeon
VERTICAL_SCROLL_DOWN:
        ; branch if in the overworld - will enter dungeon
		ldx     MAP_Y                             ; D750 A6 48                    .H
        cpx     #MAP_Y_OVERWORLD                            ; D752 E0 10                    ..
        beq     HEADED_TO_DUNGEON                           ; D754 F0 E0                    ..
        
		; branch if MAP_Y >= x0F - can't vertically scroll down out of regular dungeon
		inx                                     ; D756 E8                       .
        cpx     #MAP_Y_OVERWORLD                            ; D757 E0 10                    ..
        bcs     RTS_NO_SCROLL                           ; D759 B0 D6                    ..
        
		; otherwise, we're ok for vertical level entry
		stx     MAP_Y                             ; D75B 86 48                    .H
        lda     #$00                            ; D75D A9 00                    ..
        sta     PY                             ; D75F 85 45                    .E
LD761:
        jsr     CLEAR_ALL_OBJECTS                           ; D761 20 8A D0                  ..
        jsr     HIDE_SPRITES_280_UP                           ; D764 20 7C D0                  |.
        jsr     LOAD_MAP_FULL                           ; D767 20 F2 C8                  ..
        jsr     LOAD_GRAPHICS_FOR_MAP_LEVEL                           ; D76A 20 CB C5                  ..
        jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; D76D 20 69 C5                  i.
        sec                                     ; D770 38                       8
        rts                                     ; D771 60                       `

; ----------------------------------------------------------------------------
; handle a left/right horizontal scroll between map levels
; legality is checked prior to calling, and the MAP_X and the new player location (PX_HI, etc) are already set
HORIZONTAL_SCROLL:
        ; clean up and load the next map
		jsr     CLEAR_ALL_OBJECTS                           ; D772 20 8A D0                  ..
        jsr     HIDE_SPRITES_280_UP                           ; D775 20 7C D0                  |.
        lda     #$00                            ; D778 A9 00                    ..
        sta     SCROLL_X_LO                             ; D77A 85 7B                    .{
        jsr     LOAD_MAP_FULL                           ; D77C 20 F2 C8                  ..
        jsr     UPDATE_PPU_ADDRESS_FROM_SCROLL                           ; D77F 20 6C C7                  l.
        jsr     NMI_UPDATE_PALETTE_FROM_BUFFER                           ; D782 20 69 C5                  i.
        
		; if PX_HI <> 0 we're scrolling left - this seems reversed but it's b/c the
		; new PX_HI is set before this function is called
		lda     PX_HI                             ; D785 A5 44                    .D
        bne     LEFT_HORIZONTAL_SCROLL                           ; D787 D0 6F                    .o
        
		; PX_HI = 0; scrolling right
		; set nametable and scroll
		lda     #$FC                            ; D789 A9 FC                    ..
        sta     a:PPU_SCROLL_X                           ; D78B 8D 1C 00                 ...
        lda     #$01                            ; D78E A9 01                    ..
        sta     a:PPU_NAMETABLE_SELECT                           ; D790 8D 1D 00                 ...
        
		; set player sprite x values - right side of screen
		lda     #$F0                            ; D793 A9 F0                    ..
        sta     PLAYER_SPRITE_0_X                           ; D795 8D 13 02                 ...
        lda     #$F8                            ; D798 A9 F8                    ..
        sta     PLAYER_SPRITE_1_X                           ; D79A 8D 17 02                 ...
		
		; outer loop - 16 loops x 1 block
		; player starts at right edge of screen and ends up on left edge, in synch with the new map coming onscreen
		; from the right
		lda     #$0F                            ; D79D A9 0F                    ..
        sta     LOOP_COUNTER_0A                             ; D79F 85 0A                    ..
LD7A1:
        ; inner loop - 4x4px = 1 block
		lda     #$03                             ; D7A1 A9 03                    ..
        sta     SCRATCH_0B                             ; D7A3 85 0B                    ..
LD7A5:
        bne     LD7C3                           ; D7A5 D0 1C                    ..
        
		; nudge player sprite 1 pixel right
		inc     PLAYER_SPRITE_0_X                           ; D7A7 EE 13 02                 ...
        inc     PLAYER_SPRITE_1_X                           ; D7AA EE 17 02                 ...
        
		; branch if not in air
		lda     CTR_PLAYER_DESCENT                             ; D7AD A5 4E                    .N
        ora     JUMP_FRAMES_REMAINING                             ; D7AF 05 4F                    .O
        bne     LD7C3                           ; D7B1 D0 10                    ..
        
		; else revert player sprite to non-jumping version
		lda     PLAYER_SPRITE_0_ID                           ; D7B3 AD 11 02                 ...
        eor     #$04                            ; D7B6 49 04                    I.
        sta     PLAYER_SPRITE_0_ID                           ; D7B8 8D 11 02                 ...
        lda     PLAYER_SPRITE_1_ID                           ; D7BB AD 15 02                 ...
        eor     #$04                            ; D7BE 49 04                    I.
        sta     PLAYER_SPRITE_1_ID                           ; D7C0 8D 15 02                 ...
LD7C3:
        ; shift player sprite left on screen 4 px
		lda     PLAYER_SPRITE_0_X                           ; D7C3 AD 13 02                 ...
        sec                                     ; D7C6 38                       8
        sbc     #$04                            ; D7C7 E9 04                    ..
        sta     PLAYER_SPRITE_0_X                           ; D7C9 8D 13 02                 ...
        clc                                     ; D7CC 18                       .
        adc     #$08                            ; D7CD 69 08                    i.
        sta     PLAYER_SPRITE_1_X                           ; D7CF 8D 17 02                 ...
        
		; scroll right by 4px
		lda     PPU_SCROLL_X                             ; D7D2 A5 1C                    ..
        clc                                     ; D7D4 18                       .
        adc     #$04                            ; D7D5 69 04                    i.
        sta     PPU_SCROLL_X                             ; D7D7 85 1C                    ..
        lda     #$FF                            ; D7D9 A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; D7DB 20 8F CC                  ..
        
		; loop
		dec     SCRATCH_0B                             ; D7DE C6 0B                    ..
        bpl     LD7A5                           ; D7E0 10 C3                    ..
        
		; loop
		dec     LOOP_COUNTER_0A                             ; D7E2 C6 0A                    ..
        bpl     LD7A1                           ; D7E4 10 BB                    ..
        
		; write to PPU $2400 (nametable)
		lda     #$00                            ; D7E6 A9 00                    ..
        sta     PPU_WRITE_LO                             ; D7E8 85 16                    ..
        lda     #$24                            ; D7EA A9 24                    .$
        sta     PPU_WRITE_HI                             ; D7EC 85 17                    ..
        lda     #$10                            ; D7EE A9 10                    ..
        sta     PLAYER_MAP_TILE_LO                           ; D7F0 85 0C                    ..
        jsr     UPDATE_MAP_DATA_FROM_SCROLL                           ; D7F2 20 33 C8                  3.
        jmp     LD864                           ; D7F5 4C 64 D8                 Ld.

; ----------------------------------------------------------------------------
LEFT_HORIZONTAL_SCROLL:
        ; set nametable and scroll
		lda     #$01                            ; D7F8 A9 01                    ..
        sta     a:PPU_NAMETABLE_SELECT                           ; D7FA 8D 1D 00                 ...
        lda     #$00                            ; D7FD A9 00                    ..
        sta     a:PPU_SCROLL_X                           ; D7FF 8D 1C 00                 ...
        
		; player sprite x = 0
		lda     #$00                            ; D802 A9 00                    ..
        sta     PLAYER_SPRITE_0_X                           ; D804 8D 13 02                 ...
        lda     #$08                            ; D807 A9 08                    ..
        sta     PLAYER_SPRITE_1_X                           ; D809 8D 17 02                 ...
        lda     #$0F                            ; D80C A9 0F                    ..
        
		; set up outer/inner loop counters
		sta     LOOP_COUNTER_0A                             ; D80E 85 0A                    ..
LD810:
        lda     #$03                            ; D810 A9 03                    ..
        sta     SCRATCH_0B                             ; D812 85 0B                    ..
LD814:
        bne     LD832                           ; D814 D0 1C                    ..
        
		; nudge player sprite 1 pixel left
		dec     PLAYER_SPRITE_0_X                           ; D816 CE 13 02                 ...
        dec     PLAYER_SPRITE_1_X                           ; D819 CE 17 02                 ...
        
		; branch if not jumping
		lda     CTR_PLAYER_DESCENT                             ; D81C A5 4E                    .N
        ora     JUMP_FRAMES_REMAINING                             ; D81E 05 4F                    .O
        bne     LD832                           ; D820 D0 10                    ..
        
		; revert to walking sprite
		lda     PLAYER_SPRITE_0_ID                           ; D822 AD 11 02                 ...
        eor     #$04                            ; D825 49 04                    I.
        sta     PLAYER_SPRITE_0_ID                           ; D827 8D 11 02                 ...
        lda     PLAYER_SPRITE_1_ID                           ; D82A AD 15 02                 ...
        eor     #$04                            ; D82D 49 04                    I.
        sta     PLAYER_SPRITE_1_ID                           ; D82F 8D 15 02                 ...
LD832:
		; shift sprite x right 4
        lda     PLAYER_SPRITE_0_X                           ; D832 AD 13 02                 ...
        clc                                     ; D835 18                       .
        adc     #$04                            ; D836 69 04                    i.
        sta     PLAYER_SPRITE_0_X                           ; D838 8D 13 02                 ...
        clc                                     ; D83B 18                       .
        adc     #$08                            ; D83C 69 08                    i.
        sta     PLAYER_SPRITE_1_X                           ; D83E 8D 17 02                 ...
        
		; ooh, scroll bg 4 pixels
		lda     PPU_SCROLL_X                             ; D841 A5 1C                    ..
        sec                                     ; D843 38                       8
        sbc     #$04                            ; D844 E9 04                    ..
        sta     PPU_SCROLL_X                             ; D846 85 1C                    ..
        
		; await nmi
		lda     #$FF                            ; D848 A9 FF                    ..
        jsr     QUEUE_NEXT_NMI_ROUTINE                           ; D84A 20 8F CC                  ..
        
		; loop if SCRATCH_0B positive
		dec     SCRATCH_0B                             ; D84D C6 0B                    ..
        bpl     LD814                           ; D84F 10 C3                    ..
        
		; loop if LOOP_COUNTER_0A positive
		dec     LOOP_COUNTER_0A                             ; D851 C6 0A                    ..
        bpl     LD810                           ; D853 10 BB                    ..
        
		; write to PPU addreess $201E (nametable)
		lda     #$1E                            ; D855 A9 1E                    ..
        sta     PPU_WRITE_LO                             ; D857 85 16                    ..
        lda     #$20                            ; D859 A9 20                    . 
        sta     PPU_WRITE_HI                             ; D85B 85 17                    ..
        lda     #$2F                            ; D85D A9 2F                    ./
        sta     PLAYER_MAP_TILE_LO                           ; D85F 85 0C                    ..
        jsr     UPDATE_MAP_DATA_FROM_SCROLL                           ; D861 20 33 C8                  3.
LD864:
        sec                                     ; D864 38                       8
        rts                                     ; D865 60                       `

; ----------------------------------------------------------------------------
; used to return to overworld after crystal use, boss fights
; preps positions for player to walk up ladder and then calls
; ENTER_MAP_LOCATION
WARP_TO_OVERWORLD:
        lda     #MAP_Y_OVERWORLD                            ; D866 A9 10                    ..
        sta     MAP_Y                             ; D868 85 48                    .H
        lda     #MAP_X_OVERWORLD                            ; D86A A9 03                    ..
        sta     MAP_X                             ; D86C 85 47                    .G
        lda     #$12                            ; D86E A9 12                    ..
        sta     SCROLL_X_HI                             ; D870 85 7C                    .|
        lda     #$B0                            ; D872 A9 B0                    ..
        sta     PY                             ; D874 85 45                    .E
        lda     #$1A                            ; D876 A9 1A                    ..
        sta     PX_HI                             ; D878 85 44                    .D
        lda     #$00                            ; D87A A9 00                    ..
        sta     PX_LO                             ; D87C 85 43                    .C
        sta     SCROLL_X_LO                             ; D87E 85 7B                    .{
        jmp     ENTER_MAP_LOCATION                           ; D880 4C 95 D8                 L..

; ----------------------------------------------------------------------------
; fades out form the overworld, loads the first dungeon map, then fades in
ENTER_DUNGEON_FROM_OVERWORLD:
		; start at the top/left corner map section
        lda     #$00                            ; D883 A9 00                    ..
        sta     MAP_Y                             ; D885 85 48                    .H
        sta     MAP_X                             ; D887 85 47                    .G
        
		; player is on the ladder
		sta     SCROLL_X_HI                             ; D889 85 7C                    .|
        sta     PY                             ; D88B 85 45                    .E
        sta     PX_LO                             ; D88D 85 43                    .C
        sta     SCROLL_X_LO                             ; D88F 85 7B                    .{
        lda     #$01                            ; D891 A9 01                    ..
        sta     PX_HI                             ; D893 85 44                    .D

; load it up...
ENTER_MAP_LOCATION:
        jsr     PALETTE_FADE_OUT                           ; D895 20 E5 C3                  ..
        jsr     CLEAR_ALL_OBJECTS                           ; D898 20 8A D0                  ..
        jsr     LOAD_MAP_FULL                           ; D89B 20 F2 C8                  ..
        jsr     LOAD_GRAPHICS_FOR_MAP_LEVEL                           ; D89E 20 CB C5                  ..
        jsr     HIDE_SPRITES_280_UP                           ; D8A1 20 7C D0                  |.
        jsr     UPDATE_PPU_SCROLL_X                           ; D8A4 20 C7 C1                  ..
        jsr     DRAW_PLAYER                           ; D8A7 20 D8 C1                  ..
        jsr     PALETTE_FADE_IN                           ; D8AA 20 92 C4                  ..
        sec                                     ; D8AD 38                       8
        rts                                     ; D8AE 60                       `

; ----------------------------------------------------------------------------
; prep the player frame for drawing
MAKE_PLAYER_FRAME:
        jsr     CALC_PLAYER_FRAME_AND_SPRITE_FLAGS                           ; D8AF 20 E3 D8                  ..
        jsr     APPLY_PLAYER_FRAME_ANIMATIONS                           ; D8B2 20 4E D9                  N.
        rts                                     ; D8B5 60                       `

; ----------------------------------------------------------------------------
; applies player dx and dy to save tentative next positions in temp variables:
; $0a = next y, $0e = next x lo, $0f = next x hi
CALC_NEXT_PLAYER_POS:
		; save location and speed vars 
        lda     PX_LO                             ; D8B6 A5 43                    .C
        sta     TEMP_NEXT_X_LO                           ; D8B8 85 0E                    ..
        lda     PX_HI                             ; D8BA A5 44                    .D
        sta     TEMP_NEXT_X_HI                             ; D8BC 85 0F                    ..
        lda     PY                             ; D8BE A5 45                    .E
        sta     TEMP_NEXT_Y                             ; D8C0 85 0A                    ..
        lda     PLAYER_DY                             ; D8C2 A5 4B                    .K
 
		; branch if dy=0
		beq     LD8CB                           ; D8C4 F0 05                    ..
        
		; dy <> 0, add TEMP_NEXT_Y, set above to PY, so TEMP_NEXT_Y becomes PY+DY or next Y value
		clc                                     ; D8C6 18                       .
        adc     TEMP_NEXT_Y                             ; D8C7 65 0A                    e.
        sta     TEMP_NEXT_Y                             ; D8C9 85 0A                    ..
LD8CB:
        lda     PLAYER_DX                             ; D8CB A5 49                    .I
        
		; branch (rts) if dx=0
		beq     LD8E2                           ; D8CD F0 13                    ..
        
		; dx <> 0; PX_LO+DX with carry management, next values stored to $0e, $0f
		clc                                     ; D8CF 18                       .
        adc     TEMP_NEXT_X_LO                           ; D8D0 65 0E                    e.
        pha                                     ; D8D2 48                       H
        
		; store lower nibble
		and     #$0F                            ; D8D3 29 0F                    ).
        sta     TEMP_NEXT_X_LO                           ; D8D5 85 0E                    ..
        
		; mult original sum x 16 to set carry if sum was >= 16
		pla                                     ; D8D7 68                       h
        asl     a                               ; D8D8 0A                       .
        asl     a                               ; D8D9 0A                       .
        asl     a                               ; D8DA 0A                       .
        asl     a                               ; D8DB 0A                       .
        lda     TEMP_NEXT_X_HI                             ; D8DC A5 0F                    ..
        adc     PLAYER_HORIZ_DIR                             ; D8DE 65 4A                    eJ
        sta     TEMP_NEXT_X_HI                             ; D8E0 85 0F                    ..
LD8E2:
        rts                                     ; D8E2 60                       `

; ----------------------------------------------------------------------------
; x is used to track tentative frame before it's assigned
CALC_PLAYER_FRAME_AND_SPRITE_FLAGS:
        ; default is the hard landing frame!
		ldx     #$3D                            ; D8E3 A2 3D                    .=
        
		; branch if PLAYER_HARD_LANDING_CTR <> 0 - use hard landing sprite
		lda     PLAYER_HARD_LANDING_CTR                             ; D8E5 A5 46                    .F
        bne     LD92E                           ; D8E7 D0 45                    .E
        
		; PLAYER_HARD_LANDING_CTR = 0; ladder/facing away from screen
		ldx     #$09                            ; D8E9 A2 09                    ..
        
		; branch if ON_LADDER_FLAG <> 0; we are on a ladder and frame=9
		lda     ON_LADDER_FLAG                             ; D8EB A5 50                    .P
        bne     LD92E                           ; D8ED D0 3F                    .?
        
		; ON_LADDER_FLAG = 0; not on ladder
		lda     JOYPAD_INPUT                             ; D8EF A5 20                    . 
        and     #$BF                            ; D8F1 29 BF                    ).
        cmp     #$80                            ; D8F3 C9 80                    ..
        
		; branch if pressing A but not select/start or d pad - frame=9
		beq     LD92E                           ; D8F5 F0 37                    .7
        
		; not doing that; branch if PLAYER_DY = 0
		lda     PLAYER_DY                             ; D8F7 A5 4B                    .K
        beq     LD913                           ; D8F9 F0 18                    ..
        
		; branch if PLAYER_DY negative - ascending
		bmi     LD90C                           ; D8FB 30 0F                    0.
        
		; PLAYER_DY positive = going down; branch if CTR_PLAYER_DESCENT <> 0
		lda     CTR_PLAYER_DESCENT                             ; D8FD A5 4E                    .N
        bne     LD931                           ; D8FF D0 30                    .0
        
		; CTR_PLAYER_DESCENT = 0; branch if pressing down
		lda     JOYPAD_INPUT                             ; D901 A5 20                    . 
        and     #BTN_DOWN                            ; D903 29 04                    ).
        beq     LD913                           ; D905 F0 0C                    ..
        
		; not pressing down
		ldx     #$0D                            ; D907 A2 0D                    ..
        jmp     LD92E                           ; D909 4C 2E D9                 L..

; ----------------------------------------------------------------------------
LD90C:
        ; branch if no jump frames remain
		lda     JUMP_FRAMES_REMAINING                             ; D90C A5 4F                    .O
        beq     LD92E                           ; D90E F0 1E                    ..
        
		; jump frames remain - "jump" :D
		jmp     LD931                           ; D910 4C 31 D9                 L1.

; ----------------------------------------------------------------------------
LD913:
		; start with frame 1 (basic standing frame)
		; y --> sprite flags for horizontal mirroring (default no)
        ldx     #$01                            ; D913 A2 01                    ..
        ldy     #$00                            ; D915 A0 00                    ..
        
		; branch if player moving left
		lda     PLAYER_HORIZ_DIR                             ; D917 A5 4A                    .J
        bmi     LD921                           ; D919 30 06                    0.
        
		; moving right or no dx; branch if no dx (keep current frame)
		lda     PLAYER_DX                             ; D91B A5 49                    .I
        beq     LD930                           ; D91D F0 11                    ..
        
		; otherwise, flip sprite horizontally
		; we don't change the current frame's bits 0-2
		ldy     #$40                            ; D91F A0 40                    .@
LD921:
        stx     SCRATCH_08                             ; D921 86 08                    ..
        lda     PLAYER_FRAME                             ; D923 A5 56                    .V
        and     #$07                            ; D925 29 07                    ).
        ora     SCRATCH_08                             ; D927 05 08                    ..
        sta     PLAYER_FRAME                             ; D929 85 56                    .V
        sty     PLAYER_SPRITE_FLAGS                             ; D92B 84 57                    .W
        rts                                     ; D92D 60                       `

; ----------------------------------------------------------------------------

LD92E:
        stx     PLAYER_FRAME                             ; D92E 86 56                    .V
LD930:
        rts                                     ; D930 60                       `

; ----------------------------------------------------------------------------
LD931:
        ; we are jumping upward
		ldx     #$39                            ; D931 A2 39                    .9
        ldy     #$00                            ; D933 A0 00                    ..
        
		; branch if player moving left
		lda     PLAYER_HORIZ_DIR                             ; D935 A5 4A                    .J
        ora     PLAYER_DX                             ; D937 05 49                    .I
        bmi     LD941                           ; D939 30 06                    0.
        
		; branch (horiz flip) if moving right
		bne     LD93F                           ; D93B D0 02                    ..
        
		; not moving horizontally; x=9 ensures bits 1 and 3 set on frame
		ldx     #$09                            ; D93D A2 09                    ..
LD93F:
        ldy     #$40                            ; D93F A0 40                    .@
LD941:
        stx     SCRATCH_08                             ; D941 86 08                    ..
        lda     PLAYER_FRAME                             ; D943 A5 56                    .V
        and     #$03                            ; D945 29 03                    ).
        ora     SCRATCH_08                             ; D947 05 08                    ..
        sta     PLAYER_FRAME                             ; D949 85 56                    .V
        sty     PLAYER_SPRITE_FLAGS                             ; D94B 84 57                    .W
        rts                                     ; D94D 60                       `

; ----------------------------------------------------------------------------
; walking, firing
APPLY_PLAYER_FRAME_ANIMATIONS:
        ; branch if hard landing in progress
		lda     PLAYER_HARD_LANDING_CTR                             ; D94E A5 46                    .F
        bne     LD967                           ; D950 D0 15                    ..
        
		; branch if frame >= x20
		lda     PLAYER_FRAME                             ; D952 A5 56                    .V
        cmp     #$20                            ; D954 C9 20                    . 
        bcs     LD967                           ; D956 B0 0F                    ..
        
		; frame <= x20; branch if B pressed
		lda     PLAYER_FRAME                             ; D958 A5 56                    .V
        bit     JOYPAD_INPUT                             ; D95A 24 20                    $ 
        bvs     LD963                           ; D95C 70 05                    p.
        
		and     #OFFSCREEN_Y                            ; D95E 29 EF                    ).
        jmp     LD965                           ; D960 4C 65 D9                 Le.

; ----------------------------------------------------------------------------
LD963:
		; B pressed; modify to firing pose
        ora     #$10                            ; D963 09 10                    ..
LD965:
        sta     PLAYER_FRAME                             ; D965 85 56                    .V
LD967:
		; branch (rts) if no dpad input
        lda     JOYPAD_INPUT                             ; D967 A5 20                    . 
        and     #$0F                            ; D969 29 0F                    ).
        beq     LD990                           ; D96B F0 23                    .#
        
		; dpad input present; branch (rts) if jumping/falling
		lda     JUMP_FRAMES_REMAINING                             ; D96D A5 4F                    .O
        ora     CTR_PLAYER_DESCENT                             ; D96F 05 4E                    .N
        bne     LD990                           ; D971 D0 1D                    ..
        
		; increment CTR_PLAYER_WALK_ANIMATION and branch if %8 <> 0
		inc     CTR_PLAYER_WALK_ANIMATION                             ; D973 E6 4D                    .M
        lda     CTR_PLAYER_WALK_ANIMATION                             ; D975 A5 4D                    .M
        and     #$07                            ; D977 29 07                    ).
        bne     LD990                           ; D979 D0 15                    ..
        
		; CTR_PLAYER_WALK_ANIMATION%8 = 0
		; branch if bit 3 set on PLAYER_FRAME
		lda     PLAYER_FRAME                             ; D97B A5 56                    .V
        and     #$08                            ; D97D 29 08                    ).
        bne     TOGGLE_PLAYER_HORIZ_FLIP                           ; D97F D0 09                    ..
        
		; else flip bit 2
		lda     PLAYER_FRAME                             ; D981 A5 56                    .V
        eor     #$04                            ; D983 49 04                    I.
        sta     PLAYER_FRAME                             ; D985 85 56                    .V
        jmp     LD990                           ; D987 4C 90 D9                 L..

; ----------------------------------------------------------------------------
TOGGLE_PLAYER_HORIZ_FLIP:
        lda     PLAYER_SPRITE_FLAGS                             ; D98A A5 57                    .W
        eor     #$40                            ; D98C 49 40                    I@
        sta     PLAYER_SPRITE_FLAGS                             ; D98E 85 57                    .W
LD990:
        rts                                     ; D990 60                       `

; ----------------------------------------------------------------------------
; check if a player is going offscreen - check scroll if so
; else, check if player hits something that modifies speed (e.g. moveable block)
CHECK_PLAYER_HALT_OR_SCROLL:
		; save original dy/dx on stack
        lda     PLAYER_DY                             ; D991 A5 4B                    .K
        pha                                     ; D993 48                       H
        lda     PLAYER_DX                             ; D994 A5 49                    .I
        pha                                     ; D996 48                       H
LD997:
        ; check next position and branch if no scroll check needed
		jsr     CALC_NEXT_PLAYER_POS                           ; D997 20 B6 D8                  ..
        jsr     CHECK_OBJECT_OFFSCREEN                           ; D99A 20 08 CF                  ..
        bcc     CHECK_PLAYER_INTERACTIONS                           ; D99D 90 08                    ..
        
		; scroll check needed
		jsr     CHECK_MAP_SCROLL                           ; D99F 20 D4 D6                  ..
        bcc     SLOW_BLOCKED_PLAYER                           ; D9A2 90 47                    .G
        jmp     LDA13                           ; D9A4 4C 13 DA                 L..

; ----------------------------------------------------------------------------
CHECK_PLAYER_INTERACTIONS:
        ; branch if any touching-tile effects occurred
		jsr     CHECK_PLAYER_TOUCHING_TILES                           ; D9A7 20 42 DD                  B.
        bcs     SLOW_BLOCKED_PLAYER                           ; D9AA B0 3F                    .?
        
		; branch if no collision with solid sprites (e.g. moveable block)
		; we branch here when doing glove clip
		jsr     CHECK_TOUCH_SOLID_SPRITE                           ; D9AC 20 1A CE                  ..
        bcc     RESTORE_PLAYER_DX_DY                           ; D9AF 90 63                    .c
        
		; branch (ignore) if we collided with object slot 9
		; slot A is treasure, 0-8 are enemies, 9 is for moveable blocks/opening doors
		lda     SCRATCH_08                             ; D9B1 A5 08                    ..
        cmp     #OBJ_SLOT_TEMP_OBJECT                            ; D9B3 C9 09                    ..
        beq     SLOW_BLOCKED_PLAYER                           ; D9B5 F0 34                    .4
        
		; otherwise, branch if we collided with a slot < 9 (enemy)
		bcc     LD9D1                           ; D9B7 90 18                    ..
        
		; branch if it's not an enemy
		ldx     SCRATCH_09                             ; D9B9 A6 09                    ..
        lda     OBJ_GENERAL_TYPE,x                         ; D9BB BD 01 04                 ...
        cmp     #OBJ_GEN_TYPE_ENEMY                            ; D9BE C9 01                    ..
        bne     HANDLE_TOUCH_MAP_ITEM                           ; D9C0 D0 06                    ..
        
		; gen type is enemey, slot > OBJ_SLOT_TEMP_OBJECT, should be an unopened chest
		jsr     CHECK_OPEN_TREASURE_CHEST                           ; D9C2 20 31 DA                  1.
        jmp     RESTORE_PLAYER_DX_DY                           ; D9C5 4C 14 DA                 L..

; ----------------------------------------------------------------------------
; collect a map item (anything in a chest, or the dragon slayer)
; crowns are handled separate by COLLECT_CROWN
HANDLE_TOUCH_MAP_ITEM:
        jsr     COLLECT_CHEST_ITEM                           ; D9C8 20 86 DA                  ..
        jsr     MARK_TREASURE_COLLECTED                           ; D9CB 20 36 CA                  6.
        jmp     LDA13                           ; D9CE 4C 13 DA                 L..

; ----------------------------------------------------------------------------
LD9D1:
        ldx     SCRATCH_09                             ; D9D1 A6 09                    ..
        
		; branch if object is an enemy - see if we kill it with armor
		lda     OBJ_GENERAL_TYPE,x                         ; D9D3 BD 01 04                 ...
        cmp     #OBJ_GEN_TYPE_ENEMY                            ; D9D6 C9 01                    ..
        beq     LD9E4                           ; D9D8 F0 0A                    ..
        
		; branch (do nothing) if type >= x1A (spawner, dead)
		cmp     #$1A                            ; D9DA C9 1A                    ..
        bcs     LD9E7                           ; D9DC B0 09                    ..
        
		; e.g. items 
		jsr     COLLECT_MONSTER_DROP_ITEM                           ; D9DE 20 AA DA                  ..
        jmp      LDA13                           ; D9E1 4C 13 DA                 L..

; ----------------------------------------------------------------------------
LD9E4:
        jsr     CHECK_ARMOR_KILL                           ; D9E4 20 1B DA                  ..
LD9E7:
        clc                                     ; D9E7 18                       .
        jmp     RESTORE_PLAYER_DX_DY                           ; D9E8 4C 14 DA                 L..

; ----------------------------------------------------------------------------
; slow or stop the player b/c they have hit an obstruction
; either a solid tile, moveable block, or ceiling spikes
; if no scroll, player stops; if scroll(s) active, we loop and dec speed by 1 until not obstructed
SLOW_BLOCKED_PLAYER:
		; branch (dx=0) if no scroll speed active - our speed starts at 1 so slowing it 
		; down will get us to 0
        lda     CTR_SPEED_SCROLL_1                             ; D9EB A5 88                    ..
        beq     LDA02                           ; D9ED F0 13                    ..
        
		; speed scroll! branch if not moving horizontally though
		lda     PLAYER_DX                             ; D9EF A5 49                    .I
        beq     LDA02                           ; D9F1 F0 0F                    ..
        
		; we have a speed scroll and are moving horizontally
		; branch if moving left (dx is a 4 bit signed integer so if bit 3 set it is negative)
		; so x+=1 if moving left to slow down, x=x-2+1=-1 if moving right to slow down
		tax                                     ; D9F3 AA                       .
        and     #$08                            ; D9F4 29 08                    ).
        bne     LD9FA                           ; D9F6 D0 02                    ..
        
		; moving right - net decrease speed by 1
		dex                                     ; D9F8 CA                       .
        dex                                     ; D9F9 CA                       .
LD9FA:
        inx                                     ; D9FA E8                       .
        txa                                     ; D9FB 8A                       .
        and     #$0F                            ; D9FC 29 0F                    ).
        sta     PLAYER_DX                             ; D9FE 85 49                    .I
        
		; branch if dx non-zero; recheck obstruction
		; branch is to within CHECK_PLAYER_HALT_OR_SCROLL
		bne     LD997                           ; DA00 D0 95                    ..
LDA02:
		; dx=0
        pla                                     ; DA02 68                       h
        pha                                     ; DA03 48                       H
        sta     PLAYER_DX                             ; DA04 85 49                    .I
        ldx     PLAYER_DY                             ; DA06 A6 4B                    .K
        
		; branch (rts) if dy=0
		beq     LDA13                           ; DA08 F0 09                    ..
        
		; branch if dy negative 
		; logic below will slow by 1 if going up or down?
		bmi     LDA0E                           ; DA0A 30 02                    0.
        
		; dy positive - going down
		dex                                     ; DA0C CA                       .
        dex                                     ; DA0D CA                       .
LDA0E:
        inx                                     ; DA0E E8                       .
        stx     PLAYER_DY                             ; DA0F 86 4B                    .K
        
		; branch if still moving horizontally - re-check for obstruction
		; branch is to within CHECK_PLAYER_HALT_OR_SCROLL
		bne     LD997                           ; DA11 D0 84                    ..
LDA13:
        sec                                     ; DA13 38                       8
RESTORE_PLAYER_DX_DY:
		; restore original dx/dy
        pla                                     ; DA14 68                       h
        sta     PLAYER_DX                             ; DA15 85 49                    .I
        pla                                     ; DA17 68                       h
        sta     PLAYER_DY                             ; DA18 85 4B                    .K
        rts                                     ; DA1A 60                       `

; ----------------------------------------------------------------------------
; check if we kill an enemy with the armor
; input - SCRATCH_09 = object slot of enemy we have collided with
CHECK_ARMOR_KILL:
        ; branch (rts) if this is a crown boss
		lda     CHR_BANK_ENEMY_SPRITES                             ; DA1B A5 2D                    .-
        cmp     #SPRITE_PT_TARATUNES                            ; DA1D C9 30                    .0
        bcs     LDA30                           ; DA1F B0 0F                    ..
        
		; branch if no armor active
		lda     CTR_ARMOR_MAGIC                             ; DA21 A5 87                    ..
        beq     LDA30                           ; DA23 F0 0B                    ..
        
		; armor active - branch if we don't have magic
		lda     PLAYER_MAGIC                             ; DA25 A5 59                    .Y
        beq     LDA30                           ; DA27 F0 07                    ..
        
		; change type - armor kill
		ldx     SCRATCH_09                             ; DA29 A6 09                    ..
        lda     #OBJ_GEN_TYPE_ENEMY_JUST_KILLED                            ; DA2B A9 80                    ..
        sta     OBJ_GENERAL_TYPE,x                         ; DA2D 9D 01 04                 ...
LDA30:
        rts                                     ; DA30 60                       `

; ----------------------------------------------------------------------------
; try to open a treasure chest
; play a sound effect and clear carry if we have no keys
; otherwise use a key and open the chest
; return - carry clear if failed to open, set for success
CHECK_OPEN_TREASURE_CHEST:
		; use a key if available; carry will be set if out of keys
		; does key stick not work for chests??
        jsr     USE_NORMAL_KEY                           ; DA31 20 6F E8                  o.
        bcc     OPEN_TREASURE_CHEST                           ; DA34 90 06                    ..
        
		; carry set - no key used? not sure why doing sound effect then...?
		lda     #SOUND_OPEN_DOOR                            ; DA36 A9 06                    ..
        sta     NEXT_SOUND_EFFECT                             ; DA38 85 8F                    ..
        clc                                     ; DA3A 18                       .
        rts                                     ; DA3B 60                       `

; ----------------------------------------------------------------------------
; opens a chest
; replace the chest object with the item inside, play the music
; carry set upon completion
OPEN_TREASURE_CHEST:
		; branch if item for this map is an inventory item (e.g. not bread, magic, scroll, key, money)
		ldy     #MAP_CFG_TREASURE_ITEM_GEN_TYPE                            ; DA3C A0 0A                    ..
        lda     (MAP_DATA_LO),y                         ; DA3E B1 77                    .w
        cmp     #$08                            ; DA40 C9 08                    ..
        bcs     LDA49                           ; DA42 B0 05                    ..
        
		; otherwise, we have non-inventory item; clear MAP_ITEM_SPRITE_FLAGS
		ldy     #$00                            ; DA44 A0 00                    ..
        sty     MAP_ITEM_SPRITE_FLAGS                           ; DA46 8C A2 04                 ...
LDA49:
		; save the original item value; adding 2 converts the 
		; object gen type to the map item system
        pha                                     ; DA49 48                       H
        clc                                     ; DA4A 18                       .
        adc     #$02                            ; DA4B 69 02                    i.
        sta     MAP_ITEM_GEN_TYPE                           ; DA4D 8D A1 04                 ...
        pla                                     ; DA50 68                       h
        
		; id*4 + x81 = MAP_ITEM_SPRITE
		asl     a                               ; DA51 0A                       .
        asl     a                               ; DA52 0A                       .
        clc                                     ; DA53 18                       .
        adc     #$81                            ; DA54 69 81                    i.
        sta     MAP_ITEM_SPRITE                           ; DA56 8D A0 04                 ...

		; redraw objects to show the revealed item
        lda     #SOUND_1F_TWEET                            ; DA59 A9 1F                    ..
        sta     NEXT_SOUND_EFFECT                             ; DA5B 85 8F                    ..
        jsr     DRAW_OBJECTS                           ; DA5D 20 B1 C2                  ..
        
		; temp set INVULN_CTR to 0 so not flickering while chest opens
		lda     INVULN_CTR                             ; DA60 A5 85                    ..
        pha                                     ; DA62 48                       H
        lda     #$00                            ; DA63 A9 00                    ..
        sta     INVULN_CTR                             ; DA65 85 85                    ..
        jsr     DRAW_PLAYER                           ; DA67 20 D8 C1                  ..
        
		; save the old music
		lda     MUSIC_ID                             ; DA6A A5 8E                    ..
        pha                                     ; DA6C 48                       H
        
		; huh, treasure opening is actually a song rather than a sound effect
		lda     #MUSIC_TREASURE_CHEST                            ; DA6D A9 0E                    ..
        sta     MUSIC_ID                             ; DA6F 85 8E                    ..
        jsr     LOAD_MUSIC_DATA                           ; DA71 20 08 FC                  ..
        
		; wait 120 frames, then restore the prior music
		lda     #$78                            ; DA74 A9 78                    .x
        sta     NMI_WAIT_CTR                             ; DA76 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; DA78 20 35 C1                  5.
        pla                                     ; DA7B 68                       h
        sta     MUSIC_ID                             ; DA7C 85 8E                    ..
        jsr     LOAD_MUSIC_DATA                           ; DA7E 20 08 FC                  ..
        
		; restore invuln ctr
		pla                                     ; DA81 68                       h
        sta     INVULN_CTR                             ; DA82 85 85                    ..
        sec                                     ; DA84 38                       8
        rts                                     ; DA85 60                       `

; ----------------------------------------------------------------------------
; collect an item from an open chest
; input a = map item type of the item
COLLECT_CHEST_ITEM:
        ; convert the map item type to the OBJ_GENERAL_TYPE scale and save it
		sec                                     ; DA86 38                       8
        sbc     #$02                            ; DA87 E9 02                    ..
        pha                                     ; DA89 48                       H
        
		; branch if original a-2<x18
		; clear the item
		lda     #$00                            ; DA8A A9 00                    ..
        sta     MAP_ITEM_GEN_TYPE                           ; DA8C 8D A1 04                 ...
        
		; retrieve the OBJ_GENERAL_TYPE and branch if it's a valid item
		pla                                     ; DA8F 68                       h
        cmp     #OBJ_GEN_TYPE_PROJECTILE                            ; DA90 C9 18                    ..
		bcc     TREASURE_ITEM_COLLECTED                           ; DA92 90 03                    ..
        
		; else, not a valid item - plays open door sound; might just be paranoia, not
		; sure if this ever happens in game
		jmp     PLAY_OPEN_DOOR_SOUND                           ; DA94 4C 01 DB                 L..

; ----------------------------------------------------------------------------
; respond to collection of the chest item collected
; if it's an inventory item (e.g. wings) we add it to inventory
;   if it's also a crown, we go fight the boss
; if it's non-inventory (bread, etc) we jump to perform the relevant magic effect
TREASURE_ITEM_COLLECTED:
        ; branch if a>=OBJ_GEN_TYPE_WINGS - it's an inventory item that is collected
		cmp     #OBJ_GEN_TYPE_WINGS                            ; DA97 C9 08                    ..
		bcs     COLLECT_INVENTORY_ITEM                           ; DA99 B0 37                    .7
        
		; a <= 8; convert to an index in x and perform action
		; used for non-inventory items in chests (bread, potion, scroll, golds)
		asl     a                               ; DA9B 0A                       .
        tax                                     ; DA9C AA                       .
        lda     JMP_TBL_CHEST_ITEM_ACTIONS,x                      ; DA9D BD 16 DB                 ...
        sta     TEMP_JUMP_LO                           ; DAA0 85 0C                    ..
        lda     JMP_TBL_CHEST_ITEM_ACTIONS+1,x                    ; DAA2 BD 17 DB                 ...
        sta     TEMP_JUMP_HI                             ; DAA5 85 0D                    ..
        jmp     (TEMP_JUMP_LO)                         ; DAA7 6C 0C 00                 l..

; ----------------------------------------------------------------------------
COLLECT_MONSTER_DROP_ITEM:
        ; branch if a-2 < x18
		sec                                     ; DAAA 38                       8
        sbc     #$02                            ; DAAB E9 02                    ..
        cmp     #OBJ_GEN_TYPE_PROJECTILE                            ; DAAD C9 18                    ..
        bcc     LDAB2                           ; DAAF 90 01                    ..
        rts                                     ; DAB1 60                       `

; ----------------------------------------------------------------------------
LDAB2:
        ; save a on stack, clear slot, start counter to respawn at xf0
		pha                                     ; DAB2 48                       H
        lda     #OBJ_GEN_TYPE_BLANK                            ; DAB3 A9 00                    ..
        sta     OBJ_GENERAL_TYPE,x                         ; DAB5 9D 01 04                 ...
        lda     #$F0                            ; DAB8 A9 F0                    ..
        sta     OBJ_MISC_CTR,x                         ; DABA 9D 06 04                 ...
        lda     SCRATCH_08                             ; DABD A5 08                    ..
        asl     a                               ; DABF 0A                       .
        asl     a                               ; DAC0 0A                       .
        asl     a                               ; DAC1 0A                       .
        ora     #$80                            ; DAC2 09 80                    ..
        
		; a = 0xc0
		; sprites at $02c0 and $02c4 set offscreen
		tax                                     ; DAC4 AA                       .
        lda     #OFFSCREEN_Y                            ; DAC5 A9 EF                    ..
        sta     SPRITE_0_Y,x                         ; DAC7 9D 00 02                 ...
        sta     SPRITE_1_Y,x                         ; DACA 9D 04 02                 ...
        
		; restore a and branch if <8
		pla                                     ; DACD 68                       h
        cmp     #$08                            ; DACE C9 08                    ..
        bcc     LDAF2                           ; DAD0 90 20                    . 

; add an item to our inventory
COLLECT_INVENTORY_ITEM:
		; a was >= 8
        sbc     #$08                            ; DAD2 E9 08                    ..
        tax                                     ; DAD4 AA                       .
        lda     PLAYER_INVENTORY,x                           ; DAD5 B5 60                    .`
        cmp     #$0B                            ; DAD7 C9 0B                    ..
        
		; branch if PLAYER_INVENTORY,x was > 0xb
		bcs     FAIL_TOO_MUCH_INVENTORY                           ; DAD9 B0 11                    ..
        
		; PLAYER_INVENTORY,x was <= 0xb; increment it
		inc     PLAYER_INVENTORY,x                           ; DADB F6 60                    .`
        lda     #SOUND_RING_SCROLL                            ; DADD A9 13                    ..
        sta     NEXT_SOUND_EFFECT                             ; DADF 85 8F                    ..
        
		; branch if x=0xe (crown!), else rts
		cpx     #INV_ITEM_CROWN                            ; DAE1 E0 0E                    ..
		beq     COLLECT_CROWN                           ; DAE3 F0 01                    ..
        rts                                     ; DAE5 60                       `

; ----------------------------------------------------------------------------
COLLECT_CROWN:
		; crown collected!
        jsr     MARK_TREASURE_COLLECTED                           ; DAE6 20 36 CA                  6.
        jmp     ENTER_BOSS_FIGHT                           ; DAE9 4C 20 D6                 L .

; ----------------------------------------------------------------------------
; oh no! couldn't collect item as we have too many! just plays the poison sound
; and we've lost the item
FAIL_TOO_MUCH_INVENTORY:
		lda     #SOUND_POISON                            ; DAEC A9 1D                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DAEE 8D 8F 00                 ...
        rts                                     ; DAF1 60                       `

; ----------------------------------------------------------------------------
; similar to above - jumps to a function for item activation based on a*2
LDAF2:
        asl     a                               ; DAF2 0A                       .
        tax                                     ; DAF3 AA                       .
        lda     JMP_TBL_ITEM_ACTIONS,x                         ; DAF4 BD 06 DB                 ...
        sta     TEMP_JUMP_LO                           ; DAF7 85 0C                    ..
        lda     JMP_TBL_ITEM_ACTIONS+1,x                       ; DAF9 BD 07 DB                 ...
        sta     TEMP_JUMP_HI                             ; DAFC 85 0D                    ..
        jmp     (TEMP_JUMP_LO)                         ; DAFE 6C 0C 00                 l..

; ----------------------------------------------------------------------------
PLAY_OPEN_DOOR_SOUND:
        lda     #SOUND_OPEN_DOOR                            ; DB01 A9 06                    ..
        sta     NEXT_SOUND_EFFECT                             ; DB03 85 8F                    ..
        rts                                     ; DB05 60                       `

; ----------------------------------------------------------------------------
; What happens when items from monsters or chests are collected.
JMP_TBL_ITEM_ACTIONS:
        .addr   ACTION_BREAD                           ; DB06 26 DB                    &.
        .addr   ACTION_MAGIC                           ; DB08 31 DB                    1.
        .addr   ACTION_GOLDS                           ; DB0A 3C DB                    <.
        .addr   ACTION_POISON                           ; DB0C 52 DB                    R.
        .addr   ACTION_KEY                           ; DB0E 5D DB                    ].
        .addr   ACTION_RING_10S                           ; DB10 71 DB                    q.
        .addr   ACTION_CROSS                           ; DB12 B7 DB                    ..
        .addr   ACTION_MONSTER_DROP_SCROLL                           ; DB14 85 DB                    ..
JMP_TBL_CHEST_ITEM_ACTIONS:        
		.addr   ACTION_ELIXIR                           ; DB16 6A D1                    j.
        .addr   ACTION_MAGIC_BOTTLE                           ; DB18 99 D1                    ..
        .addr   ACTION_CHEST_GOLDS                           ; DB1A 47 DB                    G.
        ; ? unused
		.addr   ACTION_POISON                           ; DB1C 52 DB                    R.
        .addr   ACTION_CHEST_KEY                           ; DB1E 66 DB                    f.
        ; ? unused
		.addr   ACTION_RING_30S                           ; DB20 7B DB                    {.
        ; ? unused
		.addr   ACTION_CROSS                           ; DB22 B7 DB                    ..
        .addr   ACTION_CHEST_SCROLL                           ; DB24 9B DB                    ..
; ----------------------------------------------------------------------------
; bread adds 5 life
ACTION_BREAD:
        lda     #SOUND_BREAD                            ; DB26 A9 1E                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB28 8D 8F 00                 ...
        lda     #$05                            ; DB2B A9 05                    ..
        jsr     ADD_PLAYER_LIFE                           ; DB2D 20 00 E8                  ..
        rts                                     ; DB30 60                       `

; ----------------------------------------------------------------------------
; potion adds 5 magic
ACTION_MAGIC:
        lda     #SOUND_POTION_MONEY                            ; DB31 A9 11                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB33 8D 8F 00                 ...
        lda     #$05                            ; DB36 A9 05                    ..
        jsr     ADD_PLAYER_MAGIC                           ; DB38 20 16 E8                  ..
        rts                                     ; DB3B 60                       `

; ----------------------------------------------------------------------------
; golds adds 2 golds
ACTION_GOLDS:
        lda     #SOUND_POTION_MONEY                            ; DB3C A9 11                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB3E 8D 8F 00                 ...
        lda     #$02                            ; DB41 A9 02                    ..
        jsr     ADD_PLAYER_GOLDS                           ; DB43 20 2C E8                  ,.
        rts                                     ; DB46 60                       `

; ----------------------------------------------------------------------------
; golds from a chest adds 50 golds
ACTION_CHEST_GOLDS:
        lda     #SOUND_POTION_MONEY                            ; DB47 A9 11                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB49 8D 8F 00                 ...
        lda     #$32                            ; DB4C A9 32                    .2
        jsr     ADD_PLAYER_GOLDS                           ; DB4E 20 2C E8                  ,.
        rts                                     ; DB51 60                       `

; ----------------------------------------------------------------------------
; poison takes 5 life
ACTION_POISON:
        lda     #SOUND_POISON                            ; DB52 A9 1D                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB54 8D 8F 00                 ...
        lda     #$05                            ; DB57 A9 05                    ..
        jsr     STEAL_PLAYER_LIFE                           ; DB59 20 DB E7                  ..
        rts                                     ; DB5C 60                       `

; ----------------------------------------------------------------------------
; key adds 1 key
ACTION_KEY:
        lda     #SOUND_KEY                            ; DB5D A9 15                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB5F 8D 8F 00                 ...
        jsr     GIVE_PLAYER_KEY                           ; DB62 20 52 E8                  R.
        rts                                     ; DB65 60                       `

; ----------------------------------------------------------------------------
; chest key adds 20 keys
ACTION_CHEST_KEY:
        lda     #SOUND_KEY                            ; DB66 A9 15                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB68 8D 8F 00                 ...
        lda     #$14                            ; DB6B A9 14                    ..
        jsr     CAP_PLAYER_CHEST_KEY                           ; DB6D 20 59 E8                  Y.
        rts                                     ; DB70 60                       `

; ----------------------------------------------------------------------------
; ring gives 10s invulnerability
ACTION_RING_10S:
        lda     #SOUND_RING_SCROLL                            ; DB71 A9 13                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB73 8D 8F 00                 ...
        lda     #$0A                            ; DB76 A9 0A                    ..
        sta     INVULN_CTR                             ; DB78 85 85                    ..
        rts                                     ; DB7A 60                       `

; ----------------------------------------------------------------------------
; unused chest-ring routine that gives 30s of invulnerability
ACTION_RING_30S:
        lda     #SOUND_RING_SCROLL                            ; DB7B A9 13                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB7D 8D 8F 00                 ...
        lda     #$1E                            ; DB80 A9 1E                    ..
        sta     INVULN_CTR                             ; DB82 85 85                    ..
        rts                                     ; DB84 60                       `

; ----------------------------------------------------------------------------
; monster drop scroll bumps speed for 30s, also refreshes any other active scroll
; counters
ACTION_MONSTER_DROP_SCROLL:
		lda     #SOUND_RING_SCROLL                            ; DB85 A9 13                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB87 8D 8F 00                 ...
        
		; apply 30 seconds to the correct # of scroll vars (max 3)
		ldx     #$1E                            ; DB8A A2 1E                    ..
        lda     CTR_SPEED_SCROLL_1                             ; DB8C A5 88                    ..
        beq     LDB98                           ; DB8E F0 08                    ..
        lda     CTR_SPEED_SCROLL_2                             ; DB90 A5 89                    ..
        beq     LDB96                           ; DB92 F0 02                    ..
        stx     CTR_SPEED_SCROLL_3                             ; DB94 86 8A                    ..
LDB96:
        stx     CTR_SPEED_SCROLL_2                             ; DB96 86 89                    ..
LDB98:
        stx     CTR_SPEED_SCROLL_1                             ; DB98 86 88                    ..
        rts                                     ; DB9A 60                       `

; ----------------------------------------------------------------------------
; chest scroll bumps speed for 60 seconds, and refreshes any active scrolls
ACTION_CHEST_SCROLL:
        lda     #SOUND_RING_SCROLL                            ; DB9B A9 13                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DB9D 8D 8F 00                 ...
        
		; apply 60 seconds to the correct # of scroll vars (max 4)
		ldx     #$3C                            ; DBA0 A2 3C                    .<
        lda     CTR_SPEED_SCROLL_1                             ; DBA2 A5 88                    ..
        beq     LDBB4                           ; DBA4 F0 0E                    ..
        lda     CTR_SPEED_SCROLL_2                             ; DBA6 A5 89                    ..
        beq     LDBB2                           ; DBA8 F0 08                    ..
        lda     CTR_SPEED_SCROLL_3                             ; DBAA A5 8A                    ..
        beq     LDBB0                           ; DBAC F0 02                    ..
        stx     CTR_SPEED_SCROLL_CHEST                             ; DBAE 86 8B                    ..
LDBB0:
        stx     CTR_SPEED_SCROLL_3                             ; DBB0 86 8A                    ..
LDBB2:
        stx     CTR_SPEED_SCROLL_2                             ; DBB2 86 89                    ..
LDBB4:
        stx     CTR_SPEED_SCROLL_1                             ; DBB4 86 88                    ..
        rts                                     ; DBB6 60                       `

; ----------------------------------------------------------------------------
; cross kills all enemies
ACTION_CROSS:
        ldx     #$09                            ; DBB7 A2 09                    ..
        ldy     #$00                            ; DBB9 A0 00                    ..
LDBBB:
		; branch if not an enemy
        lda     OBJ_GENERAL_TYPE,y                         ; DBBB B9 01 04                 ...
        cmp     #OBJ_GEN_TYPE_ENEMY                            ; DBBE C9 01                    ..
        bne     LDBC7                           ; DBC0 D0 05                    ..
        
		; it is an enemy; kill it
		lda     #OBJ_GEN_TYPE_ENEMY_JUST_KILLED                            ; DBC2 A9 80                    ..
        sta     OBJ_GENERAL_TYPE,y                         ; DBC4 99 01 04                 ...
LDBC7:
        tya                                     ; DBC7 98                       .
        clc                                     ; DBC8 18                       .
        adc     #$10                            ; DBC9 69 10                    i.
        tay                                     ; DBCB A8                       .
        dex                                     ; DBCC CA                       .
        
		; loop until x=0
		bne     LDBBB                           ; DBCD D0 EC                    ..
        lda     #SOUND_CROSS                            ; DBCF A9 18                    ..
        sta     NEXT_SOUND_EFFECT                             ; DBD1 85 8F                    ..
        lda     #$FF                            ; DBD3 A9 FF                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; DBD5 85 90                    ..
        ldx     #$02                            ; DBD7 A2 02                    ..
        jsr     FLASH_EFFECT_C540                           ; DBD9 20 40 C5                  @.
        rts                                     ; DBDC 60                       `

; ----------------------------------------------------------------------------
; checks for whether a player descent should continue or stop
; if we hit an enemy, checks if the magic boots kill it
; if we hit enemy or solid terrain, check for a hard landing
; if we're on spikes, check if we need to take damage
HANDLE_PLAYER_DESCENT:
        ; branch if wings are active
		lda     CTR_WINGS_MAGIC                             ; DBDD A5 86                    ..
        bne     LDBE5                           ; DBDF D0 04                    ..
        
		; branch if we're not ascending during a jump or spike bounce
		lda     JUMP_FRAMES_REMAINING                             ; DBE1 A5 4F                    .O
        beq     LDBEC                           ; DBE3 F0 07                    ..
LDBE5:
		; we have wings or are ascending during a jump; can't be on a ladder
		; and are not descending - jmp below to cancel descent
        lda     #$00                            ; DBE5 A9 00                    ..
        sta     ON_LADDER_FLAG                             ; DBE7 85 50                    .P
        jmp     LDC82                           ; DBE9 4C 82 DC                 L..

; ----------------------------------------------------------------------------
LDBEC:
		; copy player values to the temp versions
        lda     PX_HI                             ; DBEC A5 44                    .D
        sta     SCRATCH_0C                           ; DBEE 85 0C                    ..
        sta     TEMP_NEXT_X_HI                             ; DBF0 85 0F                    ..
        lda     PX_LO                             ; DBF2 A5 43                    .C
        sta     TEMP_NEXT_X_LO                           ; DBF4 85 0E                    ..
        ldx     PY                             ; DBF6 A6 45                    .E
        stx     SCRATCH_0D                             ; DBF8 86 0D                    ..
        
		; PY+1 --> $0A
		inx                                     ; DBFA E8                       .
        stx     LOOP_COUNTER_0A                             ; DBFB 86 0A                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; DBFD 20 54 CA                  T.
        
		; branch if not perfectly aligned to x block
		lda     PX_LO                             ; DC00 A5 43                    .C
        bne     LDC10                           ; DC02 D0 0C                    ..
        
		; odd logic here - assumes we're on ladder, then checks
		; if we really are on ladder (e.g. tile x40), we branch to CHECK_HARD_LANDING
		lda     #$01                            ; DC04 A9 01                    ..
        sta     ON_LADDER_FLAG                             ; DC06 85 50                    .P
        ldy     #$00                            ; DC08 A0 00                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; DC0A B1 0C                    ..
        and     #$3F                            ; DC0C 29 3F                    )?
        beq     CHECK_HARD_LANDING                           ; DC0E F0 3D                    .=
LDC10:
		; we're not really on a ladder
        lda     #$00                            ; DC10 A9 00                    ..
        sta     ON_LADDER_FLAG                             ; DC12 85 50                    .P
        
		; branch if PY>xB0 - too low on screen to land on something
		lda     PY                             ; DC14 A5 45                    .E
        cmp     #$B0                            ; DC16 C9 B0                    ..
        bcs     LDC4A                           ; DC18 B0 30                    .0
        
		; branch if we did not hit an enemy
		jsr     CHECK_TEMP_POS_HIT_OBJECT                           ; DC1A 20 B2 CD                  ..
        bcc     LDC38                           ; DC1D 90 19                    ..
        
		; we did
		; SCRATCH_08 - slot # of object we hit
		; SCRATCH_09 - offset to object we hit (slot # * 0x10)
		
		; no magic boots check if on boss screen
		lda     CHR_BANK_ENEMY_SPRITES                             ; DC1F A5 2D                    .-
        cmp     #SPRITE_PT_TARATUNES                            ; DC21 C9 30                    .0
        bcs     CHECK_HARD_LANDING                           ; DC23 B0 28                    .(
        
		; see if we have the boots on
		ldy     CUR_EQUIP_SLOT_SELECTED                             ; DC25 A4 55                    .U
        ldx     CUR_EQUIP_ITEMS,y                           ; DC27 B6 51                    .Q
        cpx     #INV_ITEM_MAGIC_BOOTS                            ; DC29 E0 05                    ..
        bne     CHECK_HARD_LANDING                           ; DC2B D0 20                    . 
        
		; magic boots don't do anything if we're not descending at time of collision
		lda     CTR_PLAYER_DESCENT                             ; DC2D A5 4E                    .N
        beq     CHECK_HARD_LANDING                           ; DC2F F0 1C                    ..
        
		; kill enemy we just landed on with magic boots
		; then follow through into no-collision branch
		ldx     SCRATCH_09                             ; DC31 A6 09                    ..
        lda     #OBJ_GEN_TYPE_ENEMY_JUST_KILLED                            ; DC33 A9 80                    ..
        sta     OBJ_GENERAL_TYPE,x                         ; DC35 9D 01 04                 ...
LDC38:
		; no collision, or we just killed something with the magic boots
        ; looks like this checks if we hit ground?
		; check left tile
		ldy     #$01                            ; DC38 A0 01                    ..
        jsr     CHECK_SOLID_TILE                           ; DC3A 20 CC DC                  ..
        bcs     CHECK_HARD_LANDING                           ; DC3D B0 0E                    ..
        
		; no second tile to check if we're aligned to block
		lda     PX_LO                             ; DC3F A5 43                    .C
        beq     LDC4A                           ; DC41 F0 07                    ..
        
		; not aligned to block, check right tile
		ldy     #$0D                            ; DC43 A0 0D                    ..
        jsr     CHECK_SOLID_TILE                           ; DC45 20 CC DC                  ..
        bcs     CHECK_HARD_LANDING                           ; DC48 B0 03                    ..
LDC4A:
		; continue descent
        inc     CTR_PLAYER_DESCENT                             ; DC4A E6 4E                    .N
        rts                                     ; DC4C 60                       `

; ----------------------------------------------------------------------------
; check if the player has fallen far enough to be injured on landing
; note this can include landing on tiles or objects
; ladder can only be landed on if aligned to its block on x
CHECK_HARD_LANDING:
        lda     CTR_PLAYER_DESCENT                             ; DC4D A5 4E                    .N
        cmp     PLAYER_JUMP_FRAMES                             ; DC4F C5 5C                    .\
        
		; branch if CTR_PLAYER_DESCENT<our jump height, no hard landing
		bcc     LDC6E                           ; DC51 90 1B                    ..
        
		; CTR_PLAYER_DESCENT>=jump height
		sec                                     ; DC53 38                       8
        sbc     #$07                            ; DC54 E9 07                    ..
        cmp     PLAYER_JUMP_FRAMES                             ; DC56 C5 5C                    .\
        
		; branch if CTR_PLAYER_DESCENT <7 above jump height
		bcc     LDC5C                           ; DC58 90 02                    ..
        
		; otherwise, use the jump height
		; so bounce is bigger the longer the fall was, but will always be
		; at least 1 less than PLAYER_JUMP_FRAMES
		lda     PLAYER_JUMP_FRAMES                             ; DC5A A5 5C                    .\
LDC5C:
        sec                                     ; DC5C 38                       8
        sbc     #$01                            ; DC5D E9 01                    ..
        sta     JUMP_FRAMES_REMAINING                             ; DC5F 85 4F                    .O
        
		; and player is disabled 10 frames beyond the top of the bounce
		clc                                     ; DC61 18                       .
        adc     #$0A                            ; DC62 69 0A                    i.
        sta     PLAYER_HARD_LANDING_CTR                             ; DC64 85 46                    .F
        lda     #SOUND_HARD_LANDING                            ; DC66 A9 0A                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DC68 8D 8F 00                 ...
        jsr     DECREMENT_PLAYER_LIFE                           ; DC6B 20 CE E7                  ..
LDC6E:
        lda     CTR_PLAYER_DESCENT                             ; DC6E A5 4E                    .N
        bne     LDC82                           ; DC70 D0 10                    ..
        
		; y is input into CHECK_SPIKE_DAMAGE
		; check first tile we're touching for nasty spikes
		ldy     #$01                            ; DC72 A0 01                    ..
        jsr     CHECK_SPIKE_DAMAGE                           ; DC74 20 A8 DC                  ..
        bcs     LDC82                           ; DC77 B0 09                    ..
        
		; branch (skip 2nd spike damage check) if PX_LO = 0
		; we're only touching one tile so no need to check two
		lda     PX_LO                             ; DC79 A5 43                    .C
        beq     LDC82                           ; DC7B F0 05                    ..
        
		; we're not perfectly aligned to tile - check 2nd one for spikes
		ldy     #$0D                            ; DC7D A0 0D                    ..
        jsr     CHECK_SPIKE_DAMAGE                           ; DC7F 20 A8 DC                  ..

LDC82:
		; we are not descending
        lda     #$00                            ; DC82 A9 00                    ..
        sta     CTR_PLAYER_DESCENT                             ; DC84 85 4E                    .N
        rts                                     ; DC86 60                       `

; ----------------------------------------------------------------------------
; return - carry set if player can go up, clear if not
CHECK_CAN_SCROLL_UP:
		; branch if either wings or jump ascent active
        lda     CTR_WINGS_MAGIC                             ; DC87 A5 86                    ..
        ora     JUMP_FRAMES_REMAINING                             ; DC89 05 4F                    .O
        bne     LDCA6                           ; DC8B D0 19                    ..
       
	   ; no wings or jump ascent
	   ; branch if TEMP_NEXT_X_LO <> 0 (think this is next PY as calculated by CALC_NEXT_PLAYER_POS)
	   lda     TEMP_NEXT_X_LO                           ; DC8D A5 0E                    ..
        bne     LDCA4                           ; DC8F D0 13                    ..
        
		lda     TEMP_NEXT_X_HI                             ; DC91 A5 0F                    ..
        sta     PLAYER_MAP_TILE_LO                           ; DC93 85 0C                    ..
        lda     #$00                            ; DC95 A9 00                    ..
        sta     PLAYER_MAP_TILE_HI                             ; DC97 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; DC99 20 54 CA                  T.
        ldy     #$00                            ; DC9C A0 00                    ..
        
		; check tile above - branch if lower 6 bits zero, e.g. x40=ladder
		lda     (PLAYER_MAP_TILE_PTR),y                       ; DC9E B1 0C                    ..
        and     #$3F                            ; DCA0 29 3F                    )?
        beq     LDCA6                           ; DCA2 F0 02                    ..
LDCA4:
		; cannot go up
        clc                                     ; DCA4 18                       .
        rts                                     ; DCA5 60                       `

; ----------------------------------------------------------------------------
LDCA6:
		; ok to go up
        sec                                     ; DCA6 38                       8
        rts                                     ; DCA7 60                       `

; ----------------------------------------------------------------------------
; check if we are getting damaged by spikes; apply damage and a small jump if so
; return - carry set if on a spike
CHECK_SPIKE_DAMAGE:
        
		; branch if tile below player is not a spike
		lda     (PLAYER_MAP_TILE_PTR),y                       ; DCA8 B1 0C                    ..
        and     #$3F                            ; DCAA 29 3F                    )?
        cmp     #$30                            ; DCAC C9 30                    .0
		bne     LDCCA                           ; DCAE D0 1A                    ..
        
		; it's a spike
		; branch if JUMP_FRAMES_REMAINING <> 0
		lda     JUMP_FRAMES_REMAINING                             ; DCB0 A5 4F                    .O
        bne     LDCB8                           ; DCB2 D0 04                    ..
        
		; not currently jumping; give a little jump
		lda     #$0A                            ; DCB4 A9 0A                    ..
        sta     JUMP_FRAMES_REMAINING                             ; DCB6 85 4F                    .O
LDCB8:
        ; branch (no damage) if invulnerable
		lda     INVULN_CTR                             ; DCB8 A5 85                    ..
		bne     LDCC8                           ; DCBA D0 0C                    ..
        
		; not invulerable; play sound, give 1s invulnerability, take damage
		jsr     DECREMENT_PLAYER_LIFE                           ; DCBC 20 CE E7                  ..
        lda     #SOUND_HARD_LANDING                            ; DCBF A9 0A                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DCC1 8D 8F 00                 ...
        lda     #$01                            ; DCC4 A9 01                    ..
        sta     INVULN_CTR                             ; DCC6 85 85                    ..
LDCC8:
        ; set carry = on a spike
		sec                                     ; DCC8 38                       8
        rts                                     ; DCC9 60                       `

; ----------------------------------------------------------------------------
LDCCA:
        ; clear carry = no spike
		clc                                     ; DCCA 18                       .
        rts                                     ; DCCB 60                       `

; ----------------------------------------------------------------------------
; check if tile at offset y is solid
; return - carry set if solid, else clear
CHECK_SOLID_TILE:
		; branch if lower 6 bits are 0 (e.g. ladder x40)
        lda     (PLAYER_MAP_TILE_PTR),y                       ; DCCC B1 0C                    ..
        and     #$3F                            ; DCCE 29 3F                    )?
        tax                                     ; DCD0 AA                       .
		beq     LDCDA                           ; DCD1 F0 07                    ..
        
		; if lower 6 bits = 2, solid
		cpx     #$02                            ; DCD3 E0 02                    ..
        beq     LDCE0                           ; DCD5 F0 09                    ..
        
		; otherwise, if lower 6 bits >= x30 we are solid
		cpx     #$30                            ; DCD7 E0 30                    .0
        rts                                     ; DCD9 60                       `

; ----------------------------------------------------------------------------
LDCDA:
		; only solid if we're aligned to it in x - think this only applies to ladder?
        lda     PX_LO                             ; DCDA A5 43                    .C
        beq     LDCE0                           ; DCDC F0 02                    ..
        
		; not solid
		clc                                     ; DCDE 18                       .
        rts                                     ; DCDF 60                       `

; ----------------------------------------------------------------------------
LDCE0:
		; solid
        sec                                     ; DCE0 38                       8
        rts                                     ; DCE1 60                       `

; ----------------------------------------------------------------------------
; called when up is pressed; check if we need to enter the home or shop/inn
CHECK_SPECIAL_ENTRANCES:
        ldx     PY                             ; DCE2 A6 45                    .E
        
		; branch (rts) if PY = 0
		beq     LDD18                           ; DCE4 F0 32                    .2
        
		; else x-1 --> TILE_HI, PX_HI --> TILE_LO
		dex                                     ; DCE6 CA                       .
        stx     PLAYER_MAP_TILE_HI                             ; DCE7 86 0D                    ..
        ldx     PX_HI                             ; DCE9 A6 44                    .D
        stx     PLAYER_MAP_TILE_LO                           ; DCEB 86 0C                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; DCED 20 54 CA                  T.
        ldy     #$00                            ; DCF0 A0 00                    ..
        
		; branch if lower 6 bits of player tile = 5
		lda     (PLAYER_MAP_TILE_PTR),y                       ; DCF2 B1 0C                    ..
        and     #$3F                            ; DCF4 29 3F                    )?
        cmp     #TILE_INN                            ; DCF6 C9 05                    ..
        beq     HANDLE_TILE_INN_HOME                           ; DCF8 F0 1F                    ..
        
		; branch if lower 6 = 4
		cmp     #TILE_SHOP                            ; DCFA C9 04                    ..
        beq     HANDLE_TILE_SHOP                           ; DCFC F0 20                    . 
        
		; branch if lower 6 = 3
		cmp     #TILE_PRINCESS_PORTRAIT                            ; DCFE C9 03                    ..
        beq     HANDLE_TILE_PRINCESS                           ; DD00 F0 21                    .!
        
		; branch if PX_LO = 0, (aligned to block horizontally; no need to check a 2nd tile)
		lda     PX_LO                             ; DD02 A5 43                    .C
        beq     LDD18                           ; DD04 F0 12                    ..
        
		; not aligned perfectly, check the second tile we're touching
		ldy     #$0C                            ; DD06 A0 0C                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; DD08 B1 0C                    ..
        and     #$3F                            ; DD0A 29 3F                    )?
        
		; inn or home
		cmp     #TILE_INN                            ; DD0C C9 05                    ..
        beq     HANDLE_TILE_INN_HOME                           ; DD0E F0 09                    ..
        
		; shop
		cmp     #TILE_SHOP                            ; DD10 C9 04                    ..
        beq     HANDLE_TILE_SHOP                           ; DD12 F0 0A                    ..
        
		; princess portrait
		cmp     #TILE_PRINCESS_PORTRAIT                            ; DD14 C9 03                    ..
        beq     HANDLE_TILE_PRINCESS                           ; DD16 F0 0B                    ..
LDD18:
		; no special entrance
        rts                                     ; DD18 60                       `

; ----------------------------------------------------------------------------
; touching tile 5 - enter the inn or home, don't return to caller
HANDLE_TILE_INN_HOME:
        pla                                     ; DD19 68                       h
        pla                                     ; DD1A 68                       h
        jmp     ENTER_INN_HOME                           ; DD1B 4C 77 E0                 Lw.

; ----------------------------------------------------------------------------
; touching tile 4 - jump to enter a shop, don't return to caller
HANDLE_TILE_SHOP:
        pla                                     ; DD1E 68                       h
        pla                                     ; DD1F 68                       h
        jmp     ENTER_SHOP                           ; DD20 4C 24 E4                 L$.

; ----------------------------------------------------------------------------
; touching tile 3 - the princess portrait!
HANDLE_TILE_PRINCESS:
        ldx     CUR_EQUIP_SLOT_SELECTED                             ; DD23 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; DD25 B5 51                    .Q
        cmp     #INV_ITEM_CROWN                            ; DD27 C9 0E                    ..
        
		; branch (rts) if crown not equipped
		bne     LDD18                           ; DD29 D0 ED                    ..
        
		; crown equipped, ooh
		ldx     #$02                            ; DD2B A2 02                    ..
        
		; start with crowns in inventory
		ldy     PLAYER_INVENTORY_CROWNS                             ; DD2D A4 6E                    .n
        lda     #INV_ITEM_CROWN                            ; DD2F A9 0E                    ..
LDD31:
        ; add any equipped crowns to the total
		cmp     CUR_EQUIP_ITEMS,x                           ; DD31 D5 51                    .Q
        bne     LDD36                           ; DD33 D0 01                    ..
        iny                                     ; DD35 C8                       .
LDD36:
        dex                                     ; DD36 CA                       .
        bpl     LDD31                           ; DD37 10 F8                    ..
        
		; see if we have 4 total, between inventory and equipped
		; rts if not
		cpy     #$04                            ; DD39 C0 04                    ..
        bne     LDD18                           ; DD3B D0 DB                    ..
        
		; we have 4 total crowns! jump to PORTRAIT_WARP and don't return to caller
		pla                                     ; DD3D 68                       h
        pla                                     ; DD3E 68                       h
        jmp     PORTRAIT_WARP                           ; DD3F 4C F3 D5                 L..

; ----------------------------------------------------------------------------
; check any tiles the player might be touching and if needed apply things
; like spike damage, block moving, etc.
CHECK_PLAYER_TOUCHING_TILES:
        lda     #$90                            ; DD42 A9 90                    ..
        sta     CUR_OBJ_PTR_LO                             ; DD44 85 E5                    ..
        lda     #$04                            ; DD46 A9 04                    ..
        sta     CUR_OBJ_PTR_HI                             ; DD48 85 E6                    ..
        
		; save position vars
		lda     TEMP_NEXT_X_LO                           ; DD4A A5 0E                    ..
        pha                                     ; DD4C 48                       H
        lda     TEMP_NEXT_X_HI                             ; DD4D A5 0F                    ..
        pha                                     ; DD4F 48                       H
        lda     TEMP_NEXT_Y                             ; DD50 A5 0A                    ..
        pha                                     ; DD52 48                       H
        
		lda     TEMP_NEXT_X_HI                             ; DD53 A5 0F                    ..
        sta     PLAYER_MAP_TILE_LO                           ; DD55 85 0C                    ..
        lda     TEMP_NEXT_Y                             ; DD57 A5 0A                    ..
        sta     PLAYER_MAP_TILE_HI                             ; DD59 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; DD5B 20 54 CA                  T.
        
		; check left upper tile
		ldy     #$00                            ; DD5E A0 00                    ..
        jsr     HANDLE_TOUCH_TILE_EFFECTS                           ; DD60 20 97 DD                  ..
        bcs     LDD8D                           ; DD63 B0 28                    .(
        
		; only 1 tile to check if aligned on x
		lda     TEMP_NEXT_X_LO                           ; DD65 A5 0E                    ..
        beq     LDD70                           ; DD67 F0 07                    ..
        
		; check right upper tile
		ldy     #$0C                            ; DD69 A0 0C                    ..
        jsr     HANDLE_TOUCH_TILE_EFFECTS                           ; DD6B 20 97 DD                  ..
        bcs     LDD8D                           ; DD6E B0 1D                    ..
LDD70:
        ; branch if too low to affect a block
		lda     TEMP_NEXT_Y                             ; DD70 A5 0A                    ..
        cmp     #$B0                            ; DD72 C9 B0                    ..
        bcs     LDD8C                           ; DD74 B0 16                    ..
        
		; if aligned in y, no additional blocks to check
		and     #$0F                            ; DD76 29 0F                    ).
        beq     LDD8C                           ; DD78 F0 12                    ..
        
		; check left lower tile
		ldy     #$01                            ; DD7A A0 01                    ..
        jsr     HANDLE_TOUCH_TILE_EFFECTS                           ; DD7C 20 97 DD                  ..
        bcs     LDD8D                           ; DD7F B0 0C                    ..
        
		; only 1 tile to check if aligned on x
		lda     TEMP_NEXT_X_LO                           ; DD81 A5 0E                    ..
        beq     LDD8C                           ; DD83 F0 07                    ..
        
		; check right lower tile
		ldy     #$0D                            ; DD85 A0 0D                    ..
        jsr     HANDLE_TOUCH_TILE_EFFECTS                           ; DD87 20 97 DD                  ..
        bcs     LDD8D                           ; DD8A B0 01                    ..
LDD8C:
		; no block modified
        clc                                     ; DD8C 18                       .
LDD8D:
		; restore original values
        pla                                     ; DD8D 68                       h
        sta     TEMP_NEXT_Y                             ; DD8E 85 0A                    ..
        pla                                     ; DD90 68                       h
        sta     TEMP_NEXT_X_HI                             ; DD91 85 0F                    ..
        pla                                     ; DD93 68                       h
        sta     TEMP_NEXT_X_LO                           ; DD94 85 0E                    ..
        rts                                     ; DD96 60                       `

; ----------------------------------------------------------------------------
; input - y, used to indicate which tile to check
; return - carry set if we did something to a tile; clear otherwise
HANDLE_TOUCH_TILE_EFFECTS:
		; branch if the tile doesn't match this map's 'fake' tile
        lda     (PLAYER_MAP_TILE_PTR),y                       ; DD97 B1 0C                    ..
        and     #$3F                            ; DD99 29 3F                    )?
        cmp     MAP_FAKE_TILE_ID                             ; DD9B C5 70                    .p
        bne     LDDA2                           ; DD9D D0 03                    ..
        
		; it does match; jump
		jmp     HANDLE_TOUCH_FAKE_TILE                           ; DD9F 4C B3 DD                 L..

; ----------------------------------------------------------------------------
LDDA2:
		; branch if tile lower 6 bits <> 2
        cmp     #$02                            ; DDA2 C9 02                    ..
        bne     LDDA9                           ; DDA4 D0 03                    ..
        
		; tile lower 6 = 2
		jmp     HANDLE_TOUCH_KEY_DOOR                           ; DDA6 4C E0 DD                 L..

; ----------------------------------------------------------------------------
LDDA9:
		; branch if tile lower 6 <> x3E
        cmp     #$3E                            ; DDA9 C9 3E                    .>
        bne     LDDB0                           ; DDAB D0 03                    ..
        
		; tile lower 6 = x3E (moveable block)
		jmp     HANDLE_TOUCH_MOVEABLE_BLOCK                           ; DDAD 4C 1A DE                 L..

; ----------------------------------------------------------------------------
LDDB0:
		; sets carry if tile lower 6 bits >= x30 (spikes)
        cmp     #$30                            ; DDB0 C9 30                    .0
        rts                                     ; DDB2 60                       `

; ----------------------------------------------------------------------------
; fake tile that gets substituted when touched by player - specified for each map
HANDLE_TOUCH_FAKE_TILE:
        ; skip action if already animating something else
		lda     BLOCK_ANIMATION_FLAG                           ; DDB3 AD 91 04                 ...
        bne     LDDD9                           ; DDB6 D0 21                    .!
        
		; configure the sprite
		sty     SCRATCH_0B                             ; DDB8 84 0B                    ..
        lda     #$E1                            ; DDBA A9 E1                    ..
        sta     CUR_OBJ_SPRITE                             ; DDBC 85 ED                    ..
        lda     #OBJ_GEN_TYPE_ENEMY                            ; DDBE A9 01                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; DDC0 85 EE                    ..
        lda     #$01                            ; DDC2 A9 01                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; DDC4 85 EF                    ..
        lda     MAP_REPLACEMENT_TILE_ID                             ; DDC6 A5 71                    .q
        sta     CUR_OBJ_FALL_SPEED                             ; DDC8 85 F0                    ..
        lda     #$0A                            ; DDCA A9 0A                    ..
        sta     CUR_OBJ_MISC_CTR                             ; DDCC 85 F3                    ..
        
		; move, save, make the sound effect
		jsr     SET_TEMP_OBJECT_NEXT_POS                           ; DDCE 20 37 DF                  7.
        jsr     SAVE_CUR_OBJ                           ; DDD1 20 9A E9                  ..
        lda     #SOUND_OPEN_DOOR                            ; DDD4 A9 06                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DDD6 8D 8F 00                 ...
LDDD9:
		; set carry (solidity) using substituted tile
        lda     MAP_REPLACEMENT_TILE_ID                             ; DDD9 A5 71                    .q
        and     #$3F                            ; DDDB 29 3F                    )?
        cmp     #$30                            ; DDDD C9 30                    .0
        rts                                     ; DDDF 60                       `

; ----------------------------------------------------------------------------
HANDLE_TOUCH_KEY_DOOR:
        ; branch (skip) if already animating something else
		lda     BLOCK_ANIMATION_FLAG                           ; DDE0 AD 91 04                 ...
        bne     LDE18                           ; DDE3 D0 33                    .3
        sty     SCRATCH_0B                             ; DDE5 84 0B                    ..
        
		; branch if key stick not equipped
		ldx     CUR_EQUIP_SLOT_SELECTED                             ; DDE7 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; DDE9 B5 51                    .Q
        cmp     #INV_ITEM_KEY_STICK                            ; DDEB C9 07                    ..
        bne     LDDF4                           ; DDED D0 05                    ..
        
		; key stick equipped; try to use magic instead of key
		; branch if we had magic (carry clear), else fall back on using a key
		jsr     DECREMENT_PLAYER_MAGIC                           ; DDEF 20 F0 E7                  ..
        bcc     OPEN_DOOR                           ; DDF2 90 05                    ..
LDDF4:
		; key stick not equipped; use key
        jsr     USE_NORMAL_KEY                           ; DDF4 20 6F E8                  o.
        
		; branch if carry set (no keys avail)
		bcs     LDE18                           ; DDF7 B0 1F                    ..
OPEN_DOOR:
		; prepare animation sprite
        lda     #$E1                            ; DDF9 A9 E1                    ..
        sta     CUR_OBJ_SPRITE                             ; DDFB 85 ED                    ..
        lda     #OBJ_GEN_TYPE_ENEMY                            ; DDFD A9 01                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; DDFF 85 EE                    ..
        lda     #$01                            ; DE01 A9 01                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; DE03 85 EF                    ..
        lda     MOVEABLE_BLOCK_REPLACEMENT_TILE_ID                             ; DE05 A5 74                    .t
        sta     CUR_OBJ_FALL_SPEED                             ; DE07 85 F0                    ..
        lda     #$0F                            ; DE09 A9 0F                    ..
        sta     CUR_OBJ_MISC_CTR                             ; DE0B 85 F3                    ..
        
		; position sprite, save object, make the sound
		jsr     SET_TEMP_OBJECT_NEXT_POS                           ; DE0D 20 37 DF                  7.
        jsr     SAVE_CUR_OBJ                           ; DE10 20 9A E9                  ..
        lda     #SOUND_OPEN_DOOR                            ; DE13 A9 06                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DE15 8D 8F 00                 ...
LDE18:
        sec                                     ; DE18 38                       8
        rts                                     ; DE19 60                       `

; ----------------------------------------------------------------------------
HANDLE_TOUCH_MOVEABLE_BLOCK:
        ; branch if a not pressed
		bit     JOYPAD_INPUT                             ; DE1A 24 20                    $ 
        bpl     LDE37                           ; DE1C 10 19                    ..
        
		; a pressed; branch if animation already in progress
		lda     BLOCK_ANIMATION_FLAG                           ; DE1E AD 91 04                 ...
        bne     LDE37                           ; DE21 D0 14                    ..
        
		; no animation in progress; we can manipulate this block
		sty     SCRATCH_0B                             ; DE23 84 0B                    ..
        lda     #$01                            ; DE25 A9 01                    ..
        sta     CUR_OBJ_DIR                             ; DE27 85 F4                    ..
        
		; selected item --> x
		ldy     CUR_EQUIP_SLOT_SELECTED                             ; DE29 A4 55                    .U
        ldx     CUR_EQUIP_ITEMS,y                           ; DE2B B6 51                    .Q
        dex                                     ; DE2D CA                       .
        dex                                     ; DE2E CA                       .
        
		; branch if mattock selected
		beq     CHECK_MATTOCK_ACTION                           ; DE2F F0 0E                    ..
        dex                                     ; DE31 CA                       .
        
		; branch if glove selected
		beq     JUMP_TO_CHECK_GLOVE_ACTION                           ; DE32 F0 05                    ..
        
		; branch if crossbow selected
		dex                                     ; DE34 CA                       .
        beq     JUMP_TO_CHECK_CROSSBOW_ACTION                           ; DE35 F0 05                    ..
LDE37:
        sec                                     ; DE37 38                       8
        rts                                     ; DE38 60                       `

; ----------------------------------------------------------------------------
JUMP_TO_CHECK_GLOVE_ACTION:
        jmp     CHECK_GLOVE_ACTION                           ; DE39 4C 9F DE                 L..

; ----------------------------------------------------------------------------
JUMP_TO_CHECK_CROSSBOW_ACTION:
        jmp     CHECK_CROSSBOW_ACTION                           ; DE3C 4C E8 DE                 L..

; ----------------------------------------------------------------------------
; try to break a block with the mattock
CHECK_MATTOCK_ACTION:
        ; branch (set carry, rts) if no magic
		lda     PLAYER_MAGIC                             ; DE3F A5 59                    .Y
        beq     LDE9D                           ; DE41 F0 5A                    .Z
        
		; branch (set carry, rts) if not perfectly aligned to a block
		lda     PY                             ; DE43 A5 45                    .E
        and     #$0F                            ; DE45 29 0F                    ).
        ora     PX_LO                             ; DE47 05 43                    .C
        bne     LDE9D                           ; DE49 D0 52                    .R
        
		; convert dpad input to an index for movement tables
		lda     JOYPAD_INPUT_REFERENCE                             ; DE4B A5 FD                    ..
        and     #$0F                            ; DE4D 29 0F                    ).
        asl     a                               ; DE4F 0A                       .
        tax                                     ; DE50 AA                       .
        
		; we set some values directly to slot 9 of the object arrays here (used for temp objects)
		; move object x hi
		clc                                     ; DE51 18                       .
        lda     PX_HI                             ; DE52 A5 44                    .D
        adc     TBL_DPAD_TO_MOVEABLE_BLOCK_DX,x                         ; DE54 7D AB FE                 }..
        sta     OBJ_X_HI+$90                           ; DE57 8D 9D 04                 ...        
		sta     PLAYER_MAP_TILE_LO                           ; DE5A 85 0C                    ..
        
		; move x lo
		lda     #$00                            ; DE5C A9 00                    ..
        sta     OBJ_X_LO+$90                           ; DE5E 8D 9C 04                 ...
        
		; move y
		clc                                     ; DE61 18                       .
		lda     PY                             ; DE62 A5 45                    .E
        adc     TBL_DPAD_TO_MOVEABLE_BLOCK_DY,x                         ; DE64 7D AC FE                 }..
        sta     OBJ_Y+$90                           ; DE67 8D 9E 04                 ...
        sta     PLAYER_MAP_TILE_HI                             ; DE6A 85 0D                    ..
        
		
		; branch (set carry, rts) if not a movable block
		jsr     UPDATE_MAP_TILE_PTRS                           ; DE6C 20 54 CA                  T.
        ldy     #$00                            ; DE6F A0 00                    ..
        sty     SCRATCH_0B                             ; DE71 84 0B                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; DE73 B1 0C                    ..
        and     #$3F                            ; DE75 29 3F                    )?
        cmp     #$3E                            ; DE77 C9 3E                    .>
		bne     LDE9D                           ; DE79 D0 22                    ."
        
		; movable block; place sprite, set flag so we only do one animation at a time, set counter
		lda     #$E1                            ; DE7B A9 E1                    ..
        sta     OBJ_SPRITE+$90                           ; DE7D 8D 90 04                 ...
        lda     #$01                            ; DE80 A9 01                    ..
        sta     BLOCK_ANIMATION_FLAG                           ; DE82 8D 91 04                 ...
        lda     #$01                            ; DE85 A9 01                    ..
        sta     OBJ_SPRITE_FLAGS+$90                           ; DE87 8D 92 04                 ...
        lda     #$0F                            ; DE8A A9 0F                    ..
        sta     OBJ_MISC_CTR+$90                           ; DE8C 8D 96 04                 ...
        
		; mattock
		; get replacement tile ID
		jsr     GET_MOVEABLE_BLOCK_REPLACEMENT                           ; DE8F 20 80 DF                  ..
        sta     OBJ_DY_DOWN+$90                           ; DE92 8D 93 04                 ...
        jsr     DECREMENT_PLAYER_MAGIC                           ; DE95 20 F0 E7                  ..
        lda     #SOUND_CROSSBOW                            ; DE98 A9 14                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DE9A 8D 8F 00                 ...
LDE9D:
        sec                                     ; DE9D 38                       8
        rts                                     ; DE9E 60                       `

; ----------------------------------------------------------------------------
; try to slide a block with the glove
CHECK_GLOVE_ACTION:
        ; branch (no block move) if no stored dpad data
		lda     JOYPAD_INPUT_REFERENCE                             ; DE9F A5 FD                    ..
        and     #$0F                            ; DEA1 29 0F                    ).
        beq     LDEE0                           ; DEA3 F0 3B                    .;
        
		; set movement, speed=1
		ldy     #$01                            ; DEA5 A0 01                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; DEA7 20 70 CD                  p.
        
		; find a sprite
		ldy     #$F8                            ; DEAA A0 F8                    ..
        lda     (TILE_DEFS_LO),y                         ; DEAC B1 79                    .y
        and     #$FE                            ; DEAE 29 FE                    ).
        sta     CUR_OBJ_SPRITE                             ; DEB0 85 ED                    ..
        
		; configure the temp object, note the original tile type we're replacing, set the move ctr
		lda     #OBJ_GEN_TYPE_ENEMY                            ; DEB2 A9 01                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; DEB4 85 EE                    ..
        lda     #$03                            ; DEB6 A9 03                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; DEB8 85 EF                    ..
        ldy     SCRATCH_0B                             ; DEBA A4 0B                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; DEBC B1 0C                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; DEBE 85 F0                    ..
        lda     #$10                            ; DEC0 A9 10                    ..
        sta     CUR_OBJ_MISC_CTR                             ; DEC2 85 F3                    ..
        
		; replace the existing tile
		jsr     GET_MOVEABLE_BLOCK_REPLACEMENT                           ; DEC4 20 80 DF                  ..
        sta     (PLAYER_MAP_TILE_PTR),y                       ; DEC7 91 0C                    ..
        jsr     SET_TEMP_OBJECT_NEXT_POS                           ; DEC9 20 37 DF                  7.
        jsr     UPDATE_GRAPHICS_FOR_TEMP_OBJECT                           ; DECC 20 5E DF                  ^.
        jsr     UPDATE_TEMP_OBJECT                           ; DECF 20 F7 F7                  ..
        lda     #$FF                            ; DED2 A9 FF                    ..
        sta     CUR_OBJ_SLOT_NUM                             ; DED4 85 E3                    ..
        
		; play sound if the animation flag not yet set
		lda     BLOCK_ANIMATION_FLAG                           ; DED6 AD 91 04                 ...
        beq     LDEE0                           ; DED9 F0 05                    ..
        lda     #SOUND_OPEN_DOOR                            ; DEDB A9 06                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DEDD 8D 8F 00                 ...
LDEE0:
        ; block action halts falls
        lda     #$00                            ; DEE0 A9 00                    ..
        sta     PLAYER_DY                             ; DEE2 85 4B                    .K
        sta     CTR_PLAYER_DESCENT                             ; DEE4 85 4E                    .N
        sec                                     ; DEE6 38                       8
        rts                                     ; DEE7 60                       `

; ----------------------------------------------------------------------------
; try to shoot a block with the crossbow
CHECK_CROSSBOW_ACTION:
        ; branch (skip) if no magic
		lda     PLAYER_MAGIC                             ; DEE8 A5 59                    .Y
        beq     LDE9D                           ; DEEA F0 B1                    ..
        
		; branch (skip) if no saved dpad input
		lda     JOYPAD_INPUT_REFERENCE                             ; DEEC A5 FD                    ..
        and     #$0F                            ; DEEE 29 0F                    ).
        beq     LDF2F                           ; DEF0 F0 3D                    .=
        
		; set movement, speed=98
		ldy     #$08                            ; DEF2 A0 08                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; DEF4 20 70 CD                  p.
        
		; find our sprite, configure the temp object, remember the tile we're replacing
		ldy     #$F8                            ; DEF7 A0 F8                    ..
        lda     (TILE_DEFS_LO),y                         ; DEF9 B1 79                    .y
        and     #$FE                            ; DEFB 29 FE                    ).
        sta     CUR_OBJ_SPRITE                             ; DEFD 85 ED                    ..
        lda     #OBJ_GEN_TYPE_ENEMY                            ; DEFF A9 01                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; DF01 85 EE                    ..
        lda     #$03                            ; DF03 A9 03                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; DF05 85 EF                    ..
        ldy     SCRATCH_0B                             ; DF07 A4 0B                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; DF09 B1 0C                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; DF0B 85 F0                    ..
        lda     #$00                            ; DF0D A9 00                    ..
        sta     CUR_OBJ_MISC_CTR                             ; DF0F 85 F3                    ..
        
		; replace existing tile
		jsr     GET_MOVEABLE_BLOCK_REPLACEMENT                           ; DF11 20 80 DF                  ..
        sta     (PLAYER_MAP_TILE_PTR),y                       ; DF14 91 0C                    ..
        jsr     SET_TEMP_OBJECT_NEXT_POS                           ; DF16 20 37 DF                  7.
        jsr     UPDATE_GRAPHICS_FOR_TEMP_OBJECT                           ; DF19 20 5E DF                  ^.
        jsr     UPDATE_TEMP_OBJECT                           ; DF1C 20 F7 F7                  ..
        lda     #$FF                            ; DF1F A9 FF                    ..
        sta     CUR_OBJ_SLOT_NUM                             ; DF21 85 E3                    ..
        
		; not sure why this would happen, but branch if cur object is blank?
		lda     CUR_OBJ_GEN_TYPE                             ; DF23 A5 EE                    ..
        beq     LDF2F                           ; DF25 F0 08                    ..
        
		; otherwise, play the sound and take the magic
		lda     #SOUND_CROSSBOW                            ; DF27 A9 14                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; DF29 8D 8F 00                 ...
        jsr     DECREMENT_PLAYER_MAGIC                           ; DF2C 20 F0 E7                  ..
LDF2F:
		; block action halts falls
        lda     #$00                            ; DF2F A9 00                    ..
        sta     PLAYER_DY                             ; DF31 85 4B                    .K
        sta     CTR_PLAYER_DESCENT                             ; DF33 85 4E                    .N
        sec                                     ; DF35 38                       8
        rts                                     ; DF36 60                       `

; ----------------------------------------------------------------------------
; input - SCRATCH_0B - offset to tile i.e. the y in (PLAYER_MAP_TILE_PTR),y
SET_TEMP_OBJECT_NEXT_POS:
        ; branch if SCRATCH_0B < x0c
		lda     SCRATCH_0B                             ; DF37 A5 0B                    ..
        cmp     #$0C                            ; DF39 C9 0C                    ..
        bcc     LDF41                           ; DF3B 90 04                    ..
        
		; else subtract and incr x hi
		sbc     #$0C                            ; DF3D E9 0C                    ..
        inc     TEMP_NEXT_X_HI                             ; DF3F E6 0F                    ..
LDF41:
		; branch if 0
        tay                                     ; DF41 A8                       .
        beq     LDF4B                           ; DF42 F0 07                    ..
        
		; otherwise, add x10 to temp_next_y
		lda     TEMP_NEXT_Y                             ; DF44 A5 0A                    ..
        clc                                     ; DF46 18                       .
        adc     #$10                            ; DF47 69 10                    i.
        sta     TEMP_NEXT_Y                             ; DF49 85 0A                    ..
LDF4B:
        ; store TEMP_NEXT_Y upper nibble to CUR_OBJ_NEXT_Y
		lda     TEMP_NEXT_Y                             ; DF4B A5 0A                    ..
        and     #$F0                            ; DF4D 29 F0                    ).
        sta     CUR_OBJ_NEXT_Y                             ; DF4F 85 FB                    ..
       
		; copy temp x hi to current; clear cur obj x and y_copy
	    lda     #$00                            ; DF51 A9 00                    ..
        sta     CUR_OBJ_PROJECTILE_WIGGLE                             ; DF53 85 FC                    ..
        lda     TEMP_NEXT_X_HI                             ; DF55 A5 0F                    ..
        sta     CUR_OBJ_NEXT_X_HI                             ; DF57 85 FA                    ..
        lda     #$00                            ; DF59 A9 00                    ..
        sta     CUR_OBJ_NEXT_X                             ; DF5B 85 F9                    ..
        rts                                     ; DF5D 60                       `

; ----------------------------------------------------------------------------
; erases a moveable block or key door or replaceable tile from the nametable
; by updating that location from the tile ram
UPDATE_GRAPHICS_FOR_TEMP_OBJECT:
		; calc PPU address for tile we're updating
        lda     CUR_OBJ_NEXT_X_HI                             ; DF5E A5 FA                    ..
        sta     PLAYER_MAP_TILE_LO                           ; DF60 85 0C                    ..
        asl     a                               ; DF62 0A                       .
        and     #$1F                            ; DF63 29 1F                    ).
        sta     PPU_WRITE_LO                             ; DF65 85 16                    ..
        lda     CUR_OBJ_NEXT_X_HI                             ; DF67 A5 FA                    ..
        and     #$10                            ; DF69 29 10                    ).
        lsr     a                               ; DF6B 4A                       J
        lsr     a                               ; DF6C 4A                       J
        sta     PPU_WRITE_HI                             ; DF6D 85 17                    ..
        
		; add offset above to base address $2000
		clc                                     ; DF6F 18                       .
        lda     #$00                            ; DF70 A9 00                    ..
        adc     PPU_WRITE_LO                             ; DF72 65 16                    e.
        sta     PPU_WRITE_LO                             ; DF74 85 16                    ..
        lda     #$20                            ; DF76 A9 20                    . 
        adc     PPU_WRITE_HI                             ; DF78 65 17                    e.
        sta     PPU_WRITE_HI                             ; DF7A 85 17                    ..
        jsr     UPDATE_MAP_DATA_FROM_SCROLL                           ; DF7C 20 33 C8                  3.
        rts                                     ; DF7F 60                       `

; ----------------------------------------------------------------------------
; look up a substitute tile
GET_MOVEABLE_BLOCK_REPLACEMENT:
		; load info on a tile, lower 6 bits
        ldy     SCRATCH_0B                             ; DF80 A4 0B                    ..
        lda     (ROM_MAP_TILE_LO),y                         ; DF82 B1 10                    ..
        and     #$3F                            ; DF84 29 3F                    )?
        tax                                     ; DF86 AA                       .
        
		; map info specifies replacement block
		lda     MOVEABLE_BLOCK_REPLACEMENT_TILE_ID                             ; DF87 A5 74                    .t
        
		; think this is just to double-check as I don't think we'd ever get 
		; called for a different block type, but we make sure the existing block 
		; at (ROM_MAP_TILE_LO),y is a moveable block. If it is, we RTS with a=MOVEABLE_BLOCK_REPLACEMENT_TILE_ID.
		; if not, we return the current value of (ROM_MAP_TILE_LO),y
		cpx     #$3E                            ; DF89 E0 3E                    .>
        beq     LDF8F                           ; DF8B F0 02                    ..
        lda     (ROM_MAP_TILE_LO),y                         ; DF8D B1 10                    ..
LDF8F:
        rts                                     ; DF8F 60                       `

; ----------------------------------------------------------------------------
; output: carry
; checks something related to block boundary proximity x/y; will set
; carry if aligned or near center of a block
CHECK_PLAYER_BLOCK_ALIGNMENT:
        ; save processor flags based on dx then clear dx/helper
		lda     PLAYER_DX                             ; DF90 A5 49                    .I
        php                                     ; DF92 08                       .
        lda     #$00                            ; DF93 A9 00                    ..
        sta     PLAYER_DX                             ; DF95 85 49                    .I
        sta     PLAYER_HORIZ_DIR                             ; DF97 85 4A                    .J
        plp                                     ; DF99 28                       (
        
		; branch if dx was already 0 above
		beq     LDFCF                           ; DF9A F0 33                    .3
        
		; dx was non-zero; branch if on a 16-pixel y boundary;  (carry set/rts)
		lda     PY                             ; DF9C A5 45                    .E
        and     #$0F                            ; DF9E 29 0F                    ).
		beq     LE00D                           ; DFA0 F0 6B                    .k
        
		; not on a 16-pixel y boundary; branch if PY lower nibble < x06
		cmp     #$06                            ; DFA2 C9 06                    ..
        bcc     LDFBE                           ; DFA4 90 18                    ..
        
		; branch if y fracction <6 or >= B
		cmp     #$0B                            ; DFA6 C9 0B                    ..
		bcs     LDFAD                           ; DFA8 B0 03                    ..
        
		; y fraction >=6 and <B (carry set/rts)
		jmp     LE00D                           ; DFAA 4C 0D E0                 L..

; ----------------------------------------------------------------------------
LDFAD:
		; branch if up pressed (carry set/rts)
        lda     JOYPAD_INPUT                             ; DFAD A5 20                    . 
        and     #BTN_UP                            ; DFAF 29 08                    ).
		bne     LE00D                           ; DFB1 D0 5A                    .Z
        
		; up not pressed - going down
		lda     #$01                            ; DFB3 A9 01                    ..
        sta     PLAYER_DY                             ; DFB5 85 4B                    .K
        lda     #$00                            ; DFB7 A9 00                    ..
        sta     PLAYER_VERT_DIR                             ; DFB9 85 4C                    .L
        jmp     LE009                           ; DFBB 4C 09 E0                 L..

; ----------------------------------------------------------------------------
LDFBE:
		; branch if down pressed (carry set/rts)
        lda     JOYPAD_INPUT                             ; DFBE A5 20                    . 
        and     #BTN_DOWN                            ; DFC0 29 04                    ).
		bne     LE00D                           ; DFC2 D0 49                    .I
        
		; down not pressed - dy heading up
		lda     #$FF                            ; DFC4 A9 FF                    ..
        sta     PLAYER_DY                             ; DFC6 85 4B                    .K
        lda     #$FF                            ; DFC8 A9 FF                    ..
        sta     PLAYER_VERT_DIR                             ; DFCA 85 4C                    .L
        jmp     LE009                           ; DFCC 4C 09 E0                 L..

; ----------------------------------------------------------------------------
; player has hit ceiling?
; code below then checks if we need to scoot them right or left to align to block boundary
; only happens if they are near the edge
LDFCF:
		; save flags for DY, then clear it
        lda     PLAYER_DY                             ; DFCF A5 4B                    .K
        php                                     ; DFD1 08                       .
        lda     #$00                            ; DFD2 A9 00                    ..
        sta     PLAYER_DY                             ; DFD4 85 4B                    .K
        sta     PLAYER_VERT_DIR                             ; DFD6 85 4C                    .L
        plp                                     ; DFD8 28                       (
        
		; branch (rts/carry set) if dy was already 0 above
		beq     LE00D                           ; DFD9 F0 32                    .2
        
		; branch (rts/carry set) if on a 16-pixel x boundary
		lda     PX_LO                             ; DFDB A5 43                    .C
		beq     LE00D                           ; DFDD F0 2E                    ..
        
		; branch if x frac < 6
		cmp     #$06                            ; DFDF C9 06                    ..
		bcc     LDFFB                           ; DFE1 90 18                    ..
        
		; branch if x frac >= B
		cmp     #$0B                            ; DFE3 C9 0B                    ..
		bcs     LDFEA                           ; DFE5 B0 03                    ..
        
		; else set carry, rts
		jmp     LE00D                           ; DFE7 4C 0D E0                 L..

; ----------------------------------------------------------------------------
; x is right edge of 16-pixel boundary
LDFEA:
        lda     JOYPAD_INPUT                             ; DFEA A5 20                    . 
        and     #BTN_LEFT                            ; DFEC 29 02                    ).
        
		; branch (rts) if L pressed
		bne     LE00D                           ; DFEE D0 1D                    ..
        
		; L not pressed; gently correct right
		lda     #$01                            ; DFF0 A9 01                    ..
        sta     PLAYER_DX                             ; DFF2 85 49                    .I
        lda     #$00                            ; DFF4 A9 00                    ..
        sta     PLAYER_HORIZ_DIR                             ; DFF6 85 4A                    .J
        jmp     LE009                           ; DFF8 4C 09 E0                 L..

; ----------------------------------------------------------------------------
; x is left edge of 16-pixel boundary
LDFFB:
        lda     JOYPAD_INPUT                             ; DFFB A5 20                    . 
        and     #BTN_RIGHT                            ; DFFD 29 01                    ).
        
		; branch (rts) if R pressed
		bne     LE00D                           ; DFFF D0 0C                    ..
        
		; R not pressed - gently correct left (note: PLAYER_DX if a 4-bit signed value, so x0F = -1, x0E = -2, etc)
		lda     #$0F                            ; E001 A9 0F                    ..
        sta     PLAYER_DX                             ; E003 85 49                    .I
        lda     #$FF                            ; E005 A9 FF                    ..
        sta     PLAYER_HORIZ_DIR                             ; E007 85 4A                    .J
LE009:
        jsr     CHECK_PLAYER_HALT_OR_SCROLL                           ; E009 20 91 D9                  ..
        rts                                     ; E00C 60                       `

; ----------------------------------------------------------------------------
LE00D:
        sec                                     ; E00D 38                       8
        rts                                     ; E00E 60                       `

; ----------------------------------------------------------------------------
; player pressed start during gameplay; we can see our items but can't move around and select them
GAMEPLAY_SHOW_ITEM_SCREEN:
        lda     #SOUND_OPEN_START_MENU                           ; E00F A9 03                    ..
        sta     NEXT_SOUND_EFFECT                             ; E011 85 8F                    ..
        inc     FLAG_START_SCREEN_OPEN                             ; E013 E6 8D                    ..
        
		; branch if on boss screen
		lda     CHR_BANK_ENEMY_SPRITES                             ; E015 A5 2D                    .-
        cmp     #SPRITE_PT_TARATUNES                            ; E017 C9 30                    .0
        bcs     LE039                           ; E019 B0 1E                    ..
        
		; not boss screen
		jsr     SAVE_POS_INFO_TO_STACK                           ; E01B 20 20 E6                   .
        lda     #$08                            ; E01E A9 08                    ..
        jsr     FADE_OUT_AND_PREP_SINGLE_SCREEN                           ; E020 20 60 E6                  `.
        jsr     ITEM_SCREEN_DRAW_EQUIPPED_ITEMS                           ; E023 20 B7 E6                  ..
        jsr     DRAW_ALL_INV_ITEM_QTY                           ; E026 20 30 CF                  0.
        jsr     DRAW_START_SCR_PLAYER_STATS                           ; E029 20 82 CF                  ..
        lda     #$08                            ; E02C A9 08                    ..
        sta     SCROLL_X_LO                             ; E02E 85 7B                    .{
        jsr     UPDATE_PPU_SCROLL_X                           ; E030 20 C7 C1                  ..
        jsr     DRAW_PLAYER                           ; E033 20 D8 C1                  ..
        jsr     PALETTE_FADE_IN                           ; E036 20 92 C4                  ..
LE039:
		; wait for there to be no input
        jsr     READ_JOYPADS                           ; E039 20 43 CC                  C.
        bne     LE039                           ; E03C D0 FB                    ..
LE03E:
		; loop if start not pressed
        jsr     READ_JOYPADS                           ; E03E 20 43 CC                  C.
        and     #BTN_START                            ; E041 29 10                    ).
        beq     LE03E                           ; E043 F0 F9                    ..
LE045:
		; start pressed; loop until it's released
        jsr     READ_JOYPADS                           ; E045 20 43 CC                  C.
        bne     LE045                           ; E048 D0 FB                    ..
        
		; proceeding from the start screen!
		; play sound
		lda     #SOUND_CLOSE_START_MENU                            ; E04A A9 04                    ..
        sta     NEXT_SOUND_EFFECT                             ; E04C 85 8F                    ..
        
		; branch if on a boss screen
		lda     CHR_BANK_ENEMY_SPRITES                             ; E04E A5 2D                    .-
        cmp     #SPRITE_PT_TARATUNES                            ; E050 C9 30                    .0
        bcs     LE074                           ; E052 B0 20                    . 
        
		; fade out, load graphics/music, draw, fade in
		jsr     LOAD_POS_INFO_FROM_STACK                           ; E054 20 42 E6                  B.
        jsr     PALETTE_FADE_OUT                           ; E057 20 E5 C3                  ..
        jsr     HIDE_SHOP_SPRITES                           ; E05A 20 9D E7                  ..
        lda     LAST_MUSIC_ID                             ; E05D A5 FE                    ..
        jsr     LOAD_MUSIC_DATA_IF_NEC                           ; E05F 20 2E D0                  ..
        jsr     LOAD_MAP_NO_TILES                           ; E062 20 FF C8                  ..
        jsr     LOAD_GRAPHICS_FOR_MAP_LEVEL                           ; E065 20 CB C5                  ..
        jsr     DRAW_PLAYER                           ; E068 20 D8 C1                  ..
        jsr     DRAW_OBJECTS                           ; E06B 20 B1 C2                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; E06E 20 C7 C1                  ..
        jsr     PALETTE_FADE_IN                           ; E071 20 92 C4                  ..
LE074:
        dec     FLAG_START_SCREEN_OPEN                             ; E074 C6 8D                    ..
        rts                                     ; E076 60                       `

; ----------------------------------------------------------------------------
; inn and home use a common entrance; MAP_Y is used to discern which we're going to
ENTER_INN_HOME:
		; branch (inn) if we're not on the overworld; else enter home
        lda     MAP_Y                             ; E077 A5 48                    .H
        cmp     #MAP_Y_OVERWORLD                            ; E079 C9 10                    ..
        bne     PLAYER_ENTER_INN                           ; E07B D0 03                    ..
        jmp     PLAYER_RETURN_HOME                           ; E07D 4C F4 E0                 L..

; ----------------------------------------------------------------------------
PLAYER_ENTER_INN:
        jsr     SAVE_POS_INFO_TO_STACK                           ; E080 20 20 E6                   .
        lda     #$04                            ; E083 A9 04                    ..
        jsr     FADE_OUT_AND_PREP_SINGLE_SCREEN                           ; E085 20 60 E6                  `.
        jsr     DRAW_SHOP_INN_KEEPER                           ; E088 20 78 E7                  x.
        jsr     PALETTE_FADE_IN                           ; E08B 20 92 C4                  ..
INN_MAIN:
        jsr     RUN_AROUND_INN_SHOP                           ; E08E 20 14 E5                  ..
        bcc     CHECK_INN_GOLDS                           ; E091 90 03                    ..
        jmp     EXIT_TO_MAP_LEVEL                           ; E093 4C FD E5                 L..

; ----------------------------------------------------------------------------
; stay at the inn, if we have enough golds; else play sound and loop
CHECK_INN_GOLDS:
        lda     PLAYER_GOLDS                             ; E096 A5 5A                    .Z
        cmp     #$0A                            ; E098 C9 0A                    ..
        
		; branch if >= golds
		bcs     INN_STAY                           ; E09A B0 07                    ..
        
		; not enough money for inn!
		lda     #SOUND_OPEN_DOOR                            ; E09C A9 06                    ..
        sta     NEXT_SOUND_EFFECT                             ; E09E 85 8F                    ..
        
		; loop
		jmp     INN_MAIN                           ; E0A0 4C 8E E0                 L..

; ----------------------------------------------------------------------------
; take 10 gold from player, heal life/magic, go to item selection screen, return to inn
INN_STAY:
        ; loop and take 10 golds
		ldx     #$0A                            ; E0A3 A2 0A                    ..
LE0A5:
        txa                                     ; E0A5 8A                       .
        pha                                     ; E0A6 48                       H
        dec     PLAYER_GOLDS                             ; E0A7 C6 5A                    .Z
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; E0A9 20 F8 CA                  ..
        lda     #SOUND_EQUIP_SELECT_TICK                            ; E0AC A9 0C                    ..
        sta     NEXT_SOUND_EFFECT                             ; E0AE 85 8F                    ..
        lda     #$0A                            ; E0B0 A9 0A                    ..
        sta     NMI_WAIT_CTR                             ; E0B2 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; E0B4 20 35 C1                  5.
        pla                                     ; E0B7 68                       h
        tax                                     ; E0B8 AA                       .
        dex                                     ; E0B9 CA                       .
        bne     LE0A5                           ; E0BA D0 E9                    ..
        
		; fade screen and heal
		jsr     PALETTE_FADE_OUT_KEEP_STATUS_BAR                           ; E0BC 20 30 C4                  0.
        jsr     ACTION_ELIXIR                           ; E0BF 20 6A D1                  j.
        jsr     ACTION_MAGIC_BOTTLE                           ; E0C2 20 99 D1                  ..
        
		; head to item screen
		lda     #$08                            ; E0C5 A9 08                    ..
        jsr     FADE_OUT_AND_PREP_SINGLE_SCREEN_KEEP_STATUS_BAR                           ; E0C7 20 67 E6                  g.
        jsr     ITEM_SCREEN_DRAW_EQUIPPED_ITEMS                           ; E0CA 20 B7 E6                  ..
        jsr     DRAW_ALL_INV_ITEM_QTY                           ; E0CD 20 30 CF                  0.
        jsr     DRAW_START_SCR_PLAYER_STATS                           ; E0D0 20 82 CF                  ..
        lda     #$08                            ; E0D3 A9 08                    ..
        sta     SCROLL_X_LO                             ; E0D5 85 7B                    .{
        jsr     UPDATE_PPU_SCROLL_X                           ; E0D7 20 C7 C1                  ..
        jsr     DRAW_PLAYER                           ; E0DA 20 D8 C1                  ..
        jsr     PALETTE_FADE_IN                           ; E0DD 20 92 C4                  ..
        
		; select items and exit
		jsr     ITEM_SELECTION_SCREEN_MAIN                           ; E0E0 20 AA E4                  ..
        
		; back to inn
		lda     #$04                            ; E0E3 A9 04                    ..
        jsr     FADE_OUT_AND_PREP_SINGLE_SCREEN_KEEP_STATUS_BAR                           ; E0E5 20 67 E6                  g.
        jsr     HIDE_SHOP_SPRITES                           ; E0E8 20 9D E7                  ..
        jsr     DRAW_SHOP_INN_KEEPER                           ; E0EB 20 78 E7                  x.
        jsr     PALETTE_FADE_IN                           ; E0EE 20 92 C4                  ..
        
		; loop
		jmp     INN_MAIN                           ; E0F1 4C 8E E0                 L..

; ----------------------------------------------------------------------------
; enter the home from the overworld
PLAYER_RETURN_HOME:
        ; emtpy magic/life
		lda     #$00                            ; E0F4 A9 00                    ..
        sta     PLAYER_LIFE                             ; E0F6 85 58                    .X
        sta     PLAYER_MAGIC                             ; E0F8 85 59                    .Y
        
		; branch if PLAYER_ID >= 6
		lda     PLAYER_ID                             ; E0FA A5 40                    .@
        cmp     #PLAYER_NONE                            ; E0FC C9 06                    ..
        bcs     LE112                           ; E0FE B0 12                    ..
        
		; return any equipped items to inventory
		ldy     #$02                            ; E100 A0 02                    ..
LE102:
        ldx     CUR_EQUIP_ITEMS,y                           ; E102 B6 51                    .Q
        bmi     LE108                           ; E104 30 02                    0.
        inc     PLAYER_INVENTORY,x                           ; E106 F6 60                    .`
LE108:
        ldx     #INV_ITEM_NOTHING                            ; E108 A2 FF                    ..
        stx     CUR_EQUIP_ITEMS,y                           ; E10A 96 51                    .Q
        
		; loop until all slots empty
		dey                                     ; E10C 88                       .
        bpl     LE102                           ; E10D 10 F3                    ..
        
		; all items are back, this is our save state
		jsr     SAVE_PLAYER_HOME_STATE                           ; E10F 20 A5 D0                  ..
LE112:
		; save overworld position so we can exit at the same spot
        jsr     SAVE_POS_INFO_TO_STACK                           ; E112 20 20 E6                   .
        
		; clear player
		lda     #PLAYER_NONE                            ; E115 A9 06                    ..
        sta     PLAYER_ID                             ; E117 85 40                    .@
        
		; fade to black and update status bar life/magic
		lda     #$06                            ; E119 A9 06                    ..
        jsr     FADE_OUT_AND_PREP_SINGLE_SCREEN                           ; E11B 20 60 E6                  `.
        jsr     EVENT_PLAYER_LIFE_CHANGE                           ; E11E 20 B6 CA                  ..
        jsr     EVENT_PLAYER_MAGIC_CHANGE                           ; E121 20 CC CA                  ..
        
		; clear any equipment selection
		lda     #EQUIP_SLOT_NOTHING_SELECTED                            ; E124 A9 03                    ..
        sta     CUR_EQUIP_SLOT_SELECTED                             ; E126 85 55                    .U
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; E128 20 34 C2                  4.
        
		; ready the hand as 'player'
		lda     #$F1                            ; E12B A9 F1                    ..
        sta     PLAYER_FRAME                             ; E12D 85 56                    .V
        lda     #$00                            ; E12F A9 00                    ..
        sta     PLAYER_SPRITE_FLAGS                             ; E131 85 57                    .W
        
		; note in the pre-selection home the 'player' is the hand that floats around
		jsr     DRAW_PLAYER                           ; E133 20 D8 C1                  ..
        jsr     HOME_DRAW_FAMILY                           ; E136 20 B2 E7                  ..
        jsr     CLEAR_ALL_OBJECTS                           ; E139 20 8A D0                  ..
        jsr     PALETTE_FADE_IN                           ; E13C 20 92 C4                  ..

HOME_MAIN:
		; home is now visible and the hand is showing!
		; player moves hand around in home to select something
        jsr     HOME_WAIT_FOR_BTN_A_PRESSED                           ; E13F 20 B4 E5                  ..
        
		; a was pressed - see if we do anything useful; if not back to HOME_MAIN and wait for another press
		; branch (check for player select) if y not in painting row
		lda     TEMP_NEXT_Y                             ; E142 A5 0A                    ..
        and     #$F0                            ; E144 29 F0                    ).
        cmp     #$50                            ; E146 C9 50                    .P
		bne     HOME_CHECK_SELECT_CHARACTER                           ; E148 D0 3C                    .<
        
		; we are in the row of the painting
		; branch (main loop) if x hi not on painting
		lda     TEMP_NEXT_X_HI                             ; E14A A5 0F                    ..
        and     #$0F                            ; E14C 29 0F                    ).
        cmp     #$05                            ; E14E C9 05                    ..
		bne     HOME_MAIN                           ; E150 D0 ED                    ..
        
		; loop if CHEAT_STATUS = 0
		; step through each musical number, 0-x0f
		lda     CHEAT_STATUS                             ; E152 A5 37                    .7
		beq     HOME_MAIN                           ; E154 F0 E9                    ..
        
		; cheat mode enabled - cycle through music
		ldx     MUSIC_ID                             ; E156 A6 8E                    ..
        inx                                     ; E158 E8                       .
        cpx     #$10                            ; E159 E0 10                    ..
        bcc     LE15F                           ; E15B 90 02                    ..
        ldx     #$00                            ; E15D A2 00                    ..
LE15F:
        stx     MUSIC_ID                             ; E15F 86 8E                    ..
        jsr     LOAD_MUSIC_DATA                           ; E161 20 08 FC                  ..
        
		; loop if CHEAT_STATUS positive
		lda     CHEAT_STATUS                             ; E164 A5 37                    .7
		bpl     HOME_MAIN                           ; E166 10 D7                    ..
        lda     JOYPAD_INPUT                             ; E168 A5 20                    . 
        cmp     #$C3                            ; E16A C9 C3                    ..
        
		; branch if joypad <> A+B+L+R
		bne     HOME_MAIN                           ; E16C D0 D1                    ..
        
		; loop to write 0x10 to each slot - 16 of each item besides crown/dragon slayer
		ldx     #INV_ITEM_CRYSTAL                            ; E16E A2 0D                    ..
        lda     #$10                            ; E170 A9 10                    ..
LE172:
        sta     PLAYER_INVENTORY,x                           ; E172 95 60                    .`
        dex                                     ; E174 CA                       .
        bpl     LE172                           ; E175 10 FB                    ..
        
		; plenty of cash and keys...
		lda     #$80                            ; E177 A9 80                    ..
        sta     CHEAT_STATUS                             ; E179 85 37                    .7
        sta     PLAYER_GOLDS                             ; E17B 85 5A                    .Z
        sta     PLAYER_KEYS                             ; E17D 85 5B                    .[
        lda     #SOUND_CHEAT_MODE                            ; E17F A9 1A                    ..
        sta     NEXT_SOUND_EFFECT                             ; E181 85 8F                    ..
        jmp     HOME_MAIN                           ; E183 4C 3F E1                 L?.

; ----------------------------------------------------------------------------
; we've pressed a in the home - check if we are on one of the characters!
; x tracks the tentative PLAYER_ID based on which character is being checked;
; if a match is found it is stored to PLAYER_ID and we load that character
; input: a=upper nibble of PY
HOME_CHECK_SELECT_CHARACTER:
		; branch if PY is in the uppermost home row (Xemn, Meyna)
        ldx     #$00                            ; E186 A2 00                    ..
		cmp     #$70                            ; E188 C9 70                    .p
        beq     HOME_CHECK_TOP_ROW                           ; E18A F0 1C                    ..
        
		; branch if PY is in the middle row (Roas, Grandma, Grandpa)
		ldx     #$02                            ; E18C A2 02                    ..
        cmp     #$80                            ; E18E C9 80                    ..
        beq     HOME_CHECK_MIDDLE_ROW                           ; E190 F0 26                    .&
        
		; branch (main loop) if not in the final row (Lyll, Pochi)
		cmp     #$90                            ; E192 C9 90                    ..
        bne     HOME_MAIN                           ; E194 D0 A9                    ..
        
		; in the bottom row...
		; branch if on Lyll (x=3)
		ldx     #$03                            ; E196 A2 03                    ..
        lda     TEMP_NEXT_X_HI                             ; E198 A5 0F                    ..
        and     #$0F                            ; E19A 29 0F                    ).
        cmp     #$06                            ; E19C C9 06                    ..
        beq     LOAD_SELECTED_PLAYER                           ; E19E F0 3C                    .<
        
		; branch if on pochi (x=4)
		inx                                     ; E1A0 E8                       .
        cmp     #$0A                            ; E1A1 C9 0A                    ..
        beq     LOAD_SELECTED_PLAYER                           ; E1A3 F0 37                    .7
        jmp     HOME_MAIN                           ; E1A5 4C 3F E1                 L?.

; ----------------------------------------------------------------------------
HOME_CHECK_TOP_ROW:
        
		; branch if on xemn (x=0)
		lda     TEMP_NEXT_X_HI                             ; E1A8 A5 0F                    ..
        and     #$0F                            ; E1AA 29 0F                    ).
        cmp     #$06                            ; E1AC C9 06                    ..
        beq     LOAD_SELECTED_PLAYER                           ; E1AE F0 2C                    .,
        
		; branch if on meyna (x=1), else back to main loop
		inx                                     ; E1B0 E8                       .
        cmp     #$08                            ; E1B1 C9 08                    ..
        beq     LOAD_SELECTED_PLAYER                           ; E1B3 F0 27                    .'
        jmp     HOME_MAIN                           ; E1B5 4C 3F E1                 L?.

; ----------------------------------------------------------------------------
HOME_CHECK_MIDDLE_ROW:
		; branch (select Roas) if we're on Roas
        lda     TEMP_NEXT_X_HI                             ; E1B8 A5 0F                    ..
        and     #$0F                            ; E1BA 29 0F                    ).
        cmp     #$04                            ; E1BC C9 04                    ..
        beq     LOAD_SELECTED_PLAYER                           ; E1BE F0 1C                    ..
        
		; branch if not on grandma
		cmp     #$0A                            ; E1C0 C9 0A                    ..
        bne     LE1CE                           ; E1C2 D0 0A                    ..
        
		; lower nibble x hi=x0A; we are on grandma and show the password!
		lda     #SOUND_OPEN_START_MENU                            ; E1C4 A9 03                    ..
        sta     NEXT_SOUND_EFFECT                             ; E1C6 85 8F                    ..
        jsr     GRANDMA_SHOW_PASSWORD                           ; E1C8 20 7D E2                  }.
        jmp     HOME_MAIN                           ; E1CB 4C 3F E1                 L?.

; ----------------------------------------------------------------------------
LE1CE:
        ; branch (back to main loop) if not on grandpa
		cmp     #$0C                            ; E1CE C9 0C                    ..
        bne     LE1D9                           ; E1D0 D0 07                    ..
        
		; we are on grandpa; show the password entry form
		lda     #SOUND_OPEN_START_MENU                            ; E1D2 A9 03                    ..
        sta     NEXT_SOUND_EFFECT                             ; E1D4 85 8F                    ..
        jsr     GRANDPA_ENTER_PASSWORD                           ; E1D6 20 AA E2                  ..
LE1D9:
        jmp     HOME_MAIN                           ; E1D9 4C 3F E1                 L?.

; ----------------------------------------------------------------------------
; input - x = id of selected player
; loads player's stats, does the flash effect and draws the player, 
; sets up life, etc., goes to item screen then off to the overworld
LOAD_SELECTED_PLAYER:
        ; PLAYER_ID*4 is used as an index to stats table
		stx     PLAYER_ID                             ; E1DC 86 40                    .@
        txa                                     ; E1DE 8A                       .
        asl     a                               ; E1DF 0A                       .
        asl     a                               ; E1E0 0A                       .
        clc                                     ; E1E1 18                       .
        adc     #$03                            ; E1E2 69 03                    i.
        tay                                     ; E1E4 A8                       .
        ldx     #$03                            ; E1E5 A2 03                    ..
LOAD_PLAYER_STATS_LOOP:
        lda     TBL_PLAYER_STATS,y                         ; E1E7 B9 A7 FF                 ...
        sta     PLAYER_JUMP_FRAMES,x                           ; E1EA 95 5C                    .\
        dey                                     ; E1EC 88                       .
        dex                                     ; E1ED CA                       .
        bpl     LOAD_PLAYER_STATS_LOOP                           ; E1EE 10 F7                    ..
        
		; cross sound effect/flash
		; note we do 5 flashes, update the visuals for the selected player, then do
		; another 5 flashes - kind of cool
		lda     #SOUND_CROSS                            ; E1F0 A9 18                    ..
        sta     NEXT_SOUND_EFFECT                             ; E1F2 85 8F                    ..
        lda     #$FF                            ; E1F4 A9 FF                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; E1F6 85 90                    ..
        lda     #$04                            ; E1F8 A9 04                    ..
        sta     NMI_WAIT_CTR                             ; E1FA 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; E1FC 20 35 C1                  5.
        ldx     #$05                            ; E1FF A2 05                    ..
        jsr     FLASH_EFFECT_C540                           ; E201 20 40 C5                  @.
        
		; CHR_BANK_PLAYER_SPRITES is pattern table for specific player
		lda     PLAYER_ID                             ; E204 A5 40                    .@
        clc                                     ; E206 18                       .
        adc     #$38                            ; E207 69 38                    i8
        sta     CHR_BANK_PLAYER_SPRITES                             ; E209 85 2C                    .,
        lda     #$3D                            ; E20B A9 3D                    .=
        sta     CHR_BANK_ENEMY_SPRITES                             ; E20D 85 2D                    .-
        lda     #$3E                            ; E20F A9 3E                    .>
        sta     CHR_BANK_SPRITES_02                             ; E211 85 2E                    ..
        lda     #$3F                            ; E213 A9 3F                    .?
        sta     CHR_BANK_SPRITES_03                             ; E215 85 2F                    ./
       
        ; set player frame/position
	    lda     #$0D                            ; E217 A9 0D                    ..
        sta     PLAYER_FRAME                             ; E219 85 56                    .V
        lda     #$00                            ; E21B A9 00                    ..
        sta     PLAYER_SPRITE_FLAGS                             ; E21D 85 57                    .W
        lda     PY                             ; E21F A5 45                    .E
        and     #$F0                            ; E221 29 F0                    ).
        sta     PY                             ; E223 85 45                    .E
        lda     #$04                            ; E225 A9 04                    ..
        sta     PX_LO                             ; E227 85 43                    .C
        
		; hide the rest of the family and draw the active player
		jsr     HIDE_SPRITES_280_UP                           ; E229 20 7C D0                  |.
        jsr     DRAW_PLAYER                           ; E22C 20 D8 C1                  ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; E22F 20 35 C1                  5.
        
		; 5 more flashes with the active player shown
		ldx     #$05                            ; E232 A2 05                    ..
        jsr     FLASH_EFFECT_C540                           ; E234 20 40 C5                  @.
        
		; wait 2 seconds and fade out
		lda     #$78                            ; E237 A9 78                    .x
        sta     NMI_WAIT_CTR                             ; E239 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; E23B 20 35 C1                  5.
        jsr     PALETTE_FADE_OUT                           ; E23E 20 E5 C3                  ..
        
		; prepare frame for item screen
		lda     #$08                            ; E241 A9 08                    ..
        sta     PLAYER_FRAME                             ; E243 85 56                    .V
        lda     #$00                            ; E245 A9 00                    ..
        sta     PLAYER_SPRITE_FLAGS                             ; E247 85 57                    .W
        
		; 99 life, magic; keys and golds stay as they were
		lda     #$63                            ; E249 A9 63                    .c
        sta     PLAYER_LIFE                             ; E24B 85 58                    .X
        sta     PLAYER_MAGIC                             ; E24D 85 59                    .Y
        jsr     EVENT_PLAYER_LIFE_CHANGE                           ; E24F 20 B6 CA                  ..
        jsr     EVENT_PLAYER_MAGIC_CHANGE                           ; E252 20 CC CA                  ..
        
		; select right equipment slot
		lda     #$02                            ; E255 A9 02                    ..
        sta     CUR_EQUIP_SLOT_SELECTED                             ; E257 85 55                    .U
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; E259 20 34 C2                  4.
        
		; prep the item screen
		lda     #$08                            ; E25C A9 08                    ..
        jsr     FADE_OUT_AND_PREP_SINGLE_SCREEN                           ; E25E 20 60 E6                  `.
        jsr     ITEM_SCREEN_DRAW_EQUIPPED_ITEMS                           ; E261 20 B7 E6                  ..
        jsr     DRAW_ALL_INV_ITEM_QTY                           ; E264 20 30 CF                  0.
        jsr     DRAW_START_SCR_PLAYER_STATS                           ; E267 20 82 CF                  ..
        
		lda     #$08                            ; E26A A9 08                    ..
        sta     SCROLL_X_LO                             ; E26C 85 7B                    .{
        jsr     UPDATE_PPU_SCROLL_X                           ; E26E 20 C7 C1                  ..
        jsr     DRAW_PLAYER                           ; E271 20 D8 C1                  ..
        jsr     PALETTE_FADE_IN                           ; E274 20 92 C4                  ..
        jsr     ITEM_SELECTION_SCREEN_MAIN                           ; E277 20 AA E4                  ..
        jmp     EXIT_TO_MAP_LEVEL                           ; E27A 4C FD E5                 L..

; ----------------------------------------------------------------------------
; display password for current game state
GRANDMA_SHOW_PASSWORD:
        lda     #$10                            ; E27D A9 10                    ..
        sta     SCROLL_X_HI                             ; E27F 85 7C                    .|
        jsr     PREP_PASSWORD_SCREEN                           ; E281 20 B5 C7                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; E284 20 C7 C1                  ..
        
		; jump to $b4d4 / GENERATE_PASSWORD
		lda     #$D4                            ; E287 A9 D4                    ..
        sta     JMP_DEST_0E_LO                           ; E289 85 0E                    ..
        lda     #$B4                            ; E28B A9 B4                    ..
        sta     JMP_DEST_0F_HI                             ; E28D 85 0F                    ..
        jsr     USE_PRG_CD                           ; E28F 20 9C CC                  ..
        
		; show the password
		jsr     DRAW_PASSWORD_SCREEN                           ; E292 20 E5 D0                  ..
LE295:
        ; loop while there is joypad input
		jsr     READ_JOYPADS                           ; E295 20 43 CC                  C.
        bne     LE295                           ; E298 D0 FB                    ..
LE29A:
        ; now, loop while there's no joypad input
		jsr     READ_JOYPADS                           ; E29A 20 43 CC                  C.
        beq     LE29A                           ; E29D F0 FB                    ..
        
		lda     #$20                            ; E29F A9 20                    . 
        sta     SCROLL_X_HI                             ; E2A1 85 7C                    .|
        jsr     PREP_PASSWORD_SCREEN                           ; E2A3 20 B5 C7                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; E2A6 20 C7 C1                  ..
        rts                                     ; E2A9 60                       `

; ----------------------------------------------------------------------------
; let player enter a password
GRANDPA_ENTER_PASSWORD:
        lda     #$30                            ; E2AA A9 30                    .0
        sta     SCROLL_X_HI                             ; E2AC 85 7C                    .|
        jsr     PREP_PASSWORD_SCREEN                           ; E2AE 20 B5 C7                  ..
        jsr     WIPE_PASSWORD_BUFFER                           ; E2B1 20 5F D1                  _.
        jsr     DRAW_PASSWORD_SCREEN                           ; E2B4 20 E5 D0                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; E2B7 20 C7 C1                  ..
LE2BA:
		; wait for release of joypads
        jsr     READ_JOYPADS                           ; E2BA 20 43 CC                  C.
        bne     LE2BA                           ; E2BD D0 FB                    ..
        
		lda     #$00                            ; E2BF A9 00                    ..
        sta     CUR_OBJ_NEXT_X                             ; E2C1 85 F9                    ..
        sta     CUR_OBJ_DX                             ; E2C3 85 F5                    ..
        sta     CUR_OBJ_DY                             ; E2C5 85 F7                    ..
        
		; manually write some sprites and flags - these are for the password entry cursors
		lda     #$F5                            ; E2C7 A9 F5                    ..
        sta     $0281                           ; E2C9 8D 81 02                 ...
        sta     $0291                           ; E2CC 8D 91 02                 ...
        lda     #$F7                            ; E2CF A9 F7                    ..
        sta     $0285                           ; E2D1 8D 85 02                 ...
        sta     $0295                           ; E2D4 8D 95 02                 ...
        
		lda     #$00                            ; E2D7 A9 00                    ..
        sta     $0282                           ; E2D9 8D 82 02                 ...
        sta     $0286                           ; E2DC 8D 86 02                 ...
        sta     $0292                           ; E2DF 8D 92 02                 ...
        sta     $0296                           ; E2E2 8D 96 02                 ...
        
		jsr     DRAW_PASSWORD_ENTRY_TOP_CURSOR                           ; E2E5 20 D6 E3                  ..
        jsr     DRAW_PASSWORD_ENTRY_BOTTOM_CURSOR                           ; E2E8 20 00 E4                  ..

; handle input on the password entry screen
PASSWORD_ENTRY_CHECK_JOYPAD:
        lda     #$01                            ; E2EB A9 01                    ..
        sta     NMI_WAIT_CTR                             ; E2ED 85 36                    .6
        jsr     READ_JOYPADS                           ; E2EF 20 43 CC                  C.
        
		; branch if a pressed
		bit     JOYPAD_INPUT                             ; E2F2 24 20                    $ 
        bmi     LE32D                           ; E2F4 30 37                    07
        
		; branch if b pressed
		bvs     PASSWORD_ENTRY_TICK_AND_NEXT                           ; E2F6 70 3B                    p;
        
		; branch if right pressed
		lda     JOYPAD_INPUT                             ; E2F8 A5 20                    . 
        lsr     a                               ; E2FA 4A                       J
        bcs     LE31B                           ; E2FB B0 1E                    ..
        
		; branch if left pressed
		lsr     a                               ; E2FD 4A                       J
        bcs     LE321                           ; E2FE B0 21                    .!
        
		; branch if down pressed
		lsr     a                               ; E300 4A                       J
		bcs     LE315                           ; E301 B0 12                    ..
        
		; branch if up pressed
		lsr     a                               ; E303 4A                       J
        bcs     LE327                           ; E304 B0 21                    .!
        
		; branch if select pressed - try the password
		lsr     a                               ; E306 4A                       J
        bcs     LE30F                           ; E307 B0 06                    ..
        
		; branch if start pressed
		lsr     a                               ; E309 4A                       J
        bcs     PASSWORD_ENTRY_CLOSE                           ; E30A B0 58                    .X
        
		; nothing pressed
		jmp     PASSWORD_ENTRY_TICK_AND_NEXT                           ; E30C 4C 33 E3                 L3.

; ----------------------------------------------------------------------------
; select - try password
LE30F:
        jsr     PASSWORD_ENTRY_TRY_PASSWORD                           ; E30F 20 47 E3                  G.
        jmp     PASSWORD_ENTRY_TICK_AND_NEXT                           ; E312 4C 33 E3                 L3.

; ----------------------------------------------------------------------------
; down - move cursor
LE315:
        jsr     PASSWORD_ENTRY_DOWN_PRESSED                           ; E315 20 C7 E3                  ..
        jmp     PASSWORD_ENTRY_TICK_AND_NEXT                           ; E318 4C 33 E3                 L3.

; ----------------------------------------------------------------------------
; right - move cursor
LE31B:
        jsr     PASSWORD_ENTRY_RIGHT_PRESSED                           ; E31B 20 9E E3                  ..
        jmp     PASSWORD_ENTRY_TICK_AND_NEXT                           ; E31E 4C 33 E3                 L3.

; ----------------------------------------------------------------------------
; left - move cursor
LE321:
        jsr     PASSWORD_ENTRY_LEFT_PRESSED                           ; E321 20 AD E3                  ..
        jmp     PASSWORD_ENTRY_TICK_AND_NEXT                           ; E324 4C 33 E3                 L3.

; ----------------------------------------------------------------------------
; up - move cursor
LE327:
        jsr     PASSWORD_ENTRY_UP_PRESSED                           ; E327 20 BA E3                  ..
        jmp     LE330                           ; E32A 4C 30 E3                 L0.

; ----------------------------------------------------------------------------
; a pressed
LE32D:
        jsr     PASSWORD_ENTRY_ADD_LETTER                           ; E32D 20 72 E3                  r.
LE330:
        jsr     DRAW_PASSWORD_SCREEN                           ; E330 20 E5 D0                  ..
PASSWORD_ENTRY_TICK_AND_NEXT:
        ; branch if none of a/b/dpad are pressed - no tick sound
		lda     JOYPAD_INPUT                             ; E333 A5 20                    . 
        and     #$CF                            ; E335 29 CF                    ).
        beq     LE341                           ; E337 F0 08                    ..
        
		; some of a/b/dpad is pressed - tick sound
		lda     #SOUND_EQUIP_SELECT_TICK                            ; E339 A9 0C                    ..
        sta     NEXT_SOUND_EFFECT                             ; E33B 85 8F                    ..
        lda     #$0A                            ; E33D A9 0A                    ..
        sta     NMI_WAIT_CTR                             ; E33F 85 36                    .6
LE341:
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; E341 20 35 C1                  5.
        
		; loop
		jmp     PASSWORD_ENTRY_CHECK_JOYPAD                           ; E344 4C EB E2                 L..

; ----------------------------------------------------------------------------
PASSWORD_ENTRY_TRY_PASSWORD:
		; jump to $b577 / CHECK_PASSWORD
        lda     #$77                            ; E347 A9 77                    .w
        sta     JMP_DEST_0E_LO                           ; E349 85 0E                    ..
        lda     #$B5                            ; E34B A9 B5                    ..
        sta     JMP_DEST_0F_HI                             ; E34D 85 0F                    ..
        jsr     USE_PRG_CD                           ; E34F 20 9C CC                  ..
        bcc     PASSWORD_ACCEPTED                           ; E352 90 01                    ..
        rts                                     ; E354 60                       `

; ----------------------------------------------------------------------------
; password is good; load the relevant game state, play a sound, and don't return to caller after closing password screen
PASSWORD_ACCEPTED:
        lda     #SOUND_SELECT_PRESSED                            ; E355 A9 10                    ..
        sta     NEXT_SOUND_EFFECT                             ; E357 85 8F                    ..
        jsr     RESTORE_PLAYER_HOME_STATE                           ; E359 20 C5 D0                  ..
        jsr     EVENT_PLAYER_KEY_CHANGE                           ; E35C 20 E2 CA                  ..
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; E35F 20 F8 CA                  ..
        pla                                     ; E362 68                       h
        pla                                     ; E363 68                       h

; pressing start jumps here
PASSWORD_ENTRY_CLOSE:
        lda     #$20                            ; E364 A9 20                    . 
        sta     SCROLL_X_HI                             ; E366 85 7C                    .|
        jsr     PREP_PASSWORD_SCREEN                           ; E368 20 B5 C7                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; E36B 20 C7 C1                  ..
        jsr     HOME_DRAW_FAMILY                           ; E36E 20 B2 E7                  ..
        rts                                     ; E371 60                       `

; ----------------------------------------------------------------------------
; password entry - add a letter to the current password
PASSWORD_ENTRY_ADD_LETTER:
        lda     CUR_OBJ_DX                             ; E372 A5 F5                    ..
        asl     a                               ; E374 0A                       .
        asl     a                               ; E375 0A                       .
        adc     CUR_OBJ_DX                             ; E376 65 F5                    e.
        adc     CUR_OBJ_DY                             ; E378 65 F7                    e.
        
		; a = CUR_OBJ_DX*5+DY
		; handle the arrows that move the cursor without selecting a letter
		; move right
		cmp     #$20                            ; E37A C9 20                    . 
        beq     LE392                           ; E37C F0 14                    ..
        
		; move left
		cmp     #$21                            ; E37E C9 21                    .!
        beq     LE398                           ; E380 F0 16                    ..
        
		; submit
		cmp     #$22                            ; E382 C9 22                    ."
        beq     PASSWORD_ENTRY_TRY_PASSWORD                           ; E384 F0 C1                    ..
        
		; set x to the correct buffer pos
		pha                                     ; E386 48                       H
        jsr     PASSWORD_ENTRY_INDEX_TO_X                           ; E387 20 1E E4                  ..
        pla                                     ; E38A 68                       h
        sta     PASSWORD_BUFFER,x                         ; E38B 9D 22 03                 .".
        cpx     #$1F                            ; E38E E0 1F                    ..
        beq     PASSWORD_ENTRY_TRY_PASSWORD                           ; E390 F0 B5                    ..
LE392:
        inc     CUR_OBJ_NEXT_X                             ; E392 E6 F9                    ..
        jsr     DRAW_PASSWORD_ENTRY_TOP_CURSOR                           ; E394 20 D6 E3                  ..
        rts                                     ; E397 60                       `

; ----------------------------------------------------------------------------
LE398:
        dec     CUR_OBJ_NEXT_X                             ; E398 C6 F9                    ..
        jsr     DRAW_PASSWORD_ENTRY_TOP_CURSOR                           ; E39A 20 D6 E3                  ..
        rts                                     ; E39D 60                       `

; ----------------------------------------------------------------------------
; move cursor, check bounds
PASSWORD_ENTRY_RIGHT_PRESSED:
        ldx     CUR_OBJ_DX                             ; E39E A6 F5                    ..
        inx                                     ; E3A0 E8                       .
        cpx     #$07                            ; E3A1 E0 07                    ..
        bcc     LE3A7                           ; E3A3 90 02                    ..
        ldx     #$00                            ; E3A5 A2 00                    ..
LE3A7:
        stx     CUR_OBJ_DX                             ; E3A7 86 F5                    ..
        jsr     DRAW_PASSWORD_ENTRY_BOTTOM_CURSOR                           ; E3A9 20 00 E4                  ..
        rts                                     ; E3AC 60                       `

; ----------------------------------------------------------------------------
; move cursor, check bounds
PASSWORD_ENTRY_LEFT_PRESSED:
        ldx     CUR_OBJ_DX                             ; E3AD A6 F5                    ..
        dex                                     ; E3AF CA                       .
        bpl     LE3B4                           ; E3B0 10 02                    ..
        ldx     #$06                            ; E3B2 A2 06                    ..
LE3B4:
        stx     CUR_OBJ_DX                             ; E3B4 86 F5                    ..
        jsr     DRAW_PASSWORD_ENTRY_BOTTOM_CURSOR                           ; E3B6 20 00 E4                  ..
        rts                                     ; E3B9 60                       `

; ----------------------------------------------------------------------------
; move cursor, check bounds
PASSWORD_ENTRY_UP_PRESSED:
        ldx     CUR_OBJ_DY                             ; E3BA A6 F7                    ..
        dex                                     ; E3BC CA                       .
        bpl     LE3C1                           ; E3BD 10 02                    ..
        ldx     #$04                            ; E3BF A2 04                    ..
LE3C1:
        stx     CUR_OBJ_DY                             ; E3C1 86 F7                    ..
        jsr     DRAW_PASSWORD_ENTRY_BOTTOM_CURSOR                           ; E3C3 20 00 E4                  ..
        rts                                     ; E3C6 60                       `

; ----------------------------------------------------------------------------
; just reposition cursor and loop if needed
PASSWORD_ENTRY_DOWN_PRESSED:
        ldx     CUR_OBJ_DY                             ; E3C7 A6 F7                    ..
        inx                                     ; E3C9 E8                       .
        cpx     #$05                            ; E3CA E0 05                    ..
        bcc     LE3D0                           ; E3CC 90 02                    ..
        ldx     #$00                            ; E3CE A2 00                    ..
LE3D0:
        stx     CUR_OBJ_DY                             ; E3D0 86 F7                    ..
        jsr     DRAW_PASSWORD_ENTRY_BOTTOM_CURSOR                           ; E3D2 20 00 E4                  ..
        rts                                     ; E3D5 60                       `

; ----------------------------------------------------------------------------
; the cursor at the lead of the current password progress
DRAW_PASSWORD_ENTRY_TOP_CURSOR:
        ldx     #$61                            ; E3D6 A2 61                    .a
        
		; branch if cur next x bit 4 clear
		lda     CUR_OBJ_NEXT_X                             ; E3D8 A5 F9                    ..
        and     #$1F                            ; E3DA 29 1F                    ).
        cmp     #$10                            ; E3DC C9 10                    ..
        bcc     LE3E4                           ; E3DE 90 04                    ..
        
		; bit 4 set - subtract, moving the y value of the following sprites down by 8
		sbc     #$10                            ; E3E0 E9 10                    ..
        ldx     #$69                            ; E3E2 A2 69                    .i
LE3E4:
        stx     $0280                           ; E3E4 8E 80 02                 ...
        stx     $0284                           ; E3E7 8E 84 02                 ...
        
		; some gnarly math ensues to calc the sprite x - the shifting arithemetic
		; makes it work out so we can have groups of 4 with spaces in between. Pretty wild.
		; (next_x / 4 + next_x) * 8 + x36 
		sta     SCRATCH_08                             ; E3EA 85 08                    ..
        lsr     a                               ; E3EC 4A                       J
        lsr     a                               ; E3ED 4A                       J
        clc                                     ; E3EE 18                       .
        adc     SCRATCH_08                             ; E3EF 65 08                    e.
        asl     a                               ; E3F1 0A                       .
        asl     a                               ; E3F2 0A                       .
        asl     a                               ; E3F3 0A                       .
        adc     #$36                            ; E3F4 69 36                    i6
        sta     $0287                           ; E3F6 8D 87 02                 ...
        sec                                     ; E3F9 38                       8
        sbc     #$08                            ; E3FA E9 08                    ..
        sta     $0283                           ; E3FC 8D 83 02                 ...
        rts                                     ; E3FF 60                       `

; ----------------------------------------------------------------------------
; used for letting the player select a letter
; CUR_OBJ_DX and CUR_OBJ_DY are re-used off-label here for the cursor x and y pos
DRAW_PASSWORD_ENTRY_BOTTOM_CURSOR:
        ; cur dx * 8 + x36 --> x
		lda     CUR_OBJ_DX                             ; E400 A5 F5                    ..
        asl     a                               ; E402 0A                       .
        asl     a                               ; E403 0A                       .
        asl     a                               ; E404 0A                       .
        adc     #$36                            ; E405 69 36                    i6
        sta     $0297                           ; E407 8D 97 02                 ...
        sec                                     ; E40A 38                       8
        sbc     #$08                            ; E40B E9 08                    ..
        sta     $0293                           ; E40D 8D 93 02                 ...
        lda     CUR_OBJ_DY                             ; E410 A5 F7                    ..
        asl     a                               ; E412 0A                       .
        asl     a                               ; E413 0A                       .
        asl     a                               ; E414 0A                       .
        adc     #$81                            ; E415 69 81                    i.
        sta     $0290                           ; E417 8D 90 02                 ...
        sta     $0294                           ; E41A 8D 94 02                 ...
        rts                                     ; E41D 60                       `

; ----------------------------------------------------------------------------
PASSWORD_ENTRY_INDEX_TO_X:
        lda     CUR_OBJ_NEXT_X                             ; E41E A5 F9                    ..
        and     #$1F                            ; E420 29 1F                    ).
        tax                                     ; E422 AA                       .
        rts                                     ; E423 60                       `

; ----------------------------------------------------------------------------
; enter a shop from the overworld or dungeon
ENTER_SHOP:
		; save player pos so can reappear at same spot on exiting e.g. store
        jsr     SAVE_POS_INFO_TO_STACK                           ; E424 20 20 E6                   .
        lda     SHOP_LEFT_ITEM_ID                             ; E427 A5 80                    ..
        pha                                     ; E429 48                       H
        lda     SHOP_LEFT_ITEM_COST                             ; E42A A5 81                    ..
        pha                                     ; E42C 48                       H
        lda     SHOP_RIGHT_ITEM_ID                             ; E42D A5 82                    ..
        pha                                     ; E42F 48                       H
        lda     SHOP_RIGHT_ITEM_COST                             ; E430 A5 83                    ..
        pha                                     ; E432 48                       H
        
		; fade and load the shop's tiles
		lda     MAP_X                             ; E433 A5 47                    .G
        jsr     FADE_OUT_AND_PREP_SINGLE_SCREEN                           ; E435 20 60 E6                  `.
        
		; restore saved values
		pla                                     ; E438 68                       h
        sta     SHOP_RIGHT_ITEM_COST                             ; E439 85 83                    ..
        pla                                     ; E43B 68                       h
        sta     SHOP_RIGHT_ITEM_ID                             ; E43C 85 82                    ..
        pla                                     ; E43E 68                       h
        sta     SHOP_LEFT_ITEM_COST                             ; E43F 85 81                    ..
        pla                                     ; E441 68                       h
        sta     SHOP_LEFT_ITEM_ID                             ; E442 85 80                    ..
        
		; draw the extras and fade in
		jsr     DRAW_SHOP_ITEMS                           ; E444 20 FF E6                  ..
        jsr     DRAW_SHOP_PRICES                           ; E447 20 BC CF                  ..
        jsr     DRAW_SHOP_INN_KEEPER                           ; E44A 20 78 E7                  x.
        jsr     PALETTE_FADE_IN                           ; E44D 20 92 C4                  ..
SHOP_MAIN:
        ; player interacts with shop
		jsr     RUN_AROUND_INN_SHOP                           ; E450 20 14 E5                  ..
        
		; branch if exited, no purchase
		bcs     LE4A7                           ; E453 B0 52                    .R
        
		; exited, purchase attempted; branch if too far left
		ldx     #$00                            ; E455 A2 00                    ..
        lda     PX_HI                             ; E457 A5 44                    .D
        and     #$0F                            ; E459 29 0F                    ).
        cmp     #$03                            ; E45B C9 03                    ..
        bcc     SHOP_MAIN                           ; E45D 90 F1                    ..
        
		; branch if PX_HI < x05; purchasing left item (x=0)
		cmp     #$05                            ; E45F C9 05                    ..
        bcc     LE46D                           ; E461 90 0A                    ..
        
		; branch if PX_HI < x0A; purchase right item (x=2)
		ldx     #$02                            ; E463 A2 02                    ..
        cmp     #$0A                            ; E465 C9 0A                    ..
        bcc     SHOP_MAIN                           ; E467 90 E7                    ..
        
		; branch if PX_HI >= 0x0c; too far right, just loop
		cmp     #$0C                            ; E469 C9 0C                    ..
        bcs     SHOP_MAIN                           ; E46B B0 E3                    ..
		
		; technically, if x hi=0x0a-b we flow through here and purchase the right item...

LE46D:
		; branch (fail purchase and loop) if no item there - happens if player has too many of that item
		; push the item ID and x value (left/right item indicator)
		lda     SHOP_LEFT_ITEM_ID,x                           ; E46D B5 80                    ..
        bmi     LE489                           ; E46F 30 18                    0.
        pha                                     ; E471 48                       H
        txa                                     ; E472 8A                       .
        pha                                     ; E473 48                       H
        
		; branch if we have enough money
		lda     SHOP_LEFT_ITEM_COST,x                           ; E474 B5 81                    ..
        jsr     CHECK_TAKE_PLAYER_GOLDS                           ; E476 20 42 E8                  B.
        bcs     LE48E                           ; E479 B0 13                    ..
        
		; we don't have enough money - access the item from the stack and branch if not a crystal
		; failing to buy a crystal is one of the cheat triggers
		pla                                     ; E47B 68                       h
        pla                                     ; E47C 68                       h
        cmp     #INV_ITEM_CRYSTAL                            ; E47D C9 0D                    ..
        bne     LE489                           ; E47F D0 08                    ..
        
		; branch if not cheating
		lda     CHEAT_STATUS                             ; E481 A5 37                    .7
        beq     LE489                           ; E483 F0 04                    ..
        
		; cheating - give the player a free set of armor!
		lda     #$01                            ; E485 A9 01                    ..
        sta     PLAYER_INVENTORY+1                             ; E487 85 61                    .a
LE489:
		; failed purchase sound
        lda     #SOUND_OPEN_DOOR                            ; E489 A9 06                    ..
        jmp     LE49D                           ; E48B 4C 9D E4                 L..

; ----------------------------------------------------------------------------
LE48E:
        ; access the left/right indicator, move to x, and remove the item from the shop
		pla                                     ; E48E 68                       h
        tax                                     ; E48F AA                       .
        lda     #$FF                            ; E490 A9 FF                    ..
        sta     SHOP_LEFT_ITEM_ID,x                           ; E492 95 80                    ..
        jsr     DRAW_SHOP_ITEMS                           ; E494 20 FF E6                  ..
        
		; access the item ID and add it to the inventory; play successful purchase sound
		pla                                     ; E497 68                       h
        tax                                     ; E498 AA                       .
        inc     PLAYER_INVENTORY,x                           ; E499 F6 60                    .`
        lda     #SOUND_SELECT_PRESSED                            ; E49B A9 10                    ..
LE49D:
        sta     NEXT_SOUND_EFFECT                             ; E49D 85 8F                    ..
LE49F:
        jsr     READ_JOYPADS                           ; E49F 20 43 CC                  C.
        bne     LE49F                           ; E4A2 D0 FB                    ..
        jmp     SHOP_MAIN                           ; E4A4 4C 50 E4                 LP.

; ----------------------------------------------------------------------------
LE4A7:
        jmp     EXIT_TO_MAP_LEVEL                           ; E4A7 4C FD E5                 L..

; ----------------------------------------------------------------------------
; main loop for the item selection screen
ITEM_SELECTION_SCREEN_MAIN:
        ; let the player run around; exit by pressing a (carry clear) or off bottom of screen (carry set)
		jsr     RUN_AROUND_ITEM_SELECTION_SCREEN                           ; E4AA 20 62 E5                  b.
        
		; branch if exited without pressing a to select an item
		bcs     LE504                           ; E4AD B0 55                    .U
        
		; we pressed a to select an item - see if we get one
		; branch if PY >= x58 - too low for adding items; can shift them though
		ldx     #$FF                            ; E4AF A2 FF                    ..
        lda     PY                             ; E4B1 A5 45                    .E
        cmp     #$58                            ; E4B3 C9 58                    .X
		bcs     LE4DD                           ; E4B5 B0 26                    .&
        
		; branch if PY < x38; we're in the top row and x=0
		ldx     #$00                            ; E4B7 A2 00                    ..
        cmp     #$38                            ; E4B9 C9 38                    .8
        bcc     LE4BF                           ; E4BB 90 02                    ..
        
		; we're in the bottom row and x=8
		ldx     #$08                            ; E4BD A2 08                    ..
LE4BF:
        stx     SCRATCH_08                             ; E4BF 86 08                    ..
        
		; PX_HI/2 = 0-7, ora op will add 8 if in 2nd row to convert PX_HI to an index in x
		lda     PX_HI                             ; E4C1 A5 44                    .D
        lsr     a                               ; E4C3 4A                       J
        ora     SCRATCH_08                             ; E4C4 05 08                    ..
        tax                                     ; E4C6 AA                       .
        lda     PLAYER_INVENTORY,x                           ; E4C7 B5 60                    .`
        
		; branch if player doesn't have any of item x
		beq     LE4D4                           ; E4C9 F0 09                    ..
        
		; we have the item; check if this player can equip it
		txa                                     ; E4CB 8A                       .
        pha                                     ; E4CC 48                       H
        jsr     CHECK_ITEM_USABLE_FOR_PLAYER                           ; E4CD 20 17 D0                  ..
        pla                                     ; E4D0 68                       h
        tax                                     ; E4D1 AA                       .
        
		; branch (equip item) if it's usable
		bcs     EQUIP_ITEM_X                           ; E4D2 B0 07                    ..
LE4D4:
		; carry clear; fail to eqiup if we don't have that item or can't use it
        lda     #SOUND_OPEN_DOOR                            ; E4D4 A9 06                    ..
        sta     NEXT_SOUND_EFFECT                             ; E4D6 85 8F                    ..
        
		; loop
		jmp     ITEM_SELECTION_SCREEN_MAIN                           ; E4D8 4C AA E4                 L..

; ----------------------------------------------------------------------------
; item selection - take from inventory, return equipped item, shift others as needed
EQUIP_ITEM_X:
        dec     PLAYER_INVENTORY,x                           ; E4DB D6 60                    .`
LE4DD:
        ; ID of new item we're equipping goes to SCRATCH_08
		stx     SCRATCH_08                             ; E4DD 86 08                    ..
        
		; the first equipped item (that will be pushed out and un-equipped) --> x
		ldx     CUR_EQUIP_ITEMS                             ; E4DF A6 51                    .Q
        
		; if nothing in the first slot, no need to give any items back to inventory
		; i.e. CUR_EQIUP_ITEMS = 0xFF
		bmi     LE4E5                           ; E4E1 30 02                    0.
        
		; put current first equipped item back 
		inc     PLAYER_INVENTORY,x                           ; E4E3 F6 60                    .`
LE4E5:
        ; middle item goes to left
		lda     CUR_EQUIP_ITEMS+1                             ; E4E5 A5 52                    .R
        sta     CUR_EQUIP_ITEMS                             ; E4E7 85 51                    .Q
        
		; right item goes to middle
		lda     CUR_EQUIP_ITEMS+2                             ; E4E9 A5 53                    .S
        sta     CUR_EQUIP_ITEMS+1                             ; E4EB 85 52                    .R
        
		; new item goes to right
		lda     SCRATCH_08                             ; E4ED A5 08                    ..
        sta     CUR_EQUIP_ITEMS+2                             ; E4EF 85 53                    .S
        
		; play a sound
		lda     #SOUND_MYRNA_SHOT                            ; E4F1 A9 12                    ..
        sta     NEXT_SOUND_EFFECT                             ; E4F3 85 8F                    ..
        
		jsr     ITEM_SCREEN_DRAW_EQUIPPED_ITEMS                           ; E4F5 20 B7 E6                  ..
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; E4F8 20 34 C2                  4.
        jsr     DRAW_ALL_INV_ITEM_QTY                           ; E4FB 20 30 CF                  0.
        jsr     DRAW_START_SCR_PLAYER_STATS                           ; E4FE 20 82 CF                  ..
        
		; loop
		jmp     ITEM_SELECTION_SCREEN_MAIN                           ; E501 4C AA E4                 L..

; ----------------------------------------------------------------------------
LE504:
        ldx     CUR_EQUIP_SLOT_SELECTED                             ; E504 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; E506 B5 51                    .Q
        cmp     #INV_ITEM_CRYSTAL                            ; E508 C9 0D                    ..
        
		; branch if current equipped item not the crystal
		bne     LE513                           ; E50A D0 07                    ..
        
		; it is the crystal; clear equipment selection
		lda     #EQUIP_SLOT_NOTHING_SELECTED                            ; E50C A9 03                    ..
        sta     CUR_EQUIP_SLOT_SELECTED                             ; E50E 85 55                    .U
        jsr     DRAW_EQUIP_ITEM_CURSOR                           ; E510 20 34 C2                  4.
LE513:
        rts                                     ; E513 60                       `

; ----------------------------------------------------------------------------
; player in the inn/shop
; return - clear carry if a was pressed
RUN_AROUND_INN_SHOP:
        lda     #$01                            ; E514 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; E516 85 36                    .6
        jsr     READ_JOYPADS                           ; E518 20 43 CC                  C.
        
		; branch if A pressed - exits loop
		lda     JOYPAD_INPUT                             ; E51B A5 20                    . 
        and     #BTN_A                            ; E51D 29 80                    ).
        bne     SHOP_INN_YES                           ; E51F D0 3D                    .=
        
		; a not pressed
		; restrict a to dpad input
		; y=player speed, forced to 1
		lda     JOYPAD_INPUT                             ; E521 A5 20                    . 
        and     #$0F                            ; E523 29 0F                    ).
        ldy     #$01                            ; E525 A0 01                    ..
        jsr     NORMAL_PLAY_CALC_PLAYER_MOVE_VECTOR                           ; E527 20 2C CD                  ,.
        jsr     CALC_NEXT_PLAYER_POS                           ; E52A 20 B6 D8                  ..
        
		; branch if running up toward counter, skip movement
		lda     TEMP_NEXT_Y                             ; E52D A5 0A                    ..
        cmp     #$8C                            ; E52F C9 8C                    ..
        bcc     LE54F                           ; E531 90 1C                    ..
        
		; branch if at bottom of screen - time to go!
		cmp     #$A1                            ; E533 C9 A1                    ..
        bcs     SHOP_INN_NO                           ; E535 B0 29                    .)
        
		; otherwise, let the player run around
		lda     TEMP_NEXT_X_HI                             ; E537 A5 0F                    ..
        and     #$0F                            ; E539 29 0F                    ).
        cmp     #$02                            ; E53B C9 02                    ..
        bcc     LE54F                           ; E53D 90 10                    ..
        cmp     #$0D                            ; E53F C9 0D                    ..
        bcs     LE54F                           ; E541 B0 0C                    ..
        lda     TEMP_NEXT_X_LO                           ; E543 A5 0E                    ..
        sta     PX_LO                             ; E545 85 43                    .C
        lda     TEMP_NEXT_X_HI                             ; E547 A5 0F                    ..
        sta     PX_HI                             ; E549 85 44                    .D
        lda     TEMP_NEXT_Y                             ; E54B A5 0A                    ..
        sta     PY                             ; E54D 85 45                    .E
LE54F:
        jsr     CALC_PLAYER_FRAME_AND_SPRITE_FLAGS                           ; E54F 20 E3 D8                  ..
        jsr     APPLY_PLAYER_FRAME_ANIMATIONS                           ; E552 20 4E D9                  N.
        jsr     DRAW_PLAYER                           ; E555 20 D8 C1                  ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; E558 20 35 C1                  5.
        
		; loop
		jmp     RUN_AROUND_INN_SHOP                           ; E55B 4C 14 E5                 L..

; ----------------------------------------------------------------------------
; purchasing
SHOP_INN_YES:
        clc                                     ; E55E 18                       .
        rts                                     ; E55F 60                       `

; ----------------------------------------------------------------------------
; exiting the shop/in
SHOP_INN_NO:
        sec                                     ; E560 38                       8
        rts                                     ; E561 60                       `

; ----------------------------------------------------------------------------
; player walks around the item screen and selects their equipment
RUN_AROUND_ITEM_SELECTION_SCREEN:
        lda     #$01                            ; E562 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; E564 85 36                    .6
        jsr     READ_JOYPADS                           ; E566 20 43 CC                  C.
        
		; branch if a pressed - select item
		lda     JOYPAD_INPUT                             ; E569 A5 20                    . 
        and     #BTN_A                            ; E56B 29 80                    ).
        bne     EXIT_CHECK_SELECT_ITEM                           ; E56D D0 41                    .A
        
		; a not pressed; y=speed of 1, move the player
		lda     JOYPAD_INPUT                             ; E56F A5 20                    . 
        and     #$0F                            ; E571 29 0F                    ).
        ldy     #$01                            ; E573 A0 01                    ..
        jsr     NORMAL_PLAY_CALC_PLAYER_MOVE_VECTOR                           ; E575 20 2C CD                  ,.
        jsr     CALC_NEXT_PLAYER_POS                           ; E578 20 B6 D8                  ..
        
		; branch if TEMP_NEXT_Y < x20; we're at the top and can't go higher
		lda     TEMP_NEXT_Y                             ; E57B A5 0A                    ..
        cmp     #$20                            ; E57D C9 20                    . 
        bcc     LE5A1                           ; E57F 90 20                    . 
        
		; branch if TEMP_NEXT_Y >= xA1 - we're at the bottom; exit
		cmp     #$A1                            ; E581 C9 A1                    ..
        bcs     EXIT_NO_SELECT_ITEM                           ; E583 B0 2D                    .-
        
		lda     TEMP_NEXT_X_HI                             ; E585 A5 0F                    ..
        and     #$0F                            ; E587 29 0F                    ).
        cmp     #$01                            ; E589 C9 01                    ..
        bcc     LE5A1                           ; E58B 90 14                    ..
        
		cmp     #$0F                            ; E58D C9 0F                    ..
        bcc     LE595                           ; E58F 90 04                    ..
        
		lda     TEMP_NEXT_X_LO                           ; E591 A5 0E                    ..
        bne     LE5A1                           ; E593 D0 0C                    ..
LE595:
		; update the player position
        lda     TEMP_NEXT_X_LO                           ; E595 A5 0E                    ..
        sta     PX_LO                             ; E597 85 43                    .C
        lda     TEMP_NEXT_X_HI                             ; E599 A5 0F                    ..
        sta     PX_HI                             ; E59B 85 44                    .D
        lda     TEMP_NEXT_Y                             ; E59D A5 0A                    ..
        sta     PY                             ; E59F 85 45                    .E
LE5A1:
        jsr     CALC_PLAYER_FRAME_AND_SPRITE_FLAGS                           ; E5A1 20 E3 D8                  ..
        jsr     APPLY_PLAYER_FRAME_ANIMATIONS                           ; E5A4 20 4E D9                  N.
        jsr     DRAW_PLAYER                           ; E5A7 20 D8 C1                  ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; E5AA 20 35 C1                  5.
        jmp     RUN_AROUND_ITEM_SELECTION_SCREEN                           ; E5AD 4C 62 E5                 Lb.

; ----------------------------------------------------------------------------
; we pressed a to try to select something
EXIT_CHECK_SELECT_ITEM:
        clc                                     ; E5B0 18                       .
        rts                                     ; E5B1 60                       `

; ----------------------------------------------------------------------------
; we exited from the bottom of the screen
EXIT_NO_SELECT_ITEM:
        sec                                     ; E5B2 38                       8
        rts                                     ; E5B3 60                       `

; ----------------------------------------------------------------------------
; lets you move the hand around until you press a to select something; at that 
; point we rts to check for any action
HOME_WAIT_FOR_BTN_A_PRESSED:
        lda     #$01                            ; E5B4 A9 01                    ..
        sta     NMI_WAIT_CTR                             ; E5B6 85 36                    .6
        jsr     READ_JOYPADS                           ; E5B8 20 43 CC                  C.
        
		; branch (rts) if a was pressed
		lda     JOYPAD_INPUT                             ; E5BB A5 20                    . 
        and     #BTN_A                            ; E5BD 29 80                    ).
        bne     LE5FC                           ; E5BF D0 3B                    .;
        
		; a was not pressed
		lda     JOYPAD_INPUT                             ; E5C1 A5 20                    . 
        and     #$0F                            ; E5C3 29 0F                    ).
        ldy     #$01                            ; E5C5 A0 01                    ..
        jsr     NORMAL_PLAY_CALC_PLAYER_MOVE_VECTOR                           ; E5C7 20 2C CD                  ,.
        jsr     CALC_NEXT_PLAYER_POS                           ; E5CA 20 B6 D8                  ..
        
		; enforce x/y bounds
		; branch if too high
		lda     TEMP_NEXT_Y                             ; E5CD A5 0A                    ..
        cmp     #$30                            ; E5CF C9 30                    .0
        bcc     LE5F3                           ; E5D1 90 20                    . 
        
		; branch if too low
		cmp     #$A1                            ; E5D3 C9 A1                    ..
        bcs     LE5F3                           ; E5D5 B0 1C                    ..
        
		; branch if too far left
		lda     TEMP_NEXT_X_HI                             ; E5D7 A5 0F                    ..
        and     #$0F                            ; E5D9 29 0F                    ).
        cmp     #$02                            ; E5DB C9 02                    ..
        bcc     LE5F3                           ; E5DD 90 14                    ..
        
		; branch if not too far right
		cmp     #$0D                            ; E5DF C9 0D                    ..
        bcc     LE5E7                           ; E5E1 90 04                    ..
        
		; branch if x not aligned to block
		lda     TEMP_NEXT_X_LO                           ; E5E3 A5 0E                    ..
        bne     LE5F3                           ; E5E5 D0 0C                    ..
LE5E7:
        ; update position
		lda     TEMP_NEXT_X_LO                           ; E5E7 A5 0E                    ..
        sta     PX_LO                             ; E5E9 85 43                    .C
        lda     TEMP_NEXT_X_HI                             ; E5EB A5 0F                    ..
        sta     PX_HI                             ; E5ED 85 44                    .D
        lda     TEMP_NEXT_Y                             ; E5EF A5 0A                    ..
        sta     PY                             ; E5F1 85 45                    .E
LE5F3:
        jsr     DRAW_PLAYER                           ; E5F3 20 D8 C1                  ..
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; E5F6 20 35 C1                  5.
        
		; loop
		jmp     HOME_WAIT_FOR_BTN_A_PRESSED                           ; E5F9 4C B4 E5                 L..

; ----------------------------------------------------------------------------
LE5FC:
        rts                                     ; E5FC 60                       `

; ----------------------------------------------------------------------------
; exiting shop/home/inn; fade out, restore and draw the old map's data, and fade in
EXIT_TO_MAP_LEVEL:
        jsr     LOAD_POS_INFO_FROM_STACK                           ; E5FD 20 42 E6                  B.
        jsr     PALETTE_FADE_OUT                           ; E600 20 E5 C3                  ..
        jsr     HIDE_SHOP_SPRITES                           ; E603 20 9D E7                  ..
        lda     LAST_MUSIC_ID                             ; E606 A5 FE                    ..
        jsr     LOAD_MUSIC_DATA_IF_NEC                           ; E608 20 2E D0                  ..
        jsr     LOAD_MAP_NO_TILES                           ; E60B 20 FF C8                  ..
        jsr     LOAD_GRAPHICS_FOR_MAP_LEVEL                           ; E60E 20 CB C5                  ..
        jsr     DRAW_PLAYER                           ; E611 20 D8 C1                  ..
        jsr     DRAW_OBJECTS                           ; E614 20 B1 C2                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; E617 20 C7 C1                  ..
        jsr     PALETTE_FADE_IN                           ; E61A 20 92 C4                  ..
        jmp     MAKE_PLAYER_FRAME                           ; E61D 4C AF D8                 L..

; ----------------------------------------------------------------------------
; save position info to the stack - for easing return after visiting home/shop/inn
SAVE_POS_INFO_TO_STACK:
        pla                                     ; E620 68                       h
        tax                                     ; E621 AA                       .
        pla                                     ; E622 68                       h
        tay                                     ; E623 A8                       .
        
		; for whatever reason, MUSIC_ID saved in zero page rather than stack
		lda     MUSIC_ID                             ; E624 A5 8E                    ..
        sta     LAST_MUSIC_ID                             ; E626 85 FE                    ..
        lda     PX_LO                             ; E628 A5 43                    .C
        pha                                     ; E62A 48                       H
        lda     PX_HI                             ; E62B A5 44                    .D
        pha                                     ; E62D 48                       H
        lda     PY                             ; E62E A5 45                    .E
        pha                                     ; E630 48                       H
        lda     SCROLL_X_LO                             ; E631 A5 7B                    .{
        pha                                     ; E633 48                       H
        lda     SCROLL_X_HI                             ; E634 A5 7C                    .|
        pha                                     ; E636 48                       H
        lda     MAP_X                             ; E637 A5 47                    .G
        pha                                     ; E639 48                       H
        lda     MAP_Y                             ; E63A A5 48                    .H
        pha                                     ; E63C 48                       H
        tya                                     ; E63D 98                       .
        pha                                     ; E63E 48                       H
        txa                                     ; E63F 8A                       .
        pha                                     ; E640 48                       H
        rts                                     ; E641 60                       `

; ----------------------------------------------------------------------------
; reverse of the above; pulling the info out
LOAD_POS_INFO_FROM_STACK:
        pla                                     ; E642 68                       h
        tax                                     ; E643 AA                       .
        pla                                     ; E644 68                       h
        tay                                     ; E645 A8                       .
        pla                                     ; E646 68                       h
        sta     MAP_Y                             ; E647 85 48                    .H
        pla                                     ; E649 68                       h
        sta     MAP_X                             ; E64A 85 47                    .G
        pla                                     ; E64C 68                       h
        sta     SCROLL_X_HI                             ; E64D 85 7C                    .|
        pla                                     ; E64F 68                       h
        sta     SCROLL_X_LO                             ; E650 85 7B                    .{
        pla                                     ; E652 68                       h
        sta     PY                             ; E653 85 45                    .E
        pla                                     ; E655 68                       h
        sta     PX_HI                             ; E656 85 44                    .D
        pla                                     ; E658 68                       h
        sta     PX_LO                             ; E659 85 43                    .C
        tya                                     ; E65B 98                       .
        pha                                     ; E65C 48                       H
        txa                                     ; E65D 8A                       .
        pha                                     ; E65E 48                       H
        rts                                     ; E65F 60                       `

; ----------------------------------------------------------------------------
; called when entering shop, inn, start screen
; input: a - stored on stack and used to select TILE_DEFS_HI and MAP_X
FADE_OUT_AND_PREP_SINGLE_SCREEN:
        pha                                     ; E660 48                       H
        jsr     PALETTE_FADE_OUT                           ; E661 20 E5 C3                  ..
        jmp     LE66B                           ; E664 4C 6B E6                 Lk.

; ----------------------------------------------------------------------------
; as above, but we don't fade the status bar
FADE_OUT_AND_PREP_SINGLE_SCREEN_KEEP_STATUS_BAR:
        pha                                     ; E667 48                       H
        jsr     PALETTE_FADE_OUT_KEEP_STATUS_BAR                           ; E668 20 30 C4                  0.

; input: top of stack (see above) used to select TILE_DEFS_HI and MAP_X
LE66B:
        ; bits 2-3 of input from stack divided by 4 --> MAP_X
		pla                                     ; E66B 68                       h
        pha                                     ; E66C 48                       H
        sta     SCRATCH_08                             ; E66D 85 08                    ..
        and     #$0C                            ; E66F 29 0C                    ).
        lsr     a                               ; E671 4A                       J
        lsr     a                               ; E672 4A                       J
        sta     MAP_X                             ; E673 85 47                    .G
        lda     SCRATCH_08                             ; E675 A5 08                    ..
        and     #$03                            ; E677 29 03                    ).
        asl     a                               ; E679 0A                       .
        asl     a                               ; E67A 0A                       .
        asl     a                               ; E67B 0A                       .
        asl     a                               ; E67C 0A                       .
        sta     SCROLL_X_HI                             ; E67D 85 7C                    .|
        clc                                     ; E67F 18                       .
        adc     #$07                            ; E680 69 07                    i.
        sta     PX_HI                             ; E682 85 44                    .D
        
		; shops are in overworld row
		lda     #MAP_Y_OVERWORLD                            ; E684 A9 10                    ..
        sta     MAP_Y                             ; E686 85 48                    .H
        
		; set initial position
		lda     #$08                            ; E688 A9 08                    ..
        sta     PX_LO                             ; E68A 85 43                    .C
        lda     #$A0                            ; E68C A9 A0                    ..
        sta     PY                             ; E68E 85 45                    .E
        
		; clear jump/scroll vars not needed indoors
		lda     #$00                            ; E690 A9 00                    ..
        sta     JUMP_FRAMES_REMAINING                             ; E692 85 4F                    .O
        sta     CTR_PLAYER_DESCENT                             ; E694 85 4E                    .N
        sta     SCROLL_X_LO                             ; E696 85 7B                    .{
        
		; hide sprites, load the map
		jsr     HIDE_SPRITES_280_UP                           ; E698 20 7C D0                  |.
        jsr     LOAD_MAP_NO_TILES                           ; E69B 20 FF C8                  ..
        
		; branch if stack value <> 4
		pla                                     ; E69E 68                       h
        cmp     #$04                            ; E69F C9 04                    ..
        bne     LE6AA                           ; E6A1 D0 07                    ..
        
		; stack value was 4, load graphics from $bfxx
		lda     #$1F                            ; E6A3 A9 1F                    ..
        clc                                     ; E6A5 18                       .
        adc     #$A0                            ; E6A6 69 A0                    i.
        sta     TILE_DEFS_HI                             ; E6A8 85 7A                    .z
LE6AA:
		; load graphics and draw
        jsr     LOAD_GRAPHICS_SHOP_INN                           ; E6AA 20 DC C5                  ..
        jsr     CALC_PLAYER_FRAME_AND_SPRITE_FLAGS                           ; E6AD 20 E3 D8                  ..
        jsr     DRAW_PLAYER                           ; E6B0 20 D8 C1                  ..
        jsr     UPDATE_PPU_SCROLL_X                           ; E6B3 20 C7 C1                  ..
        rts                                     ; E6B6 60                       `

; ----------------------------------------------------------------------------
; draw the 0-3 items currently equipped at bottom/left on the item selection screen
; they are also drawn on the status bar at top/right separately
ITEM_SCREEN_DRAW_EQUIPPED_ITEMS:
        ; start x coord
		lda     #$58                            ; E6B7 A9 58                    .X
        sta     SCRATCH_08                             ; E6B9 85 08                    ..
        
		; x=loop counter, y=offset to sprite data for each item
		ldx     #$02                            ; E6BB A2 02                    ..
        ldy     #$10                            ; E6BD A0 10                    ..
LE6BF:
        lda     CUR_EQUIP_ITEMS,x                           ; E6BF B5 51                    .Q
        
		; branch (offscreen) if slot empty
		bmi     LE6D6                           ; E6C1 30 13                    0.
        
		; sprite ID = item ID*4+xA1
		asl     a                               ; E6C3 0A                       .
        asl     a                               ; E6C4 0A                       .
        clc                                     ; E6C5 18                       .
        adc     #$A1                            ; E6C6 69 A1                    i.
        sta     $0241,y                         ; E6C8 99 41 02                 .A.
        clc                                     ; E6CB 18                       .
        adc     #$02                            ; E6CC 69 02                    i.
        sta     $0245,y                         ; E6CE 99 45 02                 .E.
        
		; y coord = xBB
		lda     #$BB                            ; E6D1 A9 BB                    ..
        jmp     LE6D8                           ; E6D3 4C D8 E6                 L..

; ----------------------------------------------------------------------------
LE6D6:
        lda     #OFFSCREEN_Y                            ; E6D6 A9 EF                    ..
LE6D8:
        ; set y coords
		sta     $0240,y                         ; E6D8 99 40 02                 .@.
        sta     $0244,y                         ; E6DB 99 44 02                 .D.
        
		; set x coords
		lda     SCRATCH_08                             ; E6DE A5 08                    ..
        sta     $0243,y                         ; E6E0 99 43 02                 .C.
        clc                                     ; E6E3 18                       .
        adc     #$08                            ; E6E4 69 08                    i.
        sta     $0247,y                         ; E6E6 99 47 02                 .G.
        
		; prep for next item's x coord
		sec                                     ; E6E9 38                       8
        sbc     #$28                            ; E6EA E9 28                    .(
        sta     SCRATCH_08                             ; E6EC 85 08                    ..
        
		; set flags
		lda     #$01                            ; E6EE A9 01                    ..
        sta     $0242,y                         ; E6F0 99 42 02                 .B.
        sta     $0246,y                         ; E6F3 99 46 02                 .F.
        
		; next item drawn 2 sprite slots earlier (8 bytes)
		tya                                     ; E6F6 98                       .
        sec                                     ; E6F7 38                       8
        sbc     #$08                            ; E6F8 E9 08                    ..
        tay                                     ; E6FA A8                       .
        dex                                     ; E6FB CA                       .
        
		; loop while x >= 0
		bpl     LE6BF                           ; E6FC 10 C1                    ..
        rts                                     ; E6FE 60                       `

; ----------------------------------------------------------------------------
; Draw the items in the shop, specified by SHOP_LEFT_ITEM_ID and SHOP_RIGHT_ITEM_ID. 
DRAW_SHOP_ITEMS:
        ; branch if SHOP_LEFT_ITEM_ID is negative - item already purchased or player has too many
		lda     #OFFSCREEN_Y                            ; E6FF A9 EF                    ..
        ldx     SHOP_LEFT_ITEM_ID                             ; E701 A6 80                    ..
		bmi     LE72D                           ; E703 30 28                    0(
		
		; we have a valid item; branch if we own < 11 of them
		lda     PLAYER_INVENTORY,x                           ; E705 B5 60                    .`
        cmp     #$0B                            ; E707 C9 0B                    ..
        bcc     LE712                           ; E709 90 07                    ..
        
		; >= 11 items owned; item will not appear and is set to negative
		lda     #OFFSCREEN_Y                            ; E70B A9 EF                    ..
        sta     SHOP_LEFT_ITEM_ID                             ; E70D 85 80                    ..
        jmp     LE72D                           ; E70F 4C 2D E7                 L-.

; ----------------------------------------------------------------------------
LE712:
        ; draw the item at sprites $0240, $0244
		txa                                     ; E712 8A                       .
        asl     a                               ; E713 0A                       .
        asl     a                               ; E714 0A                       .
        clc                                     ; E715 18                       .
        adc     #$A1                            ; E716 69 A1                    i.
        sta     $0241                           ; E718 8D 41 02                 .A.
        clc                                     ; E71B 18                       .
        adc     #$02                            ; E71C 69 02                    i.
        sta     $0245                           ; E71E 8D 45 02                 .E.
        lda     #$40                            ; E721 A9 40                    .@
        sta     $0243                           ; E723 8D 43 02                 .C.
        lda     #$48                            ; E726 A9 48                    .H
        sta     $0247                           ; E728 8D 47 02                 .G.
        lda     #$A4                            ; E72B A9 A4                    ..
LE72D:
        sta     $0240                           ; E72D 8D 40 02                 .@.
        sta     $0244                           ; E730 8D 44 02                 .D.
        lda     #$01                            ; E733 A9 01                    ..
        sta     $0242                           ; E735 8D 42 02                 .B.
        sta     $0246                           ; E738 8D 46 02                 .F.
        
		lda     #OFFSCREEN_Y                            ; E73B A9 EF                    ..
        ldx     SHOP_RIGHT_ITEM_ID                             ; E73D A6 82                    ..
        
		; branch if SHOP_RIGHT_ITEM_ID negative (already purchased or player owns too many)
		bmi     LE769                           ; E73F 30 28                    0(
        
		; branch if player owns <11 of them
		lda     PLAYER_INVENTORY,x                           ; E741 B5 60                    .`
        cmp     #$0B                            ; E743 C9 0B                    ..
		bcc     LE74E                           ; E745 90 07                    ..
        
		; player owns 11+; set SHOP_RIGHT_ITEM_ID negative
		lda     #OFFSCREEN_Y                            ; E747 A9 EF                    ..
        sta     SHOP_RIGHT_ITEM_ID                             ; E749 85 82                    ..
        jmp     LE769                           ; E74B 4C 69 E7                 Li.

; ----------------------------------------------------------------------------
LE74E:
		; draw item at sprites $0248, $024c; y=xA0, x=xB0
        txa                                     ; E74E 8A                       .
        asl     a                               ; E74F 0A                       .
        asl     a                               ; E750 0A                       .
        clc                                     ; E751 18                       .
        adc     #$A1                            ; E752 69 A1                    i.
        sta     $0249                           ; E754 8D 49 02                 .I.
        clc                                     ; E757 18                       .
        adc     #$02                            ; E758 69 02                    i.
        sta     $024D                           ; E75A 8D 4D 02                 .M.
        lda     #$B0                            ; E75D A9 B0                    ..
        sta     $024B                           ; E75F 8D 4B 02                 .K.
        lda     #$B8                            ; E762 A9 B8                    ..
        sta     $024F                           ; E764 8D 4F 02                 .O.
        lda     #$A0                            ; E767 A9 A0                    ..
LE769:
        sta     $0248                           ; E769 8D 48 02                 .H.
        sta     $024C                           ; E76C 8D 4C 02                 .L.
        lda     #$01                            ; E76F A9 01                    ..
        sta     $024A                           ; E771 8D 4A 02                 .J.
        sta     $024E                           ; E774 8D 4E 02                 .N.
        rts                                     ; E777 60                       `

; ----------------------------------------------------------------------------
; shop/inn keeper use exactly the same sprites
DRAW_SHOP_INN_KEEPER:
        ; y coord
		lda     #$98                            ; E778 A9 98                    ..
        sta     $0250                           ; E77A 8D 50 02                 .P.
        sta     $0254                           ; E77D 8D 54 02                 .T.
        
		; sprite IDs
		lda     #$F1                            ; E780 A9 F1                    ..
        sta     $0251                           ; E782 8D 51 02                 .Q.
        lda     #$F3                            ; E785 A9 F3                    ..
        sta     $0255                           ; E787 8D 55 02                 .U.
        
		; flags
		lda     #$02                            ; E78A A9 02                    ..
        sta     $0252                           ; E78C 8D 52 02                 .R.
        sta     $0256                           ; E78F 8D 56 02                 .V.
        
		; x coords
		lda     #$78                            ; E792 A9 78                    .x
        sta     $0253                           ; E794 8D 53 02                 .S.
        lda     #$80                            ; E797 A9 80                    ..
        sta     $0257                           ; E799 8D 57 02                 .W.
        rts                                     ; E79C 60                       `

; ----------------------------------------------------------------------------
; hides the keeper and items
HIDE_SHOP_SPRITES:
        lda     #OFFSCREEN_Y                            ; E79D A9 EF                    ..
        
		; items
		sta     $0240                           ; E79F 8D 40 02                 .@.
        sta     $0244                           ; E7A2 8D 44 02                 .D.
        sta     $0248                           ; E7A5 8D 48 02                 .H.
        sta     $024C                           ; E7A8 8D 4C 02                 .L.
        
		; keeper
		sta     $0250                           ; E7AB 8D 50 02                 .P.
        sta     $0254                           ; E7AE 8D 54 02                 .T.
        rts                                     ; E7B1 60                       `

; ----------------------------------------------------------------------------
; the family in the home are drawn as sprites, not bg, just so they can disappear
; when a player is selected
HOME_DRAW_FAMILY:
		; load 56 bytes of sprite data from table to $0280,x 
        ldx     #$37                            ; E7B2 A2 37                    .7
LE7B4:
        lda     TBL_HOME_SPRITES,x                         ; E7B4 BD 6F FF                 .o.
        sta     $0280,x                         ; E7B7 9D 80 02                 ...
        dex                                     ; E7BA CA                       .
        bpl     LE7B4                           ; E7BB 10 F7                    ..
        
		; set the pattern tables
		lda     #$34                            ; E7BD A9 34                    .4
        sta     CHR_BANK_PLAYER_SPRITES                             ; E7BF 85 2C                    .,
        lda     #$35                            ; E7C1 A9 35                    .5
        sta     CHR_BANK_ENEMY_SPRITES                             ; E7C3 85 2D                    .-
        lda     #$36                            ; E7C5 A9 36                    .6
        sta     CHR_BANK_SPRITES_02                             ; E7C7 85 2E                    ..
        lda     #$37                            ; E7C9 A9 37                    .7
        sta     CHR_BANK_SPRITES_03                             ; E7CB 85 2F                    ./
        rts                                     ; E7CD 60                       `

; ----------------------------------------------------------------------------
; drop player life by 1; used for spikes and falls; carry set if we don't have life!
DECREMENT_PLAYER_LIFE:
        lda     PLAYER_LIFE                             ; E7CE A5 58                    .X
        
		; branch if life already 0
		beq     LE7D9                           ; E7D0 F0 07                    ..
        
		; else decrease it and clear carry
		dec     PLAYER_LIFE                             ; E7D2 C6 58                    .X
        jsr     EVENT_PLAYER_LIFE_CHANGE                           ; E7D4 20 B6 CA                  ..
        clc                                     ; E7D7 18                       .
        rts                                     ; E7D8 60                       `

; ----------------------------------------------------------------------------
LE7D9:
		; no life - fatal hit!
        sec                                     ; E7D9 38                       8
        rts                                     ; E7DA 60                       `

; ----------------------------------------------------------------------------
; input a=# to steal
; output - carry set = dead, carry clear = alive
STEAL_PLAYER_LIFE:
        sta     SCRATCH_08                             ; E7DB 85 08                    ..
        lda     PLAYER_LIFE                             ; E7DD A5 58                    .X
        sec                                     ; E7DF 38                       8
        sbc     SCRATCH_08                             ; E7E0 E5 08                    ..
        sta     PLAYER_LIFE                             ; E7E2 85 58                    .X
        php                                     ; E7E4 08                       .
        
		; branch if player still has life
		bcs     LE7EB                           ; E7E5 B0 04                    ..
        
		; otherwise go to 0
		lda     #$00                            ; E7E7 A9 00                    ..
        sta     PLAYER_LIFE                             ; E7E9 85 58                    .X
LE7EB:
        jsr     EVENT_PLAYER_LIFE_CHANGE                           ; E7EB 20 B6 CA                  ..
        
		; preserve carry set on earlier subtraction; so caller knows if we're dead
		plp                                     ; E7EE 28                       (
        rts                                     ; E7EF 60                       `

; ----------------------------------------------------------------------------
; use 1 magic and flag the necessary graphics changes
; if PLAYER_MAGIC = 0 we leave it but set carry
; return: carry clear if magic used, set if magic empty
DECREMENT_PLAYER_MAGIC:
        txa                                     ; E7F0 8A                       .
        pha                                     ; E7F1 48                       H
        lda     PLAYER_MAGIC                             ; E7F2 A5 59                    .Y
        sec                                     ; E7F4 38                       8
        beq     LE7FD                           ; E7F5 F0 06                    ..
        dec     PLAYER_MAGIC                             ; E7F7 C6 59                    .Y
        jsr     EVENT_PLAYER_MAGIC_CHANGE                           ; E7F9 20 CC CA                  ..
        clc                                     ; E7FC 18                       .
LE7FD:
        pla                                     ; E7FD 68                       h
        tax                                     ; E7FE AA                       .
        rts                                     ; E7FF 60                       `

; ----------------------------------------------------------------------------
; input - a = how much to add
ADD_PLAYER_LIFE:
        ; add life and branch if no rollover
		clc                                     ; E800 18                       .
        adc     PLAYER_LIFE                             ; E801 65 58                    eX
        bcc     LE80A                           ; E803 90 05                    ..
        
		; illegal change requested - set to max value
		lda     #MAX_PLAYER_STAT                            ; E805 A9 6D                    .m
        jmp     LE810                           ; E807 4C 10 E8                 L..

; ----------------------------------------------------------------------------
LE80A:
		; enforce max of 109
        cmp     #$6E                            ; E80A C9 6E                    .n
        bcc     LE810                           ; E80C 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; E80E A9 6D                    .m
LE810:
		; save it and update the status bar
        sta     PLAYER_LIFE                             ; E810 85 58                    .X
        jsr     EVENT_PLAYER_LIFE_CHANGE                           ; E812 20 B6 CA                  ..
        rts                                     ; E815 60                       `

; ----------------------------------------------------------------------------
; input - a = qty to add
ADD_PLAYER_MAGIC:
        clc                                     ; E816 18                       .
        adc     PLAYER_MAGIC                             ; E817 65 59                    eY
        bcc     LE820                           ; E819 90 05                    ..
        lda     #MAX_PLAYER_STAT                            ; E81B A9 6D                    .m
        jmp     LE826                           ; E81D 4C 26 E8                 L&.

; ----------------------------------------------------------------------------
LE820:
		; enforce max of 109
        cmp     #$6E                            ; E820 C9 6E                    .n
        bcc     LE826                           ; E822 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; E824 A9 6D                    .m
LE826:
		; save it and update status bar
        sta     PLAYER_MAGIC                             ; E826 85 59                    .Y
        jsr     EVENT_PLAYER_MAGIC_CHANGE                           ; E828 20 CC CA                  ..
        rts                                     ; E82B 60                       `

; ----------------------------------------------------------------------------
; input - a = qty to add
ADD_PLAYER_GOLDS:
        clc                                     ; E82C 18                       .
        adc     PLAYER_GOLDS                             ; E82D 65 5A                    eZ
        bcc     LE836                           ; E82F 90 05                    ..
        lda     #MAX_PLAYER_STAT                            ; E831 A9 6D                    .m
        jmp     LE83C                           ; E833 4C 3C E8                 L<.

; ----------------------------------------------------------------------------
LE836:
		; enforce max of 109
        cmp     #$6E                            ; E836 C9 6E                    .n
        bcc     LE83C                           ; E838 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; E83A A9 6D                    .m
LE83C:
		; save it and update status bar
        sta     PLAYER_GOLDS                             ; E83C 85 5A                    .Z
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; E83E 20 F8 CA                  ..
        rts                                     ; E841 60                       `

; ----------------------------------------------------------------------------
; input a = how much to take
; return - carry set if succesful, else clear if we don't have that much
CHECK_TAKE_PLAYER_GOLDS:
        ; branch if PLAYER_GOLDS < a
		sta     SCRATCH_08                             ; E842 85 08                    ..
        lda     PLAYER_GOLDS                             ; E844 A5 5A                    .Z
        sec                                     ; E846 38                       8
        sbc     SCRATCH_08                             ; E847 E5 08                    ..
        bcc     LE851                           ; E849 90 06                    ..
        
		; we have enough; save new amt and update status bar
		sta     PLAYER_GOLDS                             ; E84B 85 5A                    .Z
        jsr     EVENT_PLAYER_GOLDS_CHANGE                           ; E84D 20 F8 CA                  ..
        sec                                     ; E850 38                       8
LE851:
        rts                                     ; E851 60                       `

; ----------------------------------------------------------------------------
GIVE_PLAYER_KEY:
        inc     PLAYER_KEYS                             ; E852 E6 5B                    .[
        jsr     EVENT_PLAYER_KEY_CHANGE                           ; E854 20 E2 CA                  ..
        clc                                     ; E857 18                       .
        rts                                     ; E858 60                       `

; ----------------------------------------------------------------------------
; doesn't seem to add anything that just EVENT_PLAYER_KEY_CHANGE doesn't do; only called
; from ACTION_CHEST_KEY
CAP_PLAYER_CHEST_KEY:
        clc                                     ; E859 18                       .
        adc     PLAYER_KEYS                             ; E85A 65 5B                    e[
        bcc     LE863                           ; E85C 90 05                    ..
        
		; should never happen - keys would never get high enough to overflow...
		lda     #MAX_PLAYER_STAT                            ; E85E A9 6D                    .m
        jmp     LE869                           ; E860 4C 69 E8                 Li.

; ----------------------------------------------------------------------------
LE863:
        cmp     #$6E                            ; E863 C9 6E                    .n
        bcc     LE869                           ; E865 90 02                    ..
        lda     #MAX_PLAYER_STAT                            ; E867 A9 6D                    .m
LE869:
        sta     PLAYER_KEYS                             ; E869 85 5B                    .[
        jsr     EVENT_PLAYER_KEY_CHANGE                           ; E86B 20 E2 CA                  ..
        rts                                     ; E86E 60                       `

; ----------------------------------------------------------------------------
; uses up a key if there's one available
; return - set carry if we don't have keys; else use one and clear carry
USE_NORMAL_KEY:
        lda     PLAYER_KEYS                             ; E86F A5 5B                    .[
        beq     LE87A                           ; E871 F0 07                    ..
        dec     PLAYER_KEYS                             ; E873 C6 5B                    .[
        jsr     EVENT_PLAYER_KEY_CHANGE                           ; E875 20 E2 CA                  ..
        clc                                     ; E878 18                       .
        rts                                     ; E879 60                       `

; ----------------------------------------------------------------------------
LE87A:
        sec                                     ; E87A 38                       8
        rts                                     ; E87B 60                       `

; ----------------------------------------------------------------------------
; branch to handle updates on overworld (rts), normal level, boss level
; dragon fight handled separately
UPDATE_LEVEL_OBJECTS:
		; branch if not in overworld
        lda     MAP_Y                             ; E87C A5 48                    .H
        cmp     #MAP_Y_OVERWORLD                            ; E87E C9 10                    ..
        bne     LE883                           ; E880 D0 01                    ..
        
		; nothing to update in overworld
		rts                                     ; E882 60                       `

; ----------------------------------------------------------------------------
LE883:
		; branch if not on a boss level
        lda     CHR_BANK_ENEMY_SPRITES                             ; E883 A5 2D                    .-
        cmp     #SPRITE_PT_TARATUNES                            ; E885 C9 30                    .0
        bcc     UPDATE_NORMAL_LEVEL_OBJECTS                           ; E887 90 03                    ..
        
		; boss level!
		jmp     UPDATE_BOSS_LEVEL_OBJECTS                           ; E889 4C 01 E9                 L..

; ----------------------------------------------------------------------------
; CTR_E9 runs 2 down to 0
; it is modified to generate CUR_OBJ_SLOT_NUM and STOP_SLOT_NUM.
; CUR_OBJ_SLOT_NUM is ultimately the # of the object slot we're going to process, and *16 is the offset to that slot
; STOP_SLOT_NUM is here set to CUR_OBJ_SLOT_NUM+3 to as yet unknown nefarious purpose... 
; okay, I figured it out; STOP_SLOT_NUM is the ending slot, exclusive
UPDATE_NORMAL_LEVEL_OBJECTS:
        ; $E9*2+$E9 --> CUR_OBJ_SLOT_NUM
		; CUR_OBJ_SLOT_NUM + 3 --> STOP_SLOT_NUM
		lda     CTR_E9                             ; E88C A5 E9                    ..
        asl     a                               ; E88E 0A                       .
        clc                                     ; E88F 18                       .
        adc     CTR_E9                             ; E890 65 E9                    e.
        sta     CUR_OBJ_SLOT_NUM                             ; E892 85 E3                    ..
        clc                                     ; E894 18                       .
        adc     #$03                            ; E895 69 03                    i.
        sta     STOP_SLOT_NUM                             ; E897 85 E4                    ..
        
		; CUR_OBJ_SLOT_NUM * 16 --> OBJ_PTR_LO
		; CUR_OBJ_SLOT_NUM * 16 = offset to the object slot we'll target
		lda     CUR_OBJ_SLOT_NUM                             ; E899 A5 E3                    ..
        asl     a                               ; E89B 0A                       .
        asl     a                               ; E89C 0A                       .
        asl     a                               ; E89D 0A                       .
        asl     a                               ; E89E 0A                       .
        sta     CUR_OBJ_PTR_LO                             ; E89F 85 E5                    ..
        clc                                     ; E8A1 18                       .
        adc     #$20                            ; E8A2 69 20                    i 
        sta     MAP_META_PTR_LO                             ; E8A4 85 E7                    ..
        lda     #$04                            ; E8A6 A9 04                    ..
        sta     CUR_OBJ_PTR_HI                             ; E8A8 85 E6                    ..
        lda     MAP_DATA_HI                             ; E8AA A5 78                    .x
        sta     MAP_META_PTR_HI                             ; E8AC 85 E8                    ..
LE8AE:
        jsr     LOAD_CUR_OBJ                           ; E8AE 20 8F E9                  ..
        
		; branch if empty object (track re-spawn)
		lda     CUR_OBJ_GEN_TYPE                             ; E8B1 A5 EE                    ..
        beq     LE8CB                           ; E8B3 F0 16                    ..
        
		; branch if dead (0x80-FF)
		bmi     LE8D7                           ; E8B5 30 20                    0 
        
		; branch if enemy (x01)
		cmp     #OBJ_GEN_TYPE_ENEMY                            ; E8B7 C9 01                    ..
        beq     LE8C5                           ; E8B9 F0 0A                    ..
        
		; branch if >= x18
		; this will be an enemy spawner - not a projectile b/c they don't appear in these 
		; object slots
		cmp     #OBJ_GEN_TYPE_PROJECTILE                            ; E8BB C9 18                    ..
        bcs     LE8D1                           ; E8BD B0 12                    ..
        
		; otherwise, an item (2-x17)
		jsr     UPDATE_OBJECT_ITEM                           ; E8BF 20 BF EA                  ..
        jmp     CUR_OBJ_SAVE_AND_NEXT                           ; E8C2 4C DA E8                 L..

; ----------------------------------------------------------------------------
LE8C5:
        jsr     UPDATE_OBJECT_NORMAL_ENEMY                           ; E8C5 20 94 EA                  ..
        jmp     CUR_OBJ_SAVE_AND_NEXT                           ; E8C8 4C DA E8                 L..

; ----------------------------------------------------------------------------
LE8CB:
        jsr     UPDATE_OBJECT_EMPTY                           ; E8CB 20 A5 E9                  ..
        jmp     CUR_OBJ_SAVE_AND_NEXT                           ; E8CE 4C DA E8                 L..

; ----------------------------------------------------------------------------
LE8D1:
        jsr     UPDATE_OBJECT_ENEMY_SPAWNER                           ; E8D1 20 2E EA                  ..
        jmp     CUR_OBJ_SAVE_AND_NEXT                           ; E8D4 4C DA E8                 L..

; ----------------------------------------------------------------------------
LE8D7:
        jsr     UPDATE_DYING_ENEMY                           ; E8D7 20 1C EF                  ..
CUR_OBJ_SAVE_AND_NEXT:
        jsr     SAVE_CUR_OBJ                           ; E8DA 20 9A E9                  ..
        
		; advance to the next slot
		inc     CUR_OBJ_SLOT_NUM                             ; E8DD E6 E3                    ..
        lda     CUR_OBJ_PTR_LO                             ; E8DF A5 E5                    ..
        clc                                     ; E8E1 18                       .
        adc     #$10                            ; E8E2 69 10                    i.
        sta     CUR_OBJ_PTR_LO                             ; E8E4 85 E5                    ..
        lda     MAP_META_PTR_LO                             ; E8E6 A5 E7                    ..
        clc                                     ; E8E8 18                       .
        adc     #$10                            ; E8E9 69 10                    i.
        sta     MAP_META_PTR_LO                             ; E8EB 85 E7                    ..
        
		; branch if CUR_OBJ_SLOT_NUM<STOP_SLOT_NUM (it starts out 3 less)
		lda     CUR_OBJ_SLOT_NUM                             ; E8ED A5 E3                    ..
        cmp     STOP_SLOT_NUM                             ; E8EF C5 E4                    ..
        bcc     LE8AE                           ; E8F1 90 BB                    ..
        
		; CUR_OBJ_SLOT_NUM >= STOP_SLOT_NUM
		; increment CTR_E9; clear it if it's >= 3 (keep it 0-2)
		lda     CTR_E9                             ; E8F3 A5 E9                    ..
        clc                                     ; E8F5 18                       .
        adc     #$01                            ; E8F6 69 01                    i.
        cmp     #$03                            ; E8F8 C9 03                    ..
        bcc     LE8FE                           ; E8FA 90 02                    ..
        lda     #$00                            ; E8FC A9 00                    ..
LE8FE:
        sta     CTR_E9                             ; E8FE 85 E9                    ..
        rts                                     ; E900 60                       `

; ----------------------------------------------------------------------------
; we alternate frames, updating boss and its projectiles
UPDATE_BOSS_LEVEL_OBJECTS:
        ; branch if CTR_E9 is even
		lda     CTR_E9                             ; E901 A5 E9                    ..
        and     #$01                            ; E903 29 01                    ).
        beq     UPDATE_BOSS                           ; E905 F0 03                    ..
        jmp     UPDATE_BOSS_PROJECTILES                           ; E907 4C 45 E9                 LE.

; ----------------------------------------------------------------------------
; update a crown boss's state
UPDATE_BOSS:
		; point to $0400, start of boss data
        lda     #$00                            ; E90A A9 00                    ..
        sta     CUR_OBJ_PTR_LO                             ; E90C 85 E5                    ..
        lda     #$04                            ; E90E A9 04                    ..
        sta     CUR_OBJ_PTR_HI                             ; E910 85 E6                    ..
        
		; point to first slot and enemy definition
		lda     #$00                            ; E912 A9 00                    ..
        sta     CUR_OBJ_SLOT_NUM                             ; E914 85 E3                    ..
        lda     #$20                            ; E916 A9 20                    . 
        sta     MAP_META_PTR_LO                             ; E918 85 E7                    ..
        lda     MAP_DATA_HI                             ; E91A A5 78                    .x
        sta     MAP_META_PTR_HI                             ; E91C 85 E8                    ..
        
		; load slot 0 as the working object
		jsr     LOAD_CUR_OBJ                           ; E91E 20 8F E9                  ..
        
		; branch if slot empty - need to initialize the boss
		lda     CUR_OBJ_GEN_TYPE                             ; E921 A5 EE                    ..
        beq     LE939                           ; E923 F0 14                    ..
        
		; animate boss if boss not dead
		bpl     BOSS_TAKE_ACTION                           ; E925 10 0C                    ..
        
		; CUR_OBJ_GEN_TYPE is negative; boss has been killed!
		jsr     KILL_BOSS_ENEMY                           ; E927 20 30 F4                  0.
        jsr     BOSS_CHECK_HORIZONTAL_FLIP                           ; E92A 20 3B F5                  ;.
        jsr     BOSS_ANIMATE_SPRITE                           ; E92D 20 52 F5                  R.
        jmp     SAVE_BOSS_STATE                           ; E930 4C 3C E9                 L<.

; ----------------------------------------------------------------------------
BOSS_TAKE_ACTION:
        jsr     AI_BOSS                           ; E933 20 B0 F3                  ..
        jmp     SAVE_BOSS_STATE                           ; E936 4C 3C E9                 L<.

; ----------------------------------------------------------------------------
LE939:
        jsr     INIT_BOSS                           ; E939 20 49 F3                  I.
SAVE_BOSS_STATE:
        jsr     SAVE_CUR_OBJ                           ; E93C 20 9A E9                  ..
        jsr     SAVE_CUR_OBJ_EXTRA_BOSS_PARTS                           ; E93F 20 5E F5                  ^.
        
		; flips CTR_E9 and exits
		jmp     LE988                           ; E942 4C 88 E9                 L..

; ----------------------------------------------------------------------------
; boss projectiles reside in object slots 4-8
UPDATE_BOSS_PROJECTILES:
        ; projectiles start at slot 4 ($0440 up)
		lda     #$04                            ; E945 A9 04                    ..
        sta     CUR_OBJ_SLOT_NUM                             ; E947 85 E3                    ..
        lda     #$40                            ; E949 A9 40                    .@
        sta     CUR_OBJ_PTR_LO                             ; E94B 85 E5                    ..
        lda     #$04                            ; E94D A9 04                    ..
        sta     CUR_OBJ_PTR_HI                             ; E94F 85 E6                    ..
        
		; point to enemy definition
		lda     #$60                            ; E951 A9 60                    .`
        sta     MAP_META_PTR_LO                             ; E953 85 E7                    ..
        lda     MAP_DATA_HI                             ; E955 A5 78                    .x
        sta     MAP_META_PTR_HI                             ; E957 85 E8                    ..
LE959:
		; if slot is empty or dead, branch and create a new projectile
        jsr     LOAD_CUR_OBJ                           ; E959 20 8F E9                  ..
        lda     CUR_OBJ_GEN_TYPE                             ; E95C A5 EE                    ..
        beq     LE968                           ; E95E F0 08                    ..
        bmi     LE968                           ; E960 30 06                    0.
        
		; boss projectile already in this slot; update it as if it was a normal enemy
		jsr     UPDATE_OBJECT_NORMAL_ENEMY                           ; E962 20 94 EA                  ..
        jmp     LE96F                           ; E965 4C 6F E9                 Lo.

; ----------------------------------------------------------------------------
LE968:
		; clear it (if not already clear)
        lda     #OBJ_GEN_TYPE_BLANK                            ; E968 A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; E96A 85 EE                    ..
        jsr     SPAWN_BOSS_PROJECTILE                           ; E96C 20 4F EA                  O.
LE96F:
		; save the projectile to the object arry, advance to the next slot
        jsr     SAVE_CUR_OBJ                           ; E96F 20 9A E9                  ..
        inc     CUR_OBJ_SLOT_NUM                             ; E972 E6 E3                    ..
        lda     CUR_OBJ_PTR_LO                             ; E974 A5 E5                    ..
        clc                                     ; E976 18                       .
        adc     #$10                            ; E977 69 10                    i.
        sta     CUR_OBJ_PTR_LO                             ; E979 85 E5                    ..
        lda     MAP_META_PTR_LO                             ; E97B A5 E7                    ..
        clc                                     ; E97D 18                       .
        adc     #$10                            ; E97E 69 10                    i.
        sta     MAP_META_PTR_LO                             ; E980 85 E7                    ..
        
		; branch if CUR_OBJ_SLOT_NUM < OBJ_SLOT_TEMP_OBJECT
		; loop for slots 4-8, so 5 projectiles
		lda     CUR_OBJ_SLOT_NUM                             ; E982 A5 E3                    ..
        cmp     #OBJ_SLOT_TEMP_OBJECT                            ; E984 C9 09                    ..
        bcc     LE959                           ; E986 90 D1                    ..
LE988:
		; flip CTR_E9 so we alternate frames updating boss and projectiles
        lda     CTR_E9                             ; E988 A5 E9                    ..
        eor     #$01                            ; E98A 49 01                    I.
        sta     CTR_E9                             ; E98C 85 E9                    ..
        rts                                     ; E98E 60                       `

; ----------------------------------------------------------------------------
; copies 16 bytes from the object arrays to the current or working object array at CUR_OBJ_DATA
LOAD_CUR_OBJ:
        ldy     #$0F                            ; E98F A0 0F                    ..
LE991:
        lda     (CUR_OBJ_PTR_LO),y                         ; E991 B1 E5                    ..
        sta     CUR_OBJ_DATA,y                           ; E993 99 ED 00                 ...
        dey                                     ; E996 88                       .
        bpl     LE991                           ; E997 10 F8                    ..
        rts                                     ; E999 60                       `

; ----------------------------------------------------------------------------
; copies 16 bytes from the current or working object array at CUR_OBJ_DATA to its original location
; this saves any changes 'permanently'
SAVE_CUR_OBJ:
        ldy     #$0F                            ; E99A A0 0F                    ..
LE99C:
        lda     CUR_OBJ_DATA,y                           ; E99C B9 ED 00                 ...
        sta     (CUR_OBJ_PTR_LO),y                         ; E99F 91 E5                    ..
        dey                                     ; E9A1 88                       .
        bpl     LE99C                           ; E9A2 10 F8                    ..
        rts                                     ; E9A4 60                       `

; ----------------------------------------------------------------------------
; wait for the counter to decrement, then re-spawn
UPDATE_OBJECT_EMPTY:
        ; dec counter and branch if it's >= x3C
		dec     CUR_OBJ_MISC_CTR                             ; E9A5 C6 F3                    ..
        ldx     CUR_OBJ_MISC_CTR                             ; E9A7 A6 F3                    ..
        cpx     #$3C                            ; E9A9 E0 3C                    .<
        bcs     LE9E6                           ; E9AB B0 39                    .9
        
		; load enemy slot's initial x hi
		ldy     #ENEMY_X1                            ; E9AD A0 02                    ..
        lda     (MAP_META_PTR_LO),y                         ; E9AF B1 E7                    ..
        
		; advance to initial y
		iny                                     ; E9B1 C8                       .
        ora     (MAP_META_PTR_LO),y                         ; E9B2 11 E7                    ..
        
		; branch if coords supplied in map def
		bne     LE9CB                           ; E9B4 D0 15                    ..
        
		; else choose random values - cool! used by the random zoomers
		; y=0-b0 (multiple of x10)
		lda     #$0C                            ; E9B6 A9 0C                    ..
        jsr     UPDATE_RNG                           ; E9B8 20 64 CC                  d.
        asl     a                               ; E9BB 0A                       .
        asl     a                               ; E9BC 0A                       .
        asl     a                               ; E9BD 0A                       .
        asl     a                               ; E9BE 0A                       .
        sta     TEMP_NEXT_Y                             ; E9BF 85 0A                    ..
        
		; x-hi 0-3f
		lda     #$40                            ; E9C1 A9 40                    .@
        jsr     UPDATE_RNG                           ; E9C3 20 64 CC                  d.
        sta     TEMP_NEXT_X_HI                             ; E9C6 85 0F                    ..
        jmp     LE9D6                           ; E9C8 4C D6 E9                 L..

; ----------------------------------------------------------------------------
LE9CB:
		; load starting y from definition
        ldy     #ENEMY_Y1                            ; E9CB A0 03                    ..
        lda     (MAP_META_PTR_LO),y                         ; E9CD B1 E7                    ..
        sta     TEMP_NEXT_Y                             ; E9CF 85 0A                    ..
        
		; advance to x
		dey                                     ; E9D1 88                       .
        lda     (MAP_META_PTR_LO),y                         ; E9D2 B1 E7                    ..
        sta     TEMP_NEXT_X_HI                             ; E9D4 85 0F                    ..
LE9D6:
        lda     #$00                            ; E9D6 A9 00                    ..
        sta     TEMP_NEXT_X_LO                           ; E9D8 85 0E                    ..
        sta     SCRATCH_0B                             ; E9DA 85 0B                    ..
        
		; branch (rts) if colliding with player
		jsr     CHECK_OBJ_COLLIDE_WITH_PLAYER                           ; E9DC 20 7C CE                  |.
        bcs     LE9E6                           ; E9DF B0 05                    ..
        
		; otherwise, branch (move) if not going to hit a solid tile
		jsr     CHECK_TEMP_NEXT_POS_HIT_SOLID_TILE                           ; E9E1 20 3A F2                  :.
        bcc     LE9E7                           ; E9E4 90 01                    ..
LE9E6:
        rts                                     ; E9E6 60                       `

; ----------------------------------------------------------------------------
LE9E7:
        ; accept move
		lda     TEMP_NEXT_X_LO                           ; E9E7 A5 0E                    ..
        sta     CUR_OBJ_NEXT_X                             ; E9E9 85 F9                    ..
        lda     TEMP_NEXT_X_HI                             ; E9EB A5 0F                    ..
        sta     CUR_OBJ_NEXT_X_HI                             ; E9ED 85 FA                    ..
        lda     TEMP_NEXT_Y                             ; E9EF A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; E9F1 85 FB                    ..
        
		; clear values
		lda     #$00                            ; E9F3 A9 00                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; E9F5 85 F1                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; E9F7 85 F0                    ..
        sta     CUR_OBJ_DIR                             ; E9F9 85 F4                    ..
        sta     CUR_OBJ_PROJECTILE_WIGGLE                             ; E9FB 85 FC                    ..
        
		; set hp
		ldy     #ENEMY_HP                            ; E9FD A0 04                    ..
        lda     (MAP_META_PTR_LO),y                         ; E9FF B1 E7                    ..
        sta     CUR_OBJ_HP                             ; EA01 85 F2                    ..
        
		; advance to damage
		iny                                     ; EA03 C8                       .
        lda     (MAP_META_PTR_LO),y                         ; EA04 B1 E7                    ..
        sta     CUR_OBJ_DAMAGE                             ; EA06 85 F8                    ..
        
		; loop to set a bit corresponding to the player ID
		ldx     PLAYER_ID                             ; EA08 A6 40                    .@
        lda     #$00                            ; EA0A A9 00                    ..
        sec                                     ; EA0C 38                       8
LEA0D:
        rol     a                               ; EA0D 2A                       *
        dex                                     ; EA0E CA                       .
        bpl     LEA0D                           ; EA0F 10 FC                    ..
        
		; branch (standard damage) if player matches music for the map
		; this logic makes enemies do more damage to family members exploring outside their area!
		and     MAP_PREFERRED_PLAYERS                             ; EA11 25 41                    %A
        bne     LEA1D                           ; EA13 D0 08                    ..
        
		; player_id bit isn't set in match MAP_PREFERRED_PLAYERS; double damage and 
		; set to 0xFF if carry occurred
		asl     CUR_OBJ_DAMAGE          		; EA15 06 F8                    ..
        bcc     LEA1D                           ; EA17 90 04                    ..
        
		; otherwise damage --> xFF 
		lda     #$FF                            ; EA19 A9 FF                    ..
        sta     CUR_OBJ_DAMAGE                             ; EA1B 85 F8                    ..
LEA1D:
		; setup the spawner
        lda     #OBJ_GEN_TYPE_ENEMY_SPAWNING                            ; EA1D A9 7F                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; EA1F 85 EE                    ..
        lda     #$F9                            ; EA21 A9 F9                    ..
        sta     CUR_OBJ_SPRITE                             ; EA23 85 ED                    ..
        lda     #$01                            ; EA25 A9 01                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; EA27 85 EF                    ..
        lda     CUR_OBJ_MISC_CTR                             ; EA29 A5 F3                    ..
        jmp     LEA30                           ; EA2B 4C 30 EA                 L0.

; ----------------------------------------------------------------------------
UPDATE_OBJECT_ENEMY_SPAWNER:
        dec     CUR_OBJ_MISC_CTR                             ; EA2E C6 F3                    ..
LEA30:
        ; branch if counter not yet done
		bne     LEA42                           ; EA30 D0 10                    ..
        
		; when the counter = 0, we're an enemy again!
		; get our initial definitions from the map info
		lda     #$01                            ; EA32 A9 01                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; EA34 85 EE                    ..
        ldy     #ENEMY_ID                            ; EA36 A0 00                    ..
        lda     (MAP_META_PTR_LO),y                         ; EA38 B1 E7                    ..
        sta     CUR_OBJ_SPRITE                             ; EA3A 85 ED                    ..
        
		; advance to the flags
		iny                                     ; EA3C C8                       .
        lda     (MAP_META_PTR_LO),y                         ; EA3D B1 E7                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; EA3F 85 EF                    ..
        rts                                     ; EA41 60                       `

; ----------------------------------------------------------------------------
LEA42:
		; spawner animation
		; while the counter's running down, use sprite flags to toggle horizontal flip every 4 frames
        lda     CUR_OBJ_MISC_CTR                             ; EA42 A5 F3                    ..
        and     #$03                            ; EA44 29 03                    ).
        bne     LEA4E                           ; EA46 D0 06                    ..
        lda     CUR_OBJ_SPRITE_FLAGS                             ; EA48 A5 EF                    ..
        eor     #$40                            ; EA4A 49 40                    I@
        sta     CUR_OBJ_SPRITE_FLAGS                             ; EA4C 85 EF                    ..
LEA4E:
        rts                                     ; EA4E 60                       `

; ----------------------------------------------------------------------------
; common projectile spawn for all crown bosses
SPAWN_BOSS_PROJECTILE:
        ; get RNG and rts unless 0 (1 in 30)
		lda     #$1E                            ; EA4F A9 1E                    ..
        jsr     UPDATE_RNG                           ; EA51 20 64 CC                  d.
        tax                                     ; EA54 AA                       .
        bne     LEA93                           ; EA55 D0 3C                    .<
        
		; branch (y=3) if boss not horizontally flipped 
		ldx     #$03                            ; EA57 A2 03                    ..
        ldy     #$03                            ; EA59 A0 03                    ..
        lda     OBJ_SPRITE_FLAGS                           ; EA5B AD 02 04                 ...
        and     #$40                            ; EA5E 29 40                    )@
        beq     LEA64                           ; EA60 F0 02                    ..
        
		; boss is horizontally fliped; y=x13
		ldy     #$13                            ; EA62 A0 13                    ..
LEA64:
        ; set projectile x lo, x hi, y based on either boss part 0 or 1
		; so, the top-row part that is pointing in the direction of motion
		lda     OBJ_X_LO,y                         ; EA64 B9 0C 04                 ...
        sta     CUR_OBJ_NEXT_X,x                           ; EA67 95 F9                    ..
        dey                                     ; EA69 88                       .
        dex                                     ; EA6A CA                       .
        bpl     LEA64                           ; EA6B 10 F7                    ..
        
		; no movement to start
		lda     #$00                            ; EA6D A9 00                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; EA6F 85 F1                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; EA71 85 F0                    ..
        sta     CUR_OBJ_DIR     		; EA73 85 F4                    ..
        
		; load starting hp
		ldy     #ENEMY_HP                            ; EA75 A0 04                    ..
        lda     (MAP_META_PTR_LO),y                         ; EA77 B1 E7                    ..
        sta     CUR_OBJ_HP                             ; EA79 85 F2                    ..
        
		; now the attack damage
		iny                                     ; EA7B C8                       .
        lda     (MAP_META_PTR_LO),y                         ; EA7C B1 E7                    ..
        sta     CUR_OBJ_DAMAGE                             ; EA7E 85 F8                    ..
        
		; projectiles are enemies and use a common sprite
		lda     #$01                            ; EA80 A9 01                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; EA82 85 EE                    ..
        lda     #$81                            ; EA84 A9 81                    ..
        sta     CUR_OBJ_SPRITE                             ; EA86 85 ED                    ..
        
		; random palette
		lda     #$04                            ; EA88 A9 04                    ..
        jsr     UPDATE_RNG                           ; EA8A 20 64 CC                  d.
        sta     CUR_OBJ_SPRITE_FLAGS                             ; EA8D 85 EF                    ..
        
		; start upward?
		lda     #$80                            ; EA8F A9 80                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; EA91 85 F1                    ..
LEA93:
        rts                                     ; EA93 60                       `

; ----------------------------------------------------------------------------

; call the enemy ai routine specified in map meta data
UPDATE_OBJECT_NORMAL_ENEMY:
        ldy     #ENEMY_AI_TYPE                            ; EA94 A0 08                    ..
        lda     (MAP_META_PTR_LO),y                         ; EA96 B1 E7                    ..
        
		; branch if enemy behavior < 9, else set it to 0
		cmp     #$09                            ; EA98 C9 09                    ..
        bcc     LEA9E                           ; EA9A 90 02                    ..
        lda     #$00                            ; EA9C A9 00                    ..
LEA9E:
        asl     a                               ; EA9E 0A                       .
        tax                                     ; EA9F AA                       .
        lda     JUMP_TBL_ENEMY_AI,x                         ; EAA0 BD AD EA                 ...
        sta     JMP_DEST_0E_LO                           ; EAA3 85 0E                    ..
        lda     JUMP_TBL_ENEMY_AI+1,x                       ; EAA5 BD AE EA                 ...
        sta     JMP_DEST_0F_HI                             ; EAA8 85 0F                    ..
        jmp     (JMP_DEST_0E_LO)                         ; EAAA 6C 0E 00                 l..

; ----------------------------------------------------------------------------
JUMP_TBL_ENEMY_AI:
        ; gadedo, rare meta black, wizard - random dir every 30 frames
		.addr   ENEMY_AI_0                           ; EAAD FD EA                    ..
        
		; some bats, gers - random straight lines, ignore terrain, freeze on player
		.addr   ENEMY_AI_1                           ; EAAF 69 EB                    i.
        
		; meta black - back and forth on platform
		.addr   ENEMY_AI_2                           ; EAB1 90 EB                    ..
        
		; sphinx/chest mimic (moving), tiger, aryu, some wizards
		.addr   ENEMY_AI_3                           ; EAB3 D8 EB                    ..
        
		; some bat, prandy - toward player and freeze
		.addr   ENEMY_AI_4                           ; EAB5 76 EC                    v.
        
		; rock veest only
		.addr   ENEMY_AI_CEILING_CRAWLER                           ; EAB7 A8 EC                    ..
        
		; mimic/lion (still)
		.addr   ENEMY_AI_6                           ; EAB9 2A ED                    *.
        
		; random zoomers - some gers, dwarf, gadedo
		.addr   ENEMY_AI_ZOOMER                           ; EABB 6F ED                    o.
        
		; boss projectiles only
		.addr   ENEMY_AI_BOSS_PROJECTILE                           ; EABD 9F ED                    ..
; ----------------------------------------------------------------------------
; timer for object to flicker and disappear
; gravity and hitting the ground
UPDATE_OBJECT_ITEM:
        ; branch if CUR_OBJ_FALL_SPEED <> 0
		lda     CUR_OBJ_FALL_SPEED                             ; EABF A5 F0                    ..
        bne     LEACF                           ; EAC1 D0 0C                    ..
        
		; CUR_OBJ_FALL_SPEED = 0; branch if CUR_OBJ_RISE_SPEED = 0
		lda     CUR_OBJ_RISE_SPEED                             ; EAC3 A5 F1                    ..
        beq     LEAD7                           ; EAC5 F0 10                    ..
        
		; CUR_OBJ_FALL_SPEED = 0; CUR_OBJ_RISE_SPEED <> 0	
		jsr     ENEMY_BIG_JUMP                           ; EAC7 20 DA EE                  ..
        bcs     LEAD7                           ; EACA B0 0B                    ..
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; EACC 20 04 EF                  ..
LEACF:
        jsr     OBJECT_CHECK_GRAVITY_FALLING                           ; EACF 20 BB EE                  ..
        bcs     LEAD7                           ; EAD2 B0 03                    ..
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; EAD4 20 04 EF                  ..
LEAD7:
        ; dec counter and branch if <> 0
		ldx     CUR_OBJ_MISC_CTR                             ; EAD7 A6 F3                    ..
        dex                                     ; EAD9 CA                       .
        bne     LEAE5                           ; EADA D0 09                    ..
        
		; counter is 0; clear the object and set a new timer for re-spawn
		lda     #$00                            ; EADC A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; EADE 85 EE                    ..
        lda     #$F0                            ; EAE0 A9 F0                    ..
        sta     CUR_OBJ_MISC_CTR                             ; EAE2 85 F3                    ..
        rts                                     ; EAE4 60                       `

; ----------------------------------------------------------------------------
LEAE5:
        ; decrement the counter; branch if it's >= x3C
		stx     CUR_OBJ_MISC_CTR                             ; EAE5 86 F3                    ..
        cpx     #$3C                            ; EAE7 E0 3C                    .<
        bcs     LEAF9                           ; EAE9 B0 0E                    ..
        
		; counter is < x3C - item is about to expire; make it flicker
		
		; branch (set offscreen) if item currently onscreen
		ldx     #OFFSCREEN_Y                            ; EAEB A2 EF                    ..
        lda     CUR_OBJ_NEXT_Y                             ; EAED A5 FB                    ..
        cmp     #OFFSCREEN_Y                            ; EAEF C9 EF                    ..
        bne     LEAF5                           ; EAF1 D0 02                    ..
		
		; item currently offscreen - use CUR_OBJ_Y_COPY to put it back at its original location
		ldx     CUR_OBJ_Y_COPY                             ; EAF3 A6 FC                    ..
LEAF5:
		stx     CUR_OBJ_NEXT_Y                             ; EAF5 86 FB                    ..
        
		; regardless of whether we're on/offscreen, we save the prior y position to toggle again
		; next frame
		sta     CUR_OBJ_Y_COPY                             ; EAF7 85 FC                    ..
LEAF9:
        jsr     CHECK_OBJECT_INTERACTIONS                           ; EAF9 20 79 F1                  y.
        rts                                     ; EAFC 60                       `

; ----------------------------------------------------------------------------
; enemy chooses a random direction every 32 frames
; no change based on what player is doing - pretty vanilla
; e.g. 3-legged crawlers on the first screen (id=x61)
ENEMY_AI_0:
        ; branch if ctr > x20
		lda     CUR_OBJ_MISC_CTR                             ; EAFD A5 F3                    ..
        cmp     #$20                            ; EAFF C9 20                    . 
        bcs     LEB0D                           ; EB01 B0 0A                    ..
        
		; otherwise, branch if moving up
		lda     CUR_OBJ_RISE_SPEED                             ; EB03 A5 F1                    ..
        bne     LEB2C                           ; EB05 D0 25                    .%
        
		; otherwise, branch if moving at all
		lda     CUR_OBJ_DX                             ; EB07 A5 F5                    ..
        ora     CUR_OBJ_DY                             ; EB09 05 F7                    ..
        bne     LEB2C                           ; EB0B D0 1F                    ..
LEB0D:
		; reset ctr
        lda     #$00                            ; EB0D A9 00                    ..
        sta     CUR_OBJ_MISC_CTR                             ; EB0F 85 F3                    ..
        
		; choose a random direction (1 of 3)
		jsr     SET_RANDOM_DIR_RIGHT_DOWN_LEFT                           ; EB11 20 A6 EE                  ..
        
		; random dx (1-6)
		lda     #$06                            ; EB14 A9 06                    ..
        jsr     UPDATE_RNG                           ; EB16 20 64 CC                  d.
        clc                                     ; EB19 18                       .
        adc     #$01                            ; EB1A 69 01                    i.
        sta     CUR_OBJ_HORIZ_DIR                             ; EB1C 85 F6                    ..
        
		; branch if rng value <> 0 (3 in 4)
		lda     #$04                            ; EB1E A9 04                    ..
        jsr     UPDATE_RNG                           ; EB20 20 64 CC                  d.
        tax                                     ; EB23 AA                       .
        bne     LEB2C                           ; EB24 D0 06                    ..
        
		; 1 in 4 - reverse direction
		lda     #$80                            ; EB26 A9 80                    ..
        ora     CUR_OBJ_DIR                             ; EB28 05 F4                    ..
        sta     CUR_OBJ_DIR                             ; EB2A 85 F4                    ..
LEB2C:
		; save our dx; as y it is an input to calc the move vector
        lda     CUR_OBJ_HORIZ_DIR                             ; EB2C A5 F6                    ..
        pha                                     ; EB2E 48                       H
        tay                                     ; EB2F A8                       .
        lda     CUR_OBJ_DIR                             ; EB30 A5 F4                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; EB32 20 70 CD                  p.
        
		; branch if now falling
		lda     CUR_OBJ_FALL_SPEED                             ; EB35 A5 F0                    ..
        bne     LEB55                           ; EB37 D0 1C                    ..
        
		; branch if now rising
		lda     CUR_OBJ_RISE_SPEED                             ; EB39 A5 F1                    ..
        bne     LEB41                           ; EB3B D0 04                    ..
        
		; branch if dir is positive (rightward)
		; else check rising gravity anyway
        lda     CUR_OBJ_DIR                             ; EB3D A5 F4                    ..
        bpl     LEB46                           ; EB3F 10 05                    ..
LEB41:
		; branch if unobstructed
		jsr     ENEMY_BIG_JUMP                           ; EB41 20 DA EE                  ..
        bcc     LEB5A                           ; EB44 90 14                    ..
LEB46:
		; kill the rise and branch if we're no longer obstructed
        lda     #$00                            ; EB46 A9 00                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; EB48 85 F1                    ..
        jsr     OBJECT_CHECK_Y_MOVEMENT                           ; EB4A 20 E1 F0                  ..
        bcc     LEB5A                           ; EB4D 90 0B                    ..
        
		; freeze and finish
		jsr     FREEZE_ENEMY                           ; EB4F 20 11 EF                  ..
        jmp     LEB5D                           ; EB52 4C 5D EB                 L].

; ----------------------------------------------------------------------------
LEB55:
		; check falling gravity and branch if obstructed
        jsr     OBJECT_CHECK_GRAVITY_FALLING                           ; EB55 20 BB EE                  ..
        bcs     LEB5D                           ; EB58 B0 03                    ..
LEB5A:
		; we passed the checks to actually move
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; EB5A 20 04 EF                  ..
LEB5D:
		; finish up
        jsr     CHECK_OBJECT_INTERACTIONS                           ; EB5D 20 79 F1                  y.
        jsr     ANIMATE_ENEMY                           ; EB60 20 1E F0                  ..
        
		; restore our original dx
		pla                                     ; EB63 68                       h
        sta     CUR_OBJ_HORIZ_DIR                             ; EB64 85 F6                    ..
        jmp     RTS_LEFF0                           ; EB66 4C F0 EF                 L..

; ----------------------------------------------------------------------------
; moves in random straight lines; freezes if it hits the player
; e.g. bats (id=x71)
ENEMY_AI_1:
        ; branch if currently moving
		lda     CUR_OBJ_DX                             ; EB69 A5 F5                    ..
        ora     CUR_OBJ_DY                             ; EB6B 05 F7                    ..
        bne     LEB72                           ; EB6D D0 03                    ..
        
		; otherwise, choose a random dir
		jsr     SET_RANDOM_DIR_ANY                           ; EB6F 20 9A EE                  ..
LEB72:
		; lookup speed and plot a move in our chosen direction
        ldy     #ENEMY_SPEED                            ; EB72 A0 09                    ..
        lda     (MAP_META_PTR_LO),y                         ; EB74 B1 E7                    ..
        tay                                     ; EB76 A8                       .
        lda     CUR_OBJ_DIR                             ; EB77 A5 F4                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; EB79 20 70 CD                  p.
        
		; branch (complete move) if unobstructed
		jsr     CHECK_ENEMY_MOVEMENT_HIT_OR_OOB                           ; EB7C 20 1B F1                  ..
        bcc     LEB87                           ; EB7F 90 06                    ..
        
		; else, freeze and finish
		jsr     FREEZE_ENEMY                           ; EB81 20 11 EF                  ..
        jmp     LEB8A                           ; EB84 4C 8A EB                 L..

; ----------------------------------------------------------------------------
LEB87:
		; accept move and animate
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; EB87 20 04 EF                  ..
LEB8A:
        jsr     ANIMATE_ENEMY                           ; EB8A 20 1E F0                  ..
        jmp     RTS_LEFF0                           ; EB8D 4C F0 EF                 L..

; ----------------------------------------------------------------------------
; runs back and forth on a platform without falling off
; e.g. octopi from start screen (id=x51)
ENEMY_AI_2:
		; branch if currently moving
		lda     CUR_OBJ_DX                             ; EB90 A5 F5                    ..
        ora     CUR_OBJ_DY                             ; EB92 05 F7                    ..
        bne     LEB99                           ; EB94 D0 03                    ..
        
		; not moving - pick a direction
		jsr     SWAP_DIR_RIGHT_LEFT                           ; EB96 20 8D EE                  ..
LEB99:
        ; branch if not falling
		lda     CUR_OBJ_FALL_SPEED                             ; EB99 A5 F0                    ..
        beq     LEBA5                           ; EB9B F0 08                    ..
        
		; branch if fall unobstructed
		jsr     OBJECT_CHECK_GRAVITY_FALLING                           ; EB9D 20 BB EE                  ..
        bcc     LEBC6                           ; EBA0 90 24                    .$
        
		; fall obstructed - cancel move, finish up
		jmp     LEBCF                           ; EBA2 4C CF EB                 L..

; ----------------------------------------------------------------------------
LEBA5:
		; not falling; use our native speed
        ldy     #ENEMY_SPEED                            ; EBA5 A0 09                    ..
        lda     (MAP_META_PTR_LO),y                         ; EBA7 B1 E7                    ..
        tay                                     ; EBA9 A8                       .
        lda     CUR_OBJ_DIR                             ; EBAA A5 F4                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; EBAC 20 70 CD                  p.
        
		; if obstructed in y, freeze and finish
		jsr     OBJECT_CHECK_Y_MOVEMENT                           ; EBAF 20 E1 F0                  ..
        bcs     AI_2_FREEZE_AND_FINISH                           ; EBB2 B0 18                    ..
        
		; branch (freeze enemy) if no hitting solid tile at feet
		; prevents from running off platforms!
		ldy     #$01                            ; EBB4 A0 01                    ..
        jsr     CHECK_Y_TILE_SOLID_REDUX                           ; EBB6 20 33 F2                  3.
        bcc     AI_2_FREEZE_AND_FINISH                           ; EBB9 90 11                    ..
        
		lda     TEMP_NEXT_X_LO                           ; EBBB A5 0E                    ..
        beq     LEBC6                           ; EBBD F0 07                    ..
        
		ldy     #$0D                            ; EBBF A0 0D                    ..
        jsr     CHECK_Y_TILE_SOLID_REDUX                           ; EBC1 20 33 F2                  3.
        bcc     AI_2_FREEZE_AND_FINISH                           ; EBC4 90 06                    ..
LEBC6:
		; solid tile hit - ok to move and finish up
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; EBC6 20 04 EF                  ..
        jmp     LEBCF                           ; EBC9 4C CF EB                 L..

; ----------------------------------------------------------------------------
AI_2_FREEZE_AND_FINISH:
        jsr     FREEZE_ENEMY                           ; EBCC 20 11 EF                  ..
LEBCF:
        jsr     CHECK_OBJECT_INTERACTIONS                           ; EBCF 20 79 F1                  y.
        jsr     ANIMATE_ENEMY                           ; EBD2 20 1E F0                  ..
        jmp     RTS_LEFF0                           ; EBD5 4C F0 EF                 L..

; ----------------------------------------------------------------------------
; AI_6 jumps here when touched by player
; it covers sphinx and/or chest and/or hidden enemies in Meyna crown room 
; that only move when touched; also tiger, aryu, some wizards
; 
ENEMY_AI_3:
        ; clear CUR_OBJ_DIR upper nibble - bit 7 can be set to trigger a big jump
		lda     CUR_OBJ_DIR                             ; EBD8 A5 F4                    ..
        and     #$0F                            ; EBDA 29 0F                    ).
        sta     CUR_OBJ_DIR                             ; EBDC 85 F4                    ..
        
		; branch if moving
		lda     CUR_OBJ_DX                             ; EBDE A5 F5                    ..
        ora     CUR_OBJ_DY                             ; EBE0 05 F7                    ..
        bne     LEC2E                           ; EBE2 D0 4A                    .J
        
		; not moving; branch if next x <> 0
		lda     CUR_OBJ_NEXT_X                             ; EBE4 A5 F9                    ..
        bne     LEC02                           ; EBE6 D0 1A                    ..
        
		; next x=0; see if we're aligned with a ladder
		; update tile ptr
		lda     CUR_OBJ_NEXT_X_HI                             ; EBE8 A5 FA                    ..
        sta     PLAYER_MAP_TILE_LO                           ; EBEA 85 0C                    ..
        lda     CUR_OBJ_NEXT_Y                             ; EBEC A5 FB                    ..
        sta     PLAYER_MAP_TILE_HI                             ; EBEE 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; EBF0 20 54 CA                  T.
        
		; branch if near a ladder
		ldy     #$00                            ; EBF3 A0 00                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; EBF5 B1 0C                    ..
        and     #$3F                            ; EBF7 29 3F                    )?
        beq     LEC34                           ; EBF9 F0 39                    .9
        iny                                     ; EBFB C8                       .
        lda     (PLAYER_MAP_TILE_PTR),y                       ; EBFC B1 0C                    ..
        and     #$3F                            ; EBFE 29 3F                    )?
        beq     LEC34                           ; EC00 F0 32                    .2
LEC02:
		; not moving; branch if CUR_OBJ_DIR = left or right 
        lda     CUR_OBJ_DIR                             ; EC02 A5 F4                    ..
        and     #$03                            ; EC04 29 03                    ).
        bne     LEC0C                           ; EC06 D0 04                    ..
        
		; otherwise, choose right
		lda     #$01                            ; EC08 A9 01                    ..
        sta     CUR_OBJ_DIR                             ; EC0A 85 F4                    ..
LEC0C:
		; clear misc ctr; orig value --> x and branch unless it was 1
        ldx     CUR_OBJ_MISC_CTR                             ; EC0C A6 F3                    ..
        lda     #$00                            ; EC0E A9 00                    ..
        sta     CUR_OBJ_MISC_CTR                             ; EC10 85 F3                    ..
        dex                                     ; EC12 CA                       .
        bne     LEC22                           ; EC13 D0 0D                    ..
        
		; misc ctr was 1 or x=0 above
		; branch CUR_OBJ_DIR neither left/right - player/enemy x hi equal
		lda     CUR_OBJ_DIR                             ; EC15 A5 F4                    ..
        and     #$03                            ; EC17 29 03                    ).
        beq     LEC34                           ; EC19 F0 19                    ..
        
		; flip left/right direction
		eor     #$03                            ; EC1B 49 03                    I.
        sta     CUR_OBJ_DIR                             ; EC1D 85 F4                    ..
        jmp     LEC3B                           ; EC1F 4C 3B EC                 L;.

; ----------------------------------------------------------------------------
LEC22:
		; sets CUR_OBJ_DIR based on player/enemy relationship
        jsr     ENEMY_RESPOND_TO_PLAYER_LOC                           ; EC22 20 19 EE                  ..
        
		; set bit 7 - possible big jump
		lda     #$80                            ; EC25 A9 80                    ..
        ora     CUR_OBJ_DIR                             ; EC27 05 F4                    ..
        sta     CUR_OBJ_DIR                             ; EC29 85 F4                    ..
        jmp     LEC3B                           ; EC2B 4C 3B EC                 L;.

; ----------------------------------------------------------------------------
LEC2E:
		; get here if we were moving up above
        ; branch if misc ctr < x10
		lda     CUR_OBJ_MISC_CTR                             ; EC2E A5 F3                    ..
        cmp     #$10                            ; EC30 C9 10                    ..
        bcc     LEC3B                           ; EC32 90 07                    ..

; we branch here from above if on a ladder
; reset the misc ctr and respond to player location
LEC34:
        lda     #$00                            ; EC34 A9 00                    ..
        sta     CUR_OBJ_MISC_CTR                             ; EC36 85 F3                    ..
        jsr     ENEMY_RESPOND_TO_PLAYER_LOC                           ; EC38 20 19 EE                  ..
LEC3B:
        ldy     #ENEMY_SPEED                            ; EC3B A0 09                    ..
        lda     (MAP_META_PTR_LO),y                         ; EC3D B1 E7                    ..
        tay                                     ; EC3F A8                       .
        
		; CUR_OBJ_DIR --> a (direction)
		; y = speed
		lda     CUR_OBJ_DIR                             ; EC40 A5 F4                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; EC42 20 70 CD                  p.
        
		; branch if CUR_OBJ_FALL_SPEED <> 0
		lda     CUR_OBJ_FALL_SPEED                             ; EC45 A5 F0                    ..
        bne     LEC65                           ; EC47 D0 1C                    ..
        
		; not falling; branch if rising
		lda     CUR_OBJ_RISE_SPEED                             ; EC49 A5 F1                    ..
        bne     LEC51                           ; EC4B D0 04                    ..
        
		; neither falling nor rising; branch if CUR_OBJ_DIR bit 7 clear
		lda     CUR_OBJ_DIR                             ; EC4D A5 F4                    ..
        bpl     LEC56                           ; EC4F 10 05                    ..
LEC51:
		; bit 7 set; branch if ok to move
        jsr     ENEMY_BIG_JUMP                           ; EC51 20 DA EE                  ..
        bcc     LEC6A                           ; EC54 90 14                    ..
LEC56:
        ; clear CUR_OBJ_RISE_SPEED and branch if we can move
		lda     #$00                            ; EC56 A9 00                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; EC58 85 F1                    ..  
		jsr     OBJECT_CHECK_Y_MOVEMENT                           ; EC5A 20 E1 F0                  ..
        bcc     LEC6A                           ; EC5D 90 0B                    ..
        
		; we can't move; freeze and finish
		jsr     FREEZE_ENEMY                           ; EC5F 20 11 EF                  ..
        jmp     LEC6D                           ; EC62 4C 6D EC                 Lm.

; ----------------------------------------------------------------------------
LEC65:
		; CUR_OBJ_FALL_SPEED <> 0; branch if not ok to move
        jsr     OBJECT_CHECK_GRAVITY_FALLING                           ; EC65 20 BB EE                  ..
        bcs     LEC6D                           ; EC68 B0 03                    ..
LEC6A:
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; EC6A 20 04 EF                  ..
LEC6D:
        jsr     CHECK_OBJECT_INTERACTIONS                           ; EC6D 20 79 F1                  y.
        jsr     ANIMATE_ENEMY                           ; EC70 20 1E F0                  ..
        jmp     RTS_LEFF0                           ; EC73 4C F0 EF                 L..

; ----------------------------------------------------------------------------
; fly toward player, ignore walls, and freeze - e.g. some bats, prandy
ENEMY_AI_4:
        ; branch if not moving
		lda     CUR_OBJ_DX                             ; EC76 A5 F5                    ..
        ora     CUR_OBJ_DY                             ; EC78 05 F7                    ..
        beq     LEC82                           ; EC7A F0 06                    ..
        
		; moving; branch if ctr < x20 - occasionally stop tracking player
		lda     CUR_OBJ_MISC_CTR                             ; EC7C A5 F3                    ..
        cmp     #$20                            ; EC7E C9 20                    . 
        bcc     LEC85                           ; EC80 90 03                    ..
LEC82:
        ; otherwise, set dir toward player
		jsr     AI_CALC_PLAYER_DIR                           ; EC82 20 53 EE                  S.
LEC85:
        ; get a movement vector and check it
		ldy     #ENEMY_SPEED                            ; EC85 A0 09                    ..
        lda     (MAP_META_PTR_LO),y                         ; EC87 B1 E7                    ..
        tay                                     ; EC89 A8                       .
        lda     CUR_OBJ_DIR                             ; EC8A A5 F4                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; EC8C 20 70 CD                  p.		
		jsr     CHECK_ENEMY_MOVEMENT_HIT_OR_OOB                           ; EC8F 20 1B F1                  ..
        bcc     LEC9F                           ; EC92 90 0B                    ..
        
		; in bounds, track the player; branch if did not hit player
		jsr     ENEMY_AI_TRACK_PLAYER                           ; EC94 20 DA F2                  ..
        bcc     LEC9F                           ; EC97 90 06                    ..
        
		; freeze on player
		jsr     FREEZE_ENEMY                           ; EC99 20 11 EF                  ..
        jmp     LECA2                           ; EC9C 4C A2 EC                 L..

; ----------------------------------------------------------------------------
LEC9F:
		; move/animate
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; EC9F 20 04 EF                  ..
LECA2:
        jsr     ANIMATE_ENEMY                           ; ECA2 20 1E F0                  ..
        jmp     RTS_LEFF0                           ; ECA5 4C F0 EF                 L..

; ----------------------------------------------------------------------------

; the rock veest, that crawls along the ceiling and dive bombs at the player
ENEMY_AI_CEILING_CRAWLER:
        ; branch if falling
		lda     CUR_OBJ_FALL_SPEED                             ; ECA8 A5 F0                    ..
        bne     LECFA                           ; ECAA D0 4E                    .N
        
		; branch if rising
		lda     CUR_OBJ_RISE_SPEED                             ; ECAC A5 F1                    ..
        bne     LED16                           ; ECAE D0 66                    .f
        
		; neither rising nor falling
		lda     CUR_OBJ_NEXT_X_HI                             ; ECB0 A5 FA                    ..
        sta     TEMP_NEXT_X_HI                             ; ECB2 85 0F                    ..
        lda     CUR_OBJ_NEXT_X                             ; ECB4 A5 F9                    ..
        sta     TEMP_NEXT_X_LO                           ; ECB6 85 0E                    ..
        lda     CUR_OBJ_NEXT_Y                             ; ECB8 A5 FB                    ..
        sta     TEMP_NEXT_Y                             ; ECBA 85 0A                    ..
        
		; branch if all tiles above are solid
		jsr     CHECK_ALL_SOLID_ABOVE                           ; ECBC 20 F0 ED                  ..
        bcs     LECC8                           ; ECBF B0 07                    ..
        
		; otherwise fall...
		inc     CUR_OBJ_FALL_SPEED                             ; ECC1 E6 F0                    ..
        inc     CUR_OBJ_FALL_SPEED                             ; ECC3 E6 F0                    ..
        jmp     LECFA                           ; ECC5 4C FA EC                 L..

; ----------------------------------------------------------------------------
LECC8:
        ; branch if currently moving
		lda     CUR_OBJ_DX                             ; ECC8 A5 F5                    ..
        ora     CUR_OBJ_DY                             ; ECCA 05 F7                    ..
        bne     LECD1                           ; ECCC D0 03                    ..
        
		; choose a direction
		jsr     SWAP_DIR_RIGHT_LEFT                           ; ECCE 20 8D EE                  ..
LECD1:
        ; branch (stop x movement) if lined up with player
		jsr     CHECK_OBJ_PLAYER_COLLIDE_X                           ; ECD1 20 90 CE                  ..
        bcs     LECED                           ; ECD4 B0 17                    ..
        
		; else do our movement vector
		ldy     #ENEMY_SPEED                            ; ECD6 A0 09                    ..
        lda     (MAP_META_PTR_LO),y                         ; ECD8 B1 E7                    ..
        tay                                     ; ECDA A8                       .
        lda     CUR_OBJ_DIR                             ; ECDB A5 F4                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; ECDD 20 70 CD                  p.
        
		; branch (freeze and finish) if y movement obstructed
		jsr     OBJECT_CHECK_Y_MOVEMENT                           ; ECE0 20 E1 F0                  ..
        bcs     LED21                           ; ECE3 B0 3C                    .<
        
		; branch (freeze and finish) if not all solid above
		jsr     CHECK_ALL_SOLID_ABOVE                           ; ECE5 20 F0 ED                  ..
        bcc     LED21                           ; ECE8 90 37                    .7
        
		; otherwise, jump to move and animate
		jmp     LED10                           ; ECEA 4C 10 ED                 L..

; ----------------------------------------------------------------------------
LECED:
		; we come here if we're lined up with the player in x
        ; clear dx, branch (freeze and finish) if hitting player
		lda     #$00                            ; ECED A9 00                    ..
        sta     CUR_OBJ_DX                             ; ECEF 85 F5                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; ECF1 85 F6                    ..
        jsr     CHECK_OBJECT_INTERACTIONS                           ; ECF3 20 79 F1                  y.
        lda     CUR_OBJ_FALL_SPEED                             ; ECF6 A5 F0                    ..
        bcs     LED21                           ; ECF8 B0 27                    .'
LECFA:
		; otherwise, start falling, move (twice) and finish if no interactions
        jsr     OBJECT_CHECK_GRAVITY_FALLING                           ; ECFA 20 BB EE                  ..
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; ECFD 20 04 EF                  ..
        lda     CUR_OBJ_FALL_SPEED                             ; ED00 A5 F0                    ..
        pha                                     ; ED02 48                       H
        jsr     CHECK_OBJECT_INTERACTIONS                           ; ED03 20 79 F1                  y.
        pla                                     ; ED06 68                       h
        bcc     LED10                           ; ED07 90 07                    ..
        
		; we dive bombed the player, bounce up fast, then finish
		; note: rise speed is 16-x, so 5=11 px/frame upward
		adc     #$05                            ; ED09 69 05                    i.
        sta     CUR_OBJ_RISE_SPEED                             ; ED0B 85 F1                    ..
        jmp     LED24                           ; ED0D 4C 24 ED                 L$.

; ----------------------------------------------------------------------------
LED10:
		; move and finish
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; ED10 20 04 EF                  ..
        jmp     LED24                           ; ED13 4C 24 ED                 L$.

; ----------------------------------------------------------------------------
LED16:
		; move upward - freeze if halted
        jsr     ENEMY_BIG_JUMP                           ; ED16 20 DA EE                  ..
        bcs     LED21                           ; ED19 B0 06                    ..
        
		; otherwise, move and finish
		jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; ED1B 20 04 EF                  ..
        jmp     LED24                           ; ED1E 4C 24 ED                 L$.

; ----------------------------------------------------------------------------
LED21:
        jsr     FREEZE_ENEMY                           ; ED21 20 11 EF                  ..
LED24:
        jsr     ANIMATE_ENEMY                           ; ED24 20 1E F0                  ..
        jmp     RTS_LEFF0                           ; ED27 4C F0 EF                 L..

; ----------------------------------------------------------------------------
; chest mimic/sphinx
ENEMY_AI_6:
        ; branch (check for nearby player) if we don't have a direction - we're inactive
		lda     CUR_OBJ_DIR                             ; ED2A A5 F4                    ..
        beq     LED31                           ; ED2C F0 03                    ..
        
		; if we have a direction, we're active and follow ai 3
		jmp     ENEMY_AI_3                           ; ED2E 4C D8 EB                 L..

; ----------------------------------------------------------------------------
LED31:
		; check if we're within 1 px of player in any direction, hit player set f4 if so
		; appears to be the 'come alive' code
		; delegates to ai 3 once alive
		; think this is why we get hit by sphinx/chest/etc if right next to it without actually overlapping
        lda     #BTN_RIGHT                            ; ED31 A9 01                    ..
        jsr     ENEMY_CHECK_HIT_SPEED_1                           ; ED33 20 5D ED                  ].
        bcs     LED58                           ; ED36 B0 20                    . 
        lda     #BTN_LEFT                            ; ED38 A9 02                    ..
        jsr     ENEMY_CHECK_HIT_SPEED_1                           ; ED3A 20 5D ED                  ].
        bcs     LED58                           ; ED3D B0 19                    ..
        lda     #BTN_DOWN                            ; ED3F A9 04                    ..
        jsr     ENEMY_CHECK_HIT_SPEED_1                           ; ED41 20 5D ED                  ].
        bcs     LED58                           ; ED44 B0 12                    ..
        lda     #BTN_UP                            ; ED46 A9 08                    ..
        jsr     ENEMY_CHECK_HIT_SPEED_1                           ; ED48 20 5D ED                  ].
        bcs     LED58                           ; ED4B B0 0B                    ..
        
		; save our full hp to f2 - we can't be killed while dormant!
		ldy     #ENEMY_HP                            ; ED4D A0 04                    ..
        lda     (MAP_META_PTR_LO),y                         ; ED4F B1 E7                    ..
        sta     CUR_OBJ_HP                             ; ED51 85 F2                    ..
        
		; cancel any wiggling
		lda     #$00                            ; ED53 A9 00                    ..
        sta     CUR_OBJ_PROJECTILE_WIGGLE                             ; ED55 85 FC                    ..
        rts                                     ; ED57 60                       `

; ----------------------------------------------------------------------------
LED58:
		; we hit something; dir=right
        lda     #BTN_RIGHT                            ; ED58 A9 01                    ..
        sta     CUR_OBJ_DIR                             ; ED5A 85 F4                    ..
        rts                                     ; ED5C 60                       `

; ----------------------------------------------------------------------------
; used by ai 6
ENEMY_CHECK_HIT_SPEED_1:
        ldy     #$01                            ; ED5D A0 01                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; ED5F 20 70 CD                  p.
        jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; ED62 20 F1 EF                  ..
        jsr     CHECK_OBJ_COLLIDE_WITH_PLAYER                           ; ED65 20 7C CE                  |.
        bcc     LED6E                           ; ED68 90 04                    ..
        jsr     ENEMY_OR_PROJECTILE_HIT_PLAYER                           ; ED6A 20 36 F1                  6.
        sec                                     ; ED6D 38                       8
LED6E:
        rts                                     ; ED6E 60                       `

; ----------------------------------------------------------------------------
; AI for the zoomer enemies that fly at high speed in a straight line and die
; if they hit the player
ENEMY_AI_ZOOMER:
        ; branch if moving
		lda     CUR_OBJ_DX                             ; ED6F A5 F5                    ..
        ora     CUR_OBJ_DY                             ; ED71 05 F7                    ..
        bne     LED78                           ; ED73 D0 03                    ..
        
		; otherwise, random dir
		jsr     SET_RANDOM_DIR_ANY                           ; ED75 20 9A EE                  ..
LED78:
		; calc the move vector
        ldy     #ENEMY_SPEED                            ; ED78 A0 09                    ..
        lda     (MAP_META_PTR_LO),y                         ; ED7A B1 E7                    ..
        tay                                     ; ED7C A8                       .
        lda     CUR_OBJ_DIR                             ; ED7D A5 F4                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; ED7F 20 70 CD                  p.
        
		; branch (move and finish) if not hitting player or oob
		jsr     CHECK_ENEMY_MOVEMENT_HIT_OR_OOB                           ; ED82 20 1B F1                  ..
        bcc     LED91                           ; ED85 90 0A                    ..
        
		; branch if CUR_OBJ_PLAYER_PROXIMITY_FLAG set - also set CUR_OBJ_GEN_TYPE and RTS
		; branch (die!) if we touched the player
		lda     CUR_OBJ_PLAYER_PROXIMITY_FLAG                             ; ED87 A5 EA                    ..
        bne     LED9A                           ; ED89 D0 0F                    ..
        
		; CUR_OBJ_PLAYER_PROXIMITY_FLAG clear - freeze and finish
		jsr     FREEZE_ENEMY                           ; ED8B 20 11 EF                  ..
        jmp     LED94                           ; ED8E 4C 94 ED                 L..

; ----------------------------------------------------------------------------
LED91:
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; ED91 20 04 EF                  ..
LED94:
        jsr     ANIMATE_ENEMY                           ; ED94 20 1E F0                  ..
        jmp     RTS_LEFF0                           ; ED97 4C F0 EF                 L..

; ----------------------------------------------------------------------------
; kills the enemy
LED9A:
        lda     #OBJ_GEN_TYPE_ENEMY_JUST_KILLED                            ; ED9A A9 80                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; ED9C 85 EE                    ..
        rts                                     ; ED9E 60                       `

; ----------------------------------------------------------------------------
; boss projectiles
ENEMY_AI_BOSS_PROJECTILE:
        ; dec rise speed and branch (erase) if it's 0
		dec     CUR_OBJ_RISE_SPEED                             ; ED9F C6 F1                    ..
        beq     LEDEB                           ; EDA1 F0 48                    .H
        
		; branch if a dir is set
		lda     CUR_OBJ_DIR                             ; EDA3 A5 F4                    ..
        bne     LEDAD                           ; EDA5 D0 06                    ..
        
		; target the player
		jsr     AI_CALC_PLAYER_DIR                           ; EDA7 20 53 EE                  S.
        jmp     LEDD0                           ; EDAA 4C D0 ED                 L..

; ----------------------------------------------------------------------------
LEDAD:
        ; branch if ctr < 8
		lda     CUR_OBJ_MISC_CTR                             ; EDAD A5 F3                    ..
        cmp     #$08                            ; EDAF C9 08                    ..
        bcc     LEDD0                           ; EDB1 90 1D                    ..
        
		; ? changes dir to move toward player, but only if player is in a cardinal direction,
		; i.e. UDLR, but not diagonal (so # of bits set in dir=1)
		lda     CUR_OBJ_DIR                             ; EDB3 A5 F4                    ..
        sta     SCRATCH_08                             ; EDB5 85 08                    ..
        jsr     AI_CALC_PLAYER_DIR                           ; EDB7 20 53 EE                  S.
        lda     CUR_OBJ_DIR                             ; EDBA A5 F4                    ..
        eor     SCRATCH_08                             ; EDBC 45 08                    E.
        ldy     #$00                            ; EDBE A0 00                    ..
        ldx     #$04                            ; EDC0 A2 04                    ..
LEDC2:
        ; loop to count bits set in dir --> y
		lsr     a                               ; EDC2 4A                       J
        bcc     LEDC6                           ; EDC3 90 01                    ..
        
		; otherwise inc y
		iny                                     ; EDC5 C8                       .
LEDC6:
        dex                                     ; EDC6 CA                       .
        bne     LEDC2                           ; EDC7 D0 F9                    ..
        
		; branch (keep new dir) if y was 1 = cardinal direction, not diagonal
		dey                                     ; EDC9 88                       .
        beq     LEDD0                           ; EDCA F0 04                    ..
        
		; otherwise, SCRATCH_08 is the dir (the original dir)
		lda     SCRATCH_08                             ; EDCC A5 08                    ..
        sta     CUR_OBJ_DIR                             ; EDCE 85 F4                    ..
LEDD0:
		; calc move vector
        ldy     #ENEMY_SPEED                            ; EDD0 A0 09                    ..
        lda     (MAP_META_PTR_LO),y                         ; EDD2 B1 E7                    ..
        tay                                     ; EDD4 A8                       .
        lda     CUR_OBJ_DIR                             ; EDD5 A5 F4                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; EDD7 20 70 CD                  p.
        
		; branch (move and finish) if not hitting player or oob
		jsr     CHECK_ENEMY_MOVEMENT_HIT_OR_OOB                           ; EDDA 20 1B F1                  ..
        bcc     LEDE2                           ; EDDD 90 03                    ..
        
		; else erase
		jmp     LEDEB                           ; EDDF 4C EB ED                 L..

; ----------------------------------------------------------------------------
LEDE2:
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; EDE2 20 04 EF                  ..
        jsr     ANIMATE_ENEMY                           ; EDE5 20 1E F0                  ..
        jmp     RTS_LEFF0                           ; EDE8 4C F0 EF                 L..

; ----------------------------------------------------------------------------
LEDEB:
		; CHECK_ENEMY_MOVEMENT_HIT_OR_OOB takes care of damaging the player; so we just erase ourselves here
        lda     #$00                            ; EDEB A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; EDED 85 EE                    ..
        rts                                     ; EDEF 60                       `

; ----------------------------------------------------------------------------
; sets carry if there are only solid tiles above
CHECK_ALL_SOLID_ABOVE:
        ; branch if not aligned to y block
		lda     TEMP_NEXT_Y                             ; EDF0 A5 0A                    ..
        and     #$0F                            ; EDF2 29 0F                    ).
        bne     LEE17                           ; EDF4 D0 21                    .!
        
		; check the tile above us
		lda     TEMP_NEXT_X_HI                             ; EDF6 A5 0F                    ..
        sta     PLAYER_MAP_TILE_LO                           ; EDF8 85 0C                    ..
        lda     TEMP_NEXT_Y                             ; EDFA A5 0A                    ..
        sec                                     ; EDFC 38                       8
        sbc     #$10                            ; EDFD E9 10                    ..
        sta     PLAYER_MAP_TILE_HI                             ; EDFF 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; EE01 20 54 CA                  T.
        
		; clear carry if we have a non-solid tile above us
		ldy     #$00                            ; EE04 A0 00                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; EE06 20 D3 F2                  ..
        bcc     LEE17                           ; EE09 90 0C                    ..
        lda     TEMP_NEXT_X_LO                           ; EE0B A5 0E                    ..
        beq     LEE16                           ; EE0D F0 07                    ..
        ldy     #$0C                            ; EE0F A0 0C                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; EE11 20 D3 F2                  ..
        bcc     LEE17                           ; EE14 90 01                    ..
LEE16:
        rts                                     ; EE16 60                       `

; ----------------------------------------------------------------------------
LEE17:
        clc                                     ; EE17 18                       .
        rts                                     ; EE18 60                       `

; ----------------------------------------------------------------------------
; used by boss ai and enemy ai 3
;
ENEMY_RESPOND_TO_PLAYER_LOC:
        ldx     #$00                            ; EE19 A2 00                    ..
        
		; branch if obj/player x hi equal
		lda     CUR_OBJ_NEXT_X_HI                             ; EE1B A5 FA                    ..
        sec                                     ; EE1D 38                       8
        sbc     PX_HI                             ; EE1E E5 44                    .D
        beq     LEE26                           ; EE20 F0 04                    ..
        
		; branch if player x hi greater
		inx                                     ; EE22 E8                       .
        bcc     LEE26                           ; EE23 90 01                    ..
        
		; otherwise increase x
		inx                                     ; EE25 E8                       .
LEE26:
        ; CUR_OBJ_DIR coded to obj/player x relationship:
		; 0 = equal x_hi
		; 1 = player to the right (BTN_RIGHT)
		; 2 = player to the left (BTN_LEFT)
		stx     CUR_OBJ_DIR                             ; EE26 86 F4                    ..
        
		; branch if player below obj
		lda     CUR_OBJ_NEXT_Y                             ; EE28 A5 FB                    ..
        sec                                     ; EE2A 38                       8
        sbc     PY                             ; EE2B E5 45                    .E
        bcc     LEE46                           ; EE2D 90 17                    ..
        
		; player is level or above us 
		; branch (rts) if obj speed = 0 in map config
		ldy     #ENEMY_SPEED                            ; EE2F A0 09                    ..
        lda     (MAP_META_PTR_LO),y                         ; EE31 B1 E7                    ..
        beq     LEE52                           ; EE33 F0 1D                    ..
        
		; we can move; branch (rts) if RNG value non-zero (2 in 3)
		lda     #$03                            ; EE35 A9 03                    ..
        jsr     UPDATE_RNG                           ; EE37 20 64 CC                  d.
        tax                                     ; EE3A AA                       .
        bne     LEE52                           ; EE3B D0 15                    ..
        
		; 1 in 3 chance to set CUR_OBJ_DIR bit 7 negative - for bosses this may trigger a big jump
		lda     #$80                            ; EE3D A9 80                    ..
        ora     CUR_OBJ_DIR                             ; EE3F 05 F4                    ..
        sta     CUR_OBJ_DIR                             ; EE41 85 F4                    ..
        jmp     LEE52                           ; EE43 4C 52 EE                 LR.

; ----------------------------------------------------------------------------
LEE46:
		; 1 in 3: CUR_OBJ_DIR --> BTN_DOWN
        lda     #$03                            ; EE46 A9 03                    ..
        jsr     UPDATE_RNG                           ; EE48 20 64 CC                  d.
        tax                                     ; EE4B AA                       .
        bne     LEE52                           ; EE4C D0 04                    ..
        lda     #BTN_DOWN                            ; EE4E A9 04                    ..
        sta     CUR_OBJ_DIR                             ; EE50 85 F4                    ..
LEE52:
        rts                                     ; EE52 60                       `

; ----------------------------------------------------------------------------
; calcs the direction toward the player
AI_CALC_PLAYER_DIR:
        lda     CUR_OBJ_NEXT_X_HI                             ; EE53 A5 FA                    ..
        sta     TEMP_NEXT_X_HI                             ; EE55 85 0F                    ..
        lda     CUR_OBJ_NEXT_X                             ; EE57 A5 F9                    ..
        sta     TEMP_NEXT_X_LO                           ; EE59 85 0E                    ..
        lda     CUR_OBJ_NEXT_Y                             ; EE5B A5 FB                    ..
        sta     TEMP_NEXT_Y                             ; EE5D 85 0A                    ..
        
		; branch if colliding with player in x
		jsr     CHECK_OBJ_PLAYER_COLLIDE_X                           ; EE5F 20 90 CE                  ..
        ldx     #$00                            ; EE62 A2 00                    ..
        bcs     LEE6F                           ; EE64 B0 09                    ..
        
		; inx; branch if player to right of us
		lda     CUR_OBJ_NEXT_X_HI                             ; EE66 A5 FA                    ..
        sec                                     ; EE68 38                       8
        sbc     PX_HI                             ; EE69 E5 44                    .D
        inx                                     ; EE6B E8                       .
        bcc     LEE6F                           ; EE6C 90 01                    ..
        inx                                     ; EE6E E8                       .
LEE6F:
        stx     CUR_OBJ_DIR                             ; EE6F 86 F4                    ..
        
		; branch if colliding with player in y
		jsr     CHECK_OBJ_PLAYER_COLLIDE_Y                           ; EE71 20 B6 CE                  ..
        ldx     #$00                            ; EE74 A2 00                    ..
        bcs     LEE83                           ; EE76 B0 0B                    ..
        
		; x=4 if we are above player, x=8 if below
		lda     CUR_OBJ_NEXT_Y                             ; EE78 A5 FB                    ..
        sec                                     ; EE7A 38                       8
        sbc     PY                             ; EE7B E5 45                    .E
        ldx     #$04                            ; EE7D A2 04                    ..
        bcc     LEE83                           ; EE7F 90 02                    ..
        ldx     #$08                            ; EE81 A2 08                    ..
LEE83:
        txa                                     ; EE83 8A                       .
        ora     CUR_OBJ_DIR                             ; EE84 05 F4                    ..
        sta     CUR_OBJ_DIR                             ; EE86 85 F4                    ..
        lda     #$00                            ; EE88 A9 00                    ..
        sta     CUR_OBJ_MISC_CTR                             ; EE8A 85 F3                    ..
        rts                                     ; EE8C 60                       `

; ----------------------------------------------------------------------------
; uses EOR logic to swap right/left - used for enemies that go back and forth
SWAP_DIR_RIGHT_LEFT:
        lda     CUR_OBJ_DIR                             ; EE8D A5 F4                    ..
        and     #$03                            ; EE8F 29 03                    ).
        bne     LEE95                           ; EE91 D0 02                    ..
        lda     #$01                            ; EE93 A9 01                    ..
LEE95:
        eor     #$03                            ; EE95 49 03                    I.
        sta     CUR_OBJ_DIR                             ; EE97 85 F4                    ..
        rts                                     ; EE99 60                       `

; ----------------------------------------------------------------------------
; choose a random direction from the table below
SET_RANDOM_DIR_ANY:
		; index is random 0-7
        lda     #$08                            ; EE9A A9 08                    ..
        jsr     UPDATE_RNG                           ; EE9C 20 64 CC                  d.
        tax                                     ; EE9F AA                       .
        lda     TBL_ALL_DIR,x                         ; EEA0 BD B3 EE                 ...
        sta     CUR_OBJ_DIR                             ; EEA3 85 F4                    ..
        rts                                     ; EEA5 60                       `

; ----------------------------------------------------------------------------
; chooses a random direction from the table, but restricted to right, down, or left
SET_RANDOM_DIR_RIGHT_DOWN_LEFT:
		; select 2*(0-2 rng)
        lda     #$03                            ; EEA6 A9 03                    ..
        jsr     UPDATE_RNG                           ; EEA8 20 64 CC                  d.
        asl     a                               ; EEAB 0A                       .
        tax                                     ; EEAC AA                       .
        lda     TBL_ALL_DIR,x                         ; EEAD BD B3 EE                 ...
        sta     CUR_OBJ_DIR                             ; EEB0 85 F4                    ..
        rts                                     ; EEB2 60                       `

; ----------------------------------------------------------------------------
TBL_ALL_DIR: ; $eeb3
		.byte $01 ; right
		.byte $05 ; right/down
		.byte $04 ; down
		.byte $06 ; left/down
		.byte $02 ; left
		.byte $0a ; left/up
		.byte $08 ; up
		.byte $09 ; right/up
        ;.byte   $01,$05,$04,$06,$02,$0A,$08,$09 ; EEB3 01 05 04 06 02 0A 08 09  ........
; ----------------------------------------------------------------------------
; check if vertical movement calculated based on CUR_OBJ_FALL_SPEED will hit something solid
; if initially hits solid, tries killing dx to resolve
; return - carry set if hitting solid
; used by UPDATE_OBJECT_ITEM and several AI_ routines
OBJECT_CHECK_GRAVITY_FALLING:
		; dy = CUR_OBJ_FALL_SPEED/2+2
        lda     CUR_OBJ_FALL_SPEED                             ; EEBB A5 F0                    ..
        lsr     a                               ; EEBD 4A                       J
        clc                                     ; EEBE 18                       .
        adc     #$02                            ; EEBF 69 02                    i.
        sta     CUR_OBJ_DY                             ; EEC1 85 F7                    ..
        
		; branch if we hit something solid, otherwise rts
		jsr     OBJECT_CHECK_Y_MOVEMENT                           ; EEC3 20 E1 F0                  ..
        bcs     LEEC9                           ; EEC6 B0 01                    ..
        rts                                     ; EEC8 60                       `

; ----------------------------------------------------------------------------
LEEC9:
		; clear dx and CUR_OBJ_HORIZ_DIR and try again; branch if still hitting solid, otherwise rts
        lda     #$00                            ; EEC9 A9 00                    ..
        sta     CUR_OBJ_DX                             ; EECB 85 F5                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; EECD 85 F6                    ..
        jsr     OBJECT_CHECK_Y_MOVEMENT                           ; EECF 20 E1 F0                  ..
        bcs     LEED5                           ; EED2 B0 01                    ..
        rts                                     ; EED4 60                       `

; ----------------------------------------------------------------------------
LEED5:
		; still hitting solid; kill dy
        lda     #$00                            ; EED5 A9 00                    ..
        sta     CUR_OBJ_DY                             ; EED7 85 F7                    ..
        rts                                     ; EED9 60                       `

; ----------------------------------------------------------------------------
; tries to take (or continue) a big jump
ENEMY_BIG_JUMP:
        ; branch if CUR_OBJ_RISE_SPEED <> 0; else reset x --> x0F
		ldx     CUR_OBJ_RISE_SPEED                             ; EEDA A6 F1                    ..
        bne     LEEE0                           ; EEDC D0 02                    ..
        
		; big jump!
		ldx     #$0F                            ; EEDE A2 0F                    ..
LEEE0:
        dex                                     ; EEE0 CA                       .
        stx     CUR_OBJ_RISE_SPEED                             ; EEE1 86 F1                    ..
        txa                                     ; EEE3 8A                       .
        
		; CUR_OBJ_DY = -CUR_OBJ_RISE_SPEED/2+1
		lsr     a                               ; EEE4 4A                       J
        eor     #$FF                            ; EEE5 49 FF                    I.
        clc                                     ; EEE7 18                       .
        adc     #$01                            ; EEE8 69 01                    i.
        sta     CUR_OBJ_DY                             ; EEEA 85 F7                    ..
        
		; branch if obstructed; else rts
		jsr     OBJECT_CHECK_Y_MOVEMENT                           ; EEEC 20 E1 F0                  ..
        bcs     LEEF2                           ; EEEF B0 01                    ..
        rts                                     ; EEF1 60                       `

; ----------------------------------------------------------------------------
LEEF2:
        ; clear horiz movement and try jump again
		lda     #$00                            ; EEF2 A9 00                    ..
        sta     CUR_OBJ_DX                             ; EEF4 85 F5                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; EEF6 85 F6                    ..
        
		; branch (inc CUR_OBJ_RISE_SPEED) if carry set; else rts
		jsr     OBJECT_CHECK_Y_MOVEMENT                           ; EEF8 20 E1 F0                  ..
        bcs     LEEFE                           ; EEFB B0 01                    ..
        rts                                     ; EEFD 60                       `

; ----------------------------------------------------------------------------
LEEFE:
		; if we're still hitting, increase CUR_OBJ_RISE_SPEED
        inc     CUR_OBJ_RISE_SPEED                             ; EEFE E6 F1                    ..
        jsr     ENEMY_AI_TRACK_PLAYER                           ; EF00 20 DA F2                  ..
        rts                                     ; EF03 60                       `

; ----------------------------------------------------------------------------
; copies calculated x, x hi, y to the current object
APPLY_CALC_POS_TO_CUR_OBJ:
        lda     TEMP_NEXT_X_LO                           ; EF04 A5 0E                    ..
        sta     CUR_OBJ_NEXT_X                             ; EF06 85 F9                    ..
        lda     TEMP_NEXT_X_HI                             ; EF08 A5 0F                    ..
        sta     CUR_OBJ_NEXT_X_HI                             ; EF0A 85 FA                    ..
        lda     TEMP_NEXT_Y                             ; EF0C A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; EF0E 85 FB                    ..
        rts                                     ; EF10 60                       `

; ----------------------------------------------------------------------------
; stops enemy movement and clears CUR_OBJ_RISE_SPEED and CUR_OBJ_FALL_SPEED
FREEZE_ENEMY:
        lda     #$00                            ; EF11 A9 00                    ..
        sta     CUR_OBJ_DX                             ; EF13 85 F5                    ..
        sta     CUR_OBJ_DY                             ; EF15 85 F7                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; EF17 85 F1                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; EF19 85 F0                    ..
        rts                                     ; EF1B 60                       `

; ----------------------------------------------------------------------------
; current object is an enemy that has been killed
; handles playing the sound and making it fall offscreen
UPDATE_DYING_ENEMY:
        ; branch if any of the lower 7 bits of CUR_OBJ_GEN_TYPE are set
		; which will be the case on the 2nd time through here
		lda     CUR_OBJ_GEN_TYPE                             ; EF1C A5 EE                    ..
        and     #$7F                            ; EF1E 29 7F                    ).
		bne     LEF45                           ; EF20 D0 23                    .#
        
		; CUR_OBJ_GEN_TYPE lower 7 bits all clear; increment CUR_OBJ_GEN_TYPE
		; goes from x80 when enemy first killed --> 0x81
		inc     a:CUR_OBJ_GEN_TYPE                           ; EF22 EE EE 00                 ...
        lda     #SOUND_KILL_ENEMY                            ; EF25 A9 0E                    ..
        sta     NEXT_SOUND_EFFECT                             ; EF27 85 8F                    ..
        
		; starts out moving upward
		lda     #$08                            ; EF29 A9 08                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; EF2B 85 F1                    ..
        
		; clear stuff
		lda     #$00                            ; EF2D A9 00                    ..
        sta     CUR_OBJ_DX                             ; EF2F 85 F5                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; EF31 85 F6                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; EF33 85 F0                    ..
        
		; save the y value - we'll place the item here later
		lda     CUR_OBJ_NEXT_Y                             ; EF35 A5 FB                    ..
        sta     CUR_OBJ_Y_COPY                             ; EF37 85 FC                    ..
        
		; load the death sprite
		ldy     #ENEMY_DEATH_SPRITE                            ; EF39 A0 06                    ..
        lda     (MAP_META_PTR_LO),y                         ; EF3B B1 E7                    ..
        sta     CUR_OBJ_SPRITE                             ; EF3D 85 ED                    ..
        
		; clear upper 6 bits of CUR_OBJ_SPRITE_FLAGS
		; clears any horizontal/vertical mirroring so sprite starts upright, but keeps palette
		lda     CUR_OBJ_SPRITE_FLAGS                             ; EF3F A5 EF                    ..
        and     #$03                            ; EF41 29 03                    ).
        sta     CUR_OBJ_SPRITE_FLAGS                             ; EF43 85 EF                    ..
LEF45:
        ; branch if CUR_OBJ_FALL_SPEED <> 0 (set to 0 above)
		lda     CUR_OBJ_FALL_SPEED                             ; EF45 A5 F0                    ..
        bne     LEF6E                           ; EF47 D0 25                    .%
        
		; dec CUR_OBJ_RISE_SPEED - decelerate corpse upward motion 
		; branch if it's 0 - corpse has reached top of its upward motion
		dec     CUR_OBJ_RISE_SPEED                             ; EF49 C6 F1                    ..
        beq     CORPSE_START_DESCENT                           ; EF4B F0 16                    ..
        
		; convert CUR_OBJ_RISE_SPEED to a speed: -f1+1
		lda     CUR_OBJ_RISE_SPEED                             ; EF4D A5 F1                    ..
        eor     #$FF                            ; EF4F 49 FF                    I.
        clc                                     ; EF51 18                       .
        adc     #$01                            ; EF52 69 01                    i.
        sta     CUR_OBJ_DY                             ; EF54 85 F7                    ..
        jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; EF56 20 F1 EF                  ..
        jsr     CHECK_OBJECT_OFFSCREEN                           ; EF59 20 08 CF                  ..
        
		; branch if it's risen offscreen
		; we flip it upside down and set CUR_OBJ_FALL_SPEED to start descent
		; this is why enemies killed at top of screen drop immediately
		; and don't fly up into the ceiling!
		bcs     CORPSE_START_DESCENT                           ; EF5C B0 05                    ..
        
		; it hasn't - set its next y position
		lda     TEMP_NEXT_Y                             ; EF5E A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; EF60 85 FB                    ..
        rts                                     ; EF62 60                       `

; ----------------------------------------------------------------------------
CORPSE_START_DESCENT:
		; we flip it vertically and set CUR_OBJ_FALL_SPEED to start descent
		lda     CUR_OBJ_SPRITE_FLAGS                             ; EF63 A5 EF                    ..
        ora     #$80                            ; EF65 09 80                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; EF67 85 EF                    ..
        lda     #$01                            ; EF69 A9 01                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; EF6B 85 F0                    ..
        rts                                     ; EF6D 60                       `

; ----------------------------------------------------------------------------
LEF6E:
		; accelerate the corpse downward
        inc     CUR_OBJ_FALL_SPEED                             ; EF6E E6 F0                    ..
        lda     CUR_OBJ_FALL_SPEED                             ; EF70 A5 F0                    ..
        lsr     a                               ; EF72 4A                       J
        clc                                     ; EF73 18                       .
        adc     #$02                            ; EF74 69 02                    i.
        sta     CUR_OBJ_DY                             ; EF76 85 F7                    ..
        jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; EF78 20 F1 EF                  ..
        
		; generate the drop if it's fallen offscreen
		jsr     CHECK_OBJECT_OFFSCREEN                           ; EF7B 20 08 CF                  ..
        bcs     GEN_MONSTER_DROP_ITEM                           ; EF7E B0 05                    ..
        lda     TEMP_NEXT_Y                             ; EF80 A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; EF82 85 FB                    ..
        rts                                     ; EF84 60                       `

; ----------------------------------------------------------------------------
; choose a monster drop item
; forced items - bread (life<20), magic (magic<30), keys (keys<2)
; if no force, use RNG
; basic item (11/20) = bread, magic, or golds - whichever is lowest
; special item (9/20) - poison (4), key (2), ring (1), scroll (1), or cross (1)
GEN_MONSTER_DROP_ITEM:
        ldx     #$00                            ; EF85 A2 00                    ..
        lda     PLAYER_LIFE                             ; EF87 A5 58                    .X
        cmp     #$14                            ; EF89 C9 14                    ..
        
		; branch (give bread) if life<20
		bcc     LEFC4                           ; EF8B 90 37                    .7
        inx                                     ; EF8D E8                       .
        lda     PLAYER_MAGIC                             ; EF8E A5 59                    .Y
        cmp     #$1E                            ; EF90 C9 1E                    ..
        
		; branch (give magic) if magic<30
		bcc     LEFC4                           ; EF92 90 30                    .0
        ldx     #$04                            ; EF94 A2 04                    ..
        lda     PLAYER_KEYS                             ; EF96 A5 5B                    .[
        cmp     #$02                            ; EF98 C9 02                    ..
        
		; branch (give key) if keys<2
		bcc     LEFC4                           ; EF9A 90 28                    .(
        
		; no forced item, determine based on RNG
		lda     #$14                            ; EF9C A9 14                    ..
        jsr     UPDATE_RNG                           ; EF9E 20 64 CC                  d.
        cmp     #$09                            ; EFA1 C9 09                    ..
        
		; branch (common item) if RNG >= 9
		bcs     GEN_BASIC_ITEM                           ; EFA3 B0 07                    ..
        
		; RNG < 9, cool item (well, poison, key, ring, scroll or cross)
		tay                                     ; EFA5 A8                       .
        ldx     TBL_SPECIAL_ITEM,y                         ; EFA6 BE E7 EF                 ...
        jmp     LEFC4                           ; EFA9 4C C4 EF                 L..

; ----------------------------------------------------------------------------
; chooses a basic item based on what the player needs most
GEN_BASIC_ITEM:
        ; x = target item; defaults to life
		ldx     #$00                            ; EFAC A2 00                    ..
        lda     PLAYER_LIFE                             ; EFAE A5 58                    .X
        cmp     PLAYER_MAGIC                             ; EFB0 C5 59                    .Y
        
		; branch (check life vs gold) if life<magic
		bcc     LEFBE                           ; EFB2 90 0A                    ..
        
		; life>magic; magic is now the default item
		inx                                     ; EFB4 E8                       .
        lda     PLAYER_MAGIC                             ; EFB5 A5 59                    .Y
        cmp     PLAYER_GOLDS                             ; EFB7 C5 5A                    .Z
        
		; branch (give magic) if gold>magic
		bcc     LEFC4                           ; EFB9 90 09                    ..
        
		; else check life vs gold
		jmp     LEFC2                           ; EFBB 4C C2 EF                 L..

; ----------------------------------------------------------------------------
LEFBE:
        cmp     PLAYER_GOLDS                             ; EFBE C5 5A                    .Z
        
		; branch (give life) if gold>life
		bcc     LEFC4                           ; EFC0 90 02                    ..
LEFC2:
		; else give gold
        ldx     #$02                            ; EFC2 A2 02                    ..
		
; generate monster drop item based on x		
LEFC4:
		; convert drop ID to OBJ_GEN_TYPE (+2)
        txa                                     ; EFC4 8A                       .
        clc                                     ; EFC5 18                       .
        adc     #$02                            ; EFC6 69 02                    i.
        sta     CUR_OBJ_GEN_TYPE                             ; EFC8 85 EE                    ..
        
		; convert to sprite
		txa                                     ; EFCA 8A                       .
        asl     a                               ; EFCB 0A                       .
        asl     a                               ; EFCC 0A                       .
        ora     #$81                            ; EFCD 09 81                    ..
        sta     CUR_OBJ_SPRITE                             ; EFCF 85 ED                    ..
        
		; set palette
		lda     #$01                            ; EFD1 A9 01                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; EFD3 85 EF                    ..
        
		; now that the corpse has fallen offscreen, we restore the y pos of where it 
		; was killed, which is where the item shows up
		lda     CUR_OBJ_Y_COPY                             ; EFD5 A5 FC                    ..
        sta     CUR_OBJ_NEXT_Y                             ; EFD7 85 FB                    ..
        
		; set fade timer
		lda     #$F0                            ; EFD9 A9 F0                    ..
        sta     CUR_OBJ_MISC_CTR                             ; EFDB 85 F3                    ..
        
		; clear movement, check interactions/physics
		lda     #$00                            ; EFDD A9 00                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; EFDF 85 F0                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; EFE1 85 F1                    ..
        jsr     CHECK_OBJECT_INTERACTIONS                           ; EFE3 20 79 F1                  y.
        rts                                     ; EFE6 60                       `

; ----------------------------------------------------------------------------
; item drop table for the 'special' items which are not dropped based on player need
TBL_SPECIAL_ITEM:
        .byte   ITEM_POISON,ITEM_POISON,ITEM_POISON,ITEM_POISON,ITEM_KEY,ITEM_KEY,ITEM_RING,ITEM_CROSS ; EFE7 03 03 03 03 04 04 05 06  ........
        .byte   ITEM_SCROLL                             ; EFEF 07                       .
; ----------------------------------------------------------------------------

; convenient rts that several routines jump to
RTS_LEFF0:
        rts                                     ; EFF0 60                       `

; ----------------------------------------------------------------------------
; calculates a new position based on temp variables
; CUR_OBJ_NEXT_X --> $0e
; CUR_OBJ_NEXT_X_HI --> $0f
; TEMP_NEXT_Y --> CUR_OBJ_NEXT_Y+$f7
; $0e --> CUR_OBJ_DX+$f9
; $0f --> $0e+$f5 --> a; $0f+$f6 (plus carry if a*16 has it)
CALC_NEXT_POS_FROM_TEMP_VARS:
        lda     CUR_OBJ_NEXT_X                             ; EFF1 A5 F9                    ..
        sta     TEMP_NEXT_X_LO                           ; EFF3 85 0E                    ..
        lda     CUR_OBJ_NEXT_X_HI                             ; EFF5 A5 FA                    ..
        sta     TEMP_NEXT_X_HI                             ; EFF7 85 0F                    ..
        lda     CUR_OBJ_NEXT_Y                             ; EFF9 A5 FB                    ..
        sta     TEMP_NEXT_Y                             ; EFFB 85 0A                    ..
        
		; branch if not moving vertically
		lda     CUR_OBJ_DY                             ; EFFD A5 F7                    ..
        beq     LF006                           ; EFFF F0 05                    ..
        
		; otherwise, apply dy
		clc                                     ; F001 18                       .
        adc     TEMP_NEXT_Y                             ; F002 65 0A                    e.
        sta     TEMP_NEXT_Y                             ; F004 85 0A                    ..
LF006:
        ; branch if not moving horizontally
		lda     CUR_OBJ_DX                             ; F006 A5 F5                    ..
        beq     LF01D                           ; F008 F0 13                    ..
        
		; otherwise, apply dx to x_lo (0-f) and x_hi
		clc                                     ; F00A 18                       .
        adc     TEMP_NEXT_X_LO                           ; F00B 65 0E                    e.
        pha                                     ; F00D 48                       H
        and     #$0F                            ; F00E 29 0F                    ).
        sta     TEMP_NEXT_X_LO                           ; F010 85 0E                    ..
        pla                                     ; F012 68                       h
        asl     a                               ; F013 0A                       .
        asl     a                               ; F014 0A                       .
        asl     a                               ; F015 0A                       .
        asl     a                               ; F016 0A                       .
        
		; increase or decrease x_hi depending on direction
		lda     TEMP_NEXT_X_HI                             ; F017 A5 0F                    ..
        adc     CUR_OBJ_HORIZ_DIR                             ; F019 65 F6                    e.
        sta     TEMP_NEXT_X_HI                             ; F01B 85 0F                    ..
LF01D:
        rts                                     ; F01D 60                       `

; ----------------------------------------------------------------------------
; execute the enemy's animation routine; these are specified in the enemy definitions
; in map meta data, and appear in jump tabe below
ANIMATE_ENEMY:
        ldy     #ENEMY_ANIMATION_ROUTINE                            ; F01E A0 07                    ..
        lda     (MAP_META_PTR_LO),y                         ; F020 B1 E7                    ..
        and     #$03                            ; F022 29 03                    ).
        asl     a                               ; F024 0A                       .
        tax                                     ; F025 AA                       .
        lda     JMP_TBL_ENEMY_SPECIAL_ROUTINE,x                         ; F026 BD 33 F0                 .3.
        sta     JMP_DEST_0E_LO                           ; F029 85 0E                    ..
        lda     JMP_TBL_ENEMY_SPECIAL_ROUTINE+1,x                       ; F02B BD 34 F0                 .4.
        sta     JMP_DEST_0F_HI                             ; F02E 85 0F                    ..
        jmp     (JMP_DEST_0E_LO)                         ; F030 6C 0E 00                 l..

; ----------------------------------------------------------------------------
JMP_TBL_ENEMY_SPECIAL_ROUTINE:
        ; horiz flip every 4th tick
		.addr   ENEMY_ANIMATION_HORIZ_FLIP_CYCLE                           ; F033 3B F0                    ;.
        
		; alternate sprites every 4th tick; flip horizontal based on move dir (f6)
		.addr   ENEMY_ANIMATION_ALTERNATING_CYCLE                           ; F035 4B F0                    K.
        
		; ceiling crawlers with big eyes that dive bomb player
		.addr   ENEMY_ANIMATION_CEILING_CRAWLER                           ; F037 71 F0                    q.
        
		; cycles between 4 sprites instead of 2
		.addr   ENEMY_ANIMATION_4_STATE_CYCLE                           ; F039 B9 F0                    ..
; ----------------------------------------------------------------------------
; horiz flip every 4th tick - pretty basic, presumably for immobile enemies
ENEMY_ANIMATION_HORIZ_FLIP_CYCLE:
		; horizontally flip the object every 4th tick of the misc ctr
        inc     CUR_OBJ_MISC_CTR                             ; F03B E6 F3                    ..
        lda     CUR_OBJ_MISC_CTR                             ; F03D A5 F3                    ..
        and     #$03                            ; F03F 29 03                    ).
        beq     LF044                           ; F041 F0 01                    ..
        rts                                     ; F043 60                       `

; ----------------------------------------------------------------------------
LF044:
		; toggle horizontal flip
        lda     CUR_OBJ_SPRITE_FLAGS                             ; F044 A5 EF                    ..
        eor     #$40                            ; F046 49 40                    I@
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F048 85 EF                    ..
        rts                                     ; F04A 60                       `

; ----------------------------------------------------------------------------
; alternate sprites every 4th tick; flip horizontal based on move dir (f6)
ENEMY_ANIMATION_ALTERNATING_CYCLE:
		; branch if not moving horizontally
        lda     CUR_OBJ_DX                             ; F04B A5 F5                    ..
        beq     LF061                           ; F04D F0 12                    ..
        
		; moving horizontally; branch if moving left
		ldy     #$00                            ; F04F A0 00                    ..
        lda     CUR_OBJ_HORIZ_DIR                             ; F051 A5 F6                    ..
        bmi     LF057                           ; F053 30 02                    0.
        
		; moving right - horizontal flip
		ldy     #$40                            ; F055 A0 40                    .@
LF057:
        sty     SCRATCH_08                             ; F057 84 08                    ..
        lda     CUR_OBJ_SPRITE_FLAGS                             ; F059 A5 EF                    ..
        and     #$3F                            ; F05B 29 3F                    )?
        ora     SCRATCH_08                             ; F05D 05 08                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F05F 85 EF                    ..
LF061:
		; alternate sprite every 4th ctr tick
        inc     CUR_OBJ_MISC_CTR                             ; F061 E6 F3                    ..
        lda     CUR_OBJ_MISC_CTR                             ; F063 A5 F3                    ..
        and     #$03                            ; F065 29 03                    ).
        beq     LF06A                           ; F067 F0 01                    ..
        rts                                     ; F069 60                       `

; ----------------------------------------------------------------------------
LF06A:
		; toggle sprite animation
        lda     CUR_OBJ_SPRITE                             ; F06A A5 ED                    ..
        eor     #$04                            ; F06C 49 04                    I.
        sta     CUR_OBJ_SPRITE                             ; F06E 85 ED                    ..
        rts                                     ; F070 60                       `

; ----------------------------------------------------------------------------
; ceiling crawlers with big eyes that dive bomb player
ENEMY_ANIMATION_CEILING_CRAWLER:
        ; branch if not moving horizontally
		lda     CUR_OBJ_DX                             ; F071 A5 F5                    ..
        beq     LF090                           ; F073 F0 1B                    ..
        
		; moving horizontally - handle horizontal flip 
		; branch if moving left
		ldy     #$00                            ; F075 A0 00                    ..
        lda     CUR_OBJ_HORIZ_DIR                             ; F077 A5 F6                    ..
        bmi     LF07D                           ; F079 30 02                    0.
        ldy     #$40                            ; F07B A0 40                    .@
LF07D:
        sty     SCRATCH_08                             ; F07D 84 08                    ..
        lda     CUR_OBJ_SPRITE_FLAGS                             ; F07F A5 EF                    ..
        and     #$3F                            ; F081 29 3F                    )?
        ora     SCRATCH_08                             ; F083 05 08                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F085 85 EF                    ..
        
		; clear bit 3 on sprite
		lda     CUR_OBJ_SPRITE                             ; F087 A5 ED                    ..
        and     #$F7                            ; F089 29 F7                    ).
        sta     CUR_OBJ_SPRITE                             ; F08B 85 ED                    ..
        jmp     LF09C                           ; F08D 4C 9C F0                 L..

; ----------------------------------------------------------------------------
LF090:
		; branch if not moving vertically
        lda     CUR_OBJ_DY                             ; F090 A5 F7                    ..
        beq     LF09C                           ; F092 F0 08                    ..
        
		; set bit 3, clear bit 2 on sprite
		lda     CUR_OBJ_SPRITE                             ; F094 A5 ED                    ..
        and     #$F3                            ; F096 29 F3                    ).
        ora     #$08                            ; F098 09 08                    ..
        sta     CUR_OBJ_SPRITE                             ; F09A 85 ED                    ..
LF09C:
		; branch every 4th tick
        inc     CUR_OBJ_MISC_CTR                             ; F09C E6 F3                    ..
        lda     CUR_OBJ_MISC_CTR                             ; F09E A5 F3                    ..
        and     #$03                            ; F0A0 29 03                    ).
        beq     LF0A5                           ; F0A2 F0 01                    ..
        rts                                     ; F0A4 60                       `

; ----------------------------------------------------------------------------
LF0A5:
		; branch if sprite bit 3 set
        lda     CUR_OBJ_SPRITE                             ; F0A5 A5 ED                    ..
        and     #$08                            ; F0A7 29 08                    ).
        bne     LF0B2                           ; F0A9 D0 07                    ..
        
		; sprite bit 3 clear; alternate sprite
		lda     CUR_OBJ_SPRITE                             ; F0AB A5 ED                    ..
        eor     #$04                            ; F0AD 49 04                    I.
        sta     CUR_OBJ_SPRITE                             ; F0AF 85 ED                    ..
        rts                                     ; F0B1 60                       `

; ----------------------------------------------------------------------------
LF0B2:
		; sprite bit 3 set; toggle horizontal flip
        lda     CUR_OBJ_SPRITE_FLAGS                             ; F0B2 A5 EF                    ..
        eor     #$40                            ; F0B4 49 40                    I@
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F0B6 85 EF                    ..
        rts                                     ; F0B8 60                       `

; ----------------------------------------------------------------------------
; cycles between 4 sprites instead of 2
ENEMY_ANIMATION_4_STATE_CYCLE:
		; branch if not moving horizontally
        lda     CUR_OBJ_DX                             ; F0B9 A5 F5                    ..
        beq     LF0CF                           ; F0BB F0 12                    ..
       
	    ; moving horizontally - handle flip
		; branch if moving left
  	    ldy     #$00                            ; F0BD A0 00                    ..
        lda     CUR_OBJ_HORIZ_DIR                             ; F0BF A5 F6                    ..
        bmi     LF0C5                           ; F0C1 30 02                    0.
        ldy     #$40                            ; F0C3 A0 40                    .@
LF0C5:
        sty     SCRATCH_08                             ; F0C5 84 08                    ..
        lda     CUR_OBJ_SPRITE_FLAGS                             ; F0C7 A5 EF                    ..
        and     #$3F                            ; F0C9 29 3F                    )?
        ora     SCRATCH_08                             ; F0CB 05 08                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F0CD 85 EF                    ..
LF0CF:
        inc     CUR_OBJ_MISC_CTR                             ; F0CF E6 F3                    ..
        lda     CUR_OBJ_MISC_CTR                             ; F0D1 A5 F3                    ..
        and     #$06                            ; F0D3 29 06                    ).
        asl     a                               ; F0D5 0A                       .
        sta     SCRATCH_08                             ; F0D6 85 08                    ..
        
		; clear bits 2 and 3 but potentially set them via ora from ctr*2
		; so, 4 states, e.g. xE1, xE5, xE9, xED
		lda     CUR_OBJ_SPRITE                             ; F0D8 A5 ED                    ..
        and     #$F3                            ; F0DA 29 F3                    ).
        ora     SCRATCH_08                             ; F0DC 05 08                    ..
        sta     CUR_OBJ_SPRITE                             ; F0DE 85 ED                    ..
        rts                                     ; F0E0 60                       `

; ----------------------------------------------------------------------------

; check if an object's current dy will result in it hitting something
; return - carry set if hit solid; clear if didn't
OBJECT_CHECK_Y_MOVEMENT:
		; check movement
        lda     CUR_OBJ_DY                             ; F0E1 A5 F7                    ..
        pha                                     ; F0E3 48                       H
LF0E4:
        jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; F0E4 20 F1 EF                  ..
        jsr     CHECK_OBJECT_OFFSCREEN                           ; F0E7 20 08 CF                  ..
        
		; branch (clear slot/setup respawn) if offscreen
		bcs     LF10E                           ; F0EA B0 22                    ."
        
		; not offscreen; branch if CUR_OBJ_GEN_TYPE-1 <> 0 i.e. not an enemy
		ldx     CUR_OBJ_GEN_TYPE                             ; F0EC A6 EE                    ..
        dex                                     ; F0EE CA                       .
        bne     LF0F9                           ; F0EF D0 08                    ..
        
		; CUR_OBJ_GEN_TYPE = 1 (enemy); branch if not colliding with player
		jsr     CHECK_OBJ_COLLIDE_WITH_PLAYER                           ; F0F1 20 7C CE                  |.
        bcc     LF0F9                           ; F0F4 90 03                    ..
        
		; hitting player
		jsr     ENEMY_OR_PROJECTILE_HIT_PLAYER                           ; F0F6 20 36 F1                  6.
LF0F9:
		; branch if not hitting solid tile (save dy and return with carry clear)
        jsr     CHECK_TEMP_NEXT_POS_HIT_SOLID_TILE                           ; F0F9 20 3A F2                  :.
        bcc     LF117                           ; F0FC 90 19                    ..
        
		; hitting solid tile; branch if not moving vertically
		ldx     CUR_OBJ_DY                             ; F0FE A6 F7                    ..
        beq     LF116                           ; F100 F0 14                    ..
        
		; moving vertically; branch if moving upward
		bmi     LF106                           ; F102 30 02                    0.
        dex                                     ; F104 CA                       .
        dex                                     ; F105 CA                       .
LF106:
        inx                                     ; F106 E8                       .
        stx     CUR_OBJ_DY                             ; F107 86 F7                    ..
        
		; loop and decrease dy until it's 0 or no longer hitting a solid tile
		bne     LF0E4                           ; F109 D0 D9                    ..
        
		; set carry, save dy and rts
		jmp     LF116                           ; F10B 4C 16 F1                 L..

; ----------------------------------------------------------------------------
; enemy ran offscreen 
LF10E:
		; clear it
        lda     #$00                            ; F10E A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; F110 85 EE                    ..
        
		; set respawn counter
		lda     #$F0                            ; F112 A9 F0                    ..
        sta     CUR_OBJ_MISC_CTR                             ; F114 85 F3                    ..
LF116:
        sec                                     ; F116 38                       8
LF117:
        pla                                     ; F117 68                       h
        sta     CUR_OBJ_DY                             ; F118 85 F7                    ..
        rts                                     ; F11A 60                       `

; ----------------------------------------------------------------------------
; for the proposed enemy movement, see if it hits player or runs oob
; sets carry if hits player
; clears the enemy and starts respawn ctr if oob
CHECK_ENEMY_MOVEMENT_HIT_OR_OOB:
        ; branch if no collision with player
		jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; F11B 20 F1 EF                  ..
        jsr     CHECK_OBJ_COLLIDE_WITH_PLAYER                           ; F11E 20 7C CE                  |.
        bcc     LF128                           ; F121 90 05                    ..
        
		; TODO: check name on this - seems like it's any enemy, not just projectile?
		jsr     ENEMY_OR_PROJECTILE_HIT_PLAYER                           ; F123 20 36 F1                  6.
        sec                                     ; F126 38                       8
        rts                                     ; F127 60                       `

; ----------------------------------------------------------------------------
LF128:
		; branch if not oob
        jsr     CHECK_OBJECT_OFFSCREEN                           ; F128 20 08 CF                  ..
        bcc     LF135                           ; F12B 90 08                    ..
        
		; erase and start ctr for respawn
		lda     #$00                            ; F12D A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; F12F 85 EE                    ..
        lda     #$F0                            ; F131 A9 F0                    ..
        sta     CUR_OBJ_MISC_CTR                             ; F133 85 F3                    ..
LF135:
        rts                                     ; F135 60                       `

; ----------------------------------------------------------------------------
ENEMY_OR_PROJECTILE_HIT_PLAYER:
        ; branch (no damage) if invulnerable
		lda     INVULN_CTR                             ; F136 A5 85                    ..
        bne     LF178                           ; F138 D0 3E                    .>
        
		; branch if CUR_OBJ_GEN_TYPE-1 <> 0
		ldx     CUR_OBJ_GEN_TYPE                             ; F13A A6 EE                    ..
        dex                                     ; F13C CA                       .
        bne     LF178                           ; F13D D0 39                    .9
        
		; CUR_OBJ_GEN_TYPE-1 = 0; we are an enemy
		; branch if not on a boss level
		lda     CHR_BANK_ENEMY_SPRITES                             ; F13F A5 2D                    .-
        cmp     #SPRITE_PT_TARATUNES                            ; F141 C9 30                    .0
        bcc     LF154                           ; F143 90 0F                    ..
        
		; boss fight
		; branch if current object is the boss itself
		lda     CUR_OBJ_SLOT_NUM                             ; F145 A5 E3                    ..
        beq     OBJECT_DAMAGE_PLAYER                           ; seF147 F0 11                    ..
        
		; otherwise, this is one of the boss's projectiles - branch (no damage) if shield equipped
		ldx     CUR_EQUIP_SLOT_SELECTED                             ; F149 A6 55                    .U
        lda     CUR_EQUIP_ITEMS,x                           ; F14B B5 51                    .Q
        cmp     #INV_ITEM_SHIELD                           ; F14D C9 0A                    ..
        beq     BOSS_PROJECTILE_HIT_SHIELD                           ; F14F F0 22                    ."
        
		; else jump
		jmp     OBJECT_DAMAGE_PLAYER                           ; F151 4C 5A F1                 LZ.

; ----------------------------------------------------------------------------
LF154:
        ; branch if pochi - no damage :)
		lda     PLAYER_ID                             ; F154 A5 40                    .@
        cmp     #PLAYER_POCHI                         ; F156 C9 04                    ..
        beq     LF178                           ; F158 F0 1E                    ..

; enemy or projectile damages the player
OBJECT_DAMAGE_PLAYER:
        ; apply damage
		lda     CUR_OBJ_DAMAGE                             ; F15A A5 F8                    ..
        jsr     STEAL_PLAYER_LIFE                           ; F15C 20 DB E7                  ..
        
		; sound effect and 1s invulnerability
		lda     #SOUND_TAKE_DAMAGE                            ; F15F A9 21                    .!
        sta     a:NEXT_SOUND_EFFECT                           ; F161 8D 8F 00                 ...
        lda     #$01                            ; F164 A9 01                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; F166 85 90                    ..
        lda     #$01                            ; F168 A9 01                    ..
        sta     INVULN_CTR                             ; F16A 85 85                    ..
        
		; clear sprite flag x20 - show it in front of bg
		lda     CUR_OBJ_SPRITE_FLAGS                             ; F16C A5 EF                    ..
        and     #$DF                            ; F16E 29 DF                    ).
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F170 85 EF                    ..
        rts                                     ; F172 60                       `

; ----------------------------------------------------------------------------
BOSS_PROJECTILE_HIT_SHIELD:
        lda     #SOUND_SHIELD_HIT                            ; F173 A9 01                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; F175 8D 8F 00                 ...
LF178:
        rts                                     ; F178 60                       `

; ----------------------------------------------------------------------------
CHECK_OBJECT_INTERACTIONS:
        ; branch if CUR_OBJ_RISE_SPEED <> 0
		lda     CUR_OBJ_RISE_SPEED                             ; F179 A5 F1                    ..
        bne     LF1D3                           ; F17B D0 56                    .V
        
		; CUR_OBJ_RISE_SPEED = 0
		lda     CUR_OBJ_NEXT_X_HI                             ; F17D A5 FA                    ..
        sta     PLAYER_MAP_TILE_LO                           ; F17F 85 0C                    ..
        sta     TEMP_NEXT_X_HI                             ; F181 85 0F                    ..
        lda     CUR_OBJ_NEXT_X                             ; F183 A5 F9                    ..
        sta     TEMP_NEXT_X_LO                           ; F185 85 0E                    ..
        ldx     CUR_OBJ_NEXT_Y                             ; F187 A6 FB                    ..
        
		; branch if current object is an enemy (gen type = 1)
		ldy     CUR_OBJ_GEN_TYPE                             ; F189 A4 EE                    ..
        dey                                     ; F18B 88                       .
        beq     LF199                           ; F18C F0 0B                    ..
        
		; not an enemy; if we're a flickering item then our CUR_OBJ_NEXT_Y may 
		; set to offscreen; so we check here and use the on-screen CUR_OBJ_Y_COPY
		; for collision-detection purposes
		cpx     #OFFSCREEN_Y                            ; F18E E0 EF                    ..
        bne     LF194                           ; F190 D0 02                    ..
        
		; flickering item currently offscreen - use the onscreen y copy
		ldx     CUR_OBJ_Y_COPY                             ; F192 A6 FC                    ..
LF194:
        stx     PLAYER_MAP_TILE_HI                             ; F194 86 0D                    ..
        jmp     LF1A7                           ; F196 4C A7 F1                 L..

; ----------------------------------------------------------------------------
LF199:
        ; branch if going off bottom of screen
		cpx     #$B0                            ; F199 E0 B0                    ..
        bcs     LF1CF                           ; F19B B0 32                    .2
        
		; otherwise, set our position
		stx     PLAYER_MAP_TILE_HI                             ; F19D 86 0D                    ..
        inx                                     ; F19F E8                       .
        stx     TEMP_NEXT_Y                             ; F1A0 86 0A                    ..
        jsr     CHECK_OBJ_COLLIDE_WITH_PLAYER                           ; F1A2 20 7C CE                  |.
        bcs     LF1D3                           ; F1A5 B0 2C                    .,
LF1A7:
        jsr     UPDATE_MAP_TILE_PTRS                           ; F1A7 20 54 CA                  T.
        lda     CUR_OBJ_NEXT_X                             ; F1AA A5 F9                    ..
        
		; branch if next x <> 0
		bne     LF1BD                           ; F1AC D0 0F                    ..
        
		; next x = 0 
		; branch if near a ladder
		ldy     #$00                            ; F1AE A0 00                    ..
        lda     (PLAYER_MAP_TILE_PTR),y                       ; F1B0 B1 0C                    ..
        and     #$3F                            ; F1B2 29 3F                    )?
        beq     LF1D3                           ; F1B4 F0 1D                    ..
        iny                                     ; F1B6 C8                       .
        lda     (PLAYER_MAP_TILE_PTR),y                       ; F1B7 B1 0C                    ..
        and     #$3F                            ; F1B9 29 3F                    )?
        beq     LF1D3                           ; F1BB F0 16                    ..
LF1BD:
		; not near a ladder; check if hitting 
        ldy     #$01                            ; F1BD A0 01                    ..
        jsr     CHECK_Y_TILE_SOLID_REDUX                           ; F1BF 20 33 F2                  3.
        bcs     LF1D3                           ; F1C2 B0 0F                    ..
        lda     CUR_OBJ_NEXT_X                             ; F1C4 A5 F9                    ..
        beq     LF1CF                           ; F1C6 F0 07                    ..
        ldy     #$0D                            ; F1C8 A0 0D                    ..
        jsr     CHECK_Y_TILE_SOLID_REDUX                           ; F1CA 20 33 F2                  3.
        bcs     LF1D3                           ; F1CD B0 04                    ..
LF1CF:
		; inc counter for how far we've traveled?
        inc     CUR_OBJ_FALL_SPEED                             ; F1CF E6 F0                    ..
        clc                                     ; F1D1 18                       .
        rts                                     ; F1D2 60                       `

; ----------------------------------------------------------------------------
LF1D3:
		; object near a ladder or solid tile
		; if f0 >= x0c subtract 4 and save to f1; either way clear f0
        lda     CUR_OBJ_FALL_SPEED                             ; F1D3 A5 F0                    ..
        cmp     #$0C                            ; F1D5 C9 0C                    ..
        bcc     LF1DE                           ; F1D7 90 05                    ..
        
		; if fall speed >= x0c give a little bounce on hitting ground!
		sec                                     ; F1D9 38                       8
        sbc     #$04                            ; F1DA E9 04                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; F1DC 85 F1                    ..
LF1DE:
        lda     #$00                            ; F1DE A9 00                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; F1E0 85 F0                    ..
        sec                                     ; F1E2 38                       8
        rts                                     ; F1E3 60                       `

; ----------------------------------------------------------------------------
; check a boss's movement for legality
BOSS_CHECK_MOVEMENT:
        ; branch if rising
		lda     CUR_OBJ_RISE_SPEED                             ; F1E4 A5 F1                    ..
        bne     LF223                           ; F1E6 D0 3B                    .;
        
		; setup collision detection vars
		lda     CUR_OBJ_NEXT_X_HI                             ; F1E8 A5 FA                    ..
        sta     PLAYER_MAP_TILE_LO                           ; F1EA 85 0C                    ..
        sta     TEMP_NEXT_X_HI                             ; F1EC 85 0F                    ..
        lda     CUR_OBJ_NEXT_X                             ; F1EE A5 F9                    ..
        sta     TEMP_NEXT_X_LO                           ; F1F0 85 0E                    ..
        ldx     CUR_OBJ_NEXT_Y                             ; F1F2 A6 FB                    ..
        stx     PLAYER_MAP_TILE_HI                             ; F1F4 86 0D                    ..
        inx                                     ; F1F6 E8                       .
        stx     TEMP_NEXT_Y                             ; F1F7 86 0A                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; F1F9 20 54 CA                  T.
        
		; branch if near bottom of screen
		lda     CUR_OBJ_NEXT_Y                             ; F1FC A5 FB                    ..
        cmp     #$A0                            ; F1FE C9 A0                    ..
        bcs     LF220                           ; F200 B0 1E                    ..
        
		; branch if hitting player
		jsr     CHECK_BOSS_PLAYER_PROXIMITY                           ; F202 20 C7 CE                  ..
        bcs     LF223                           ; F205 B0 1C                    ..
        
		; to LF223 if near solid tile, else LF220
		ldy     #$02                            ; F207 A0 02                    ..
        jsr     CHECK_Y_TILE_SOLID_REDUX                           ; F209 20 33 F2                  3.
        bcs     LF223                           ; F20C B0 15                    ..
        ldy     #$0E                            ; F20E A0 0E                    ..
        jsr     CHECK_Y_TILE_SOLID_REDUX                           ; F210 20 33 F2                  3.
        bcs     LF223                           ; F213 B0 0E                    ..
        lda     CUR_OBJ_NEXT_X                             ; F215 A5 F9                    ..
        beq     LF220                           ; F217 F0 07                    ..
        ldy     #$1A                            ; F219 A0 1A                    ..
        jsr     CHECK_Y_TILE_SOLID_REDUX                           ; F21B 20 33 F2                  3.
        bcs     LF223                           ; F21E B0 03                    ..
LF220:
		; inc travel counter
        inc     CUR_OBJ_FALL_SPEED                             ; F220 E6 F0                    ..
        rts                                     ; F222 60                       `

; ----------------------------------------------------------------------------
LF223:
		; clear CUR_OBJ_FALL_SPEED; if it was >= 12 then subtract 4 and save --> CUR_OBJ_RISE_SPEED
        lda     CUR_OBJ_FALL_SPEED                             ; F223 A5 F0                    ..
        cmp     #$0C                            ; F225 C9 0C                    ..
        bcc     LF22E                           ; F227 90 05                    ..
        sec                                     ; F229 38                       8
        sbc     #$04                            ; F22A E9 04                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; F22C 85 F1                    ..
LF22E:
        lda     #$00                            ; F22E A9 00                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; F230 85 F0                    ..
        rts                                     ; F232 60                       `

; ----------------------------------------------------------------------------
; just a copy of CHECK_Y_TILE_SOLID
; sets carry if tile in y is solid (x3x, x7x, xBx, xFx); clear if not
CHECK_Y_TILE_SOLID_REDUX:
        lda     (PLAYER_MAP_TILE_PTR),y                       ; F233 B1 0C                    ..
        and     #$3F                            ; F235 29 3F                    )?
        cmp     #$30                            ; F237 C9 30                    .0
        rts                                     ; F239 60                       `

; ----------------------------------------------------------------------------
; check up to 4 tiles near TEMP_NEXT_X_HI and TEMP_NEXT_Y and set carry if any
; are solid 
CHECK_TEMP_NEXT_POS_HIT_SOLID_TILE:
        ; copy position vars
		lda     TEMP_NEXT_X_HI                             ; F23A A5 0F                    ..
        sta     PLAYER_MAP_TILE_LO                           ; F23C 85 0C                    ..
        lda     TEMP_NEXT_Y                             ; F23E A5 0A                    ..
        sta     PLAYER_MAP_TILE_HI                             ; F240 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; F242 20 54 CA                  T.
        
		; check beneath - branch if solid
		ldy     #$00                            ; F245 A0 00                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F247 20 D3 F2                  ..
        bcs     LF274                           ; F24A B0 28                    .(
        
		; branch if aligned with block
		lda     TEMP_NEXT_X_LO                           ; F24C A5 0E                    ..
        beq     LF257                           ; F24E F0 07                    ..
        
		; otherwise, check tile to the right
		ldy     #$0C                            ; F250 A0 0C                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F252 20 D3 F2                  ..
        bcs     LF274                           ; F255 B0 1D                    ..
LF257:
        ; branch if going into the floor
		lda     TEMP_NEXT_Y                             ; F257 A5 0A                    ..
        cmp     #$B0                            ; F259 C9 B0                    ..
        bcs     LF273                           ; F25B B0 16                    ..
        
		; branch if aligned with block in y
		and     #$0F                            ; F25D 29 0F                    ).
        beq     LF273                           ; F25F F0 12                    ..
        
		; otherwise, check upper tile(s) as well
		ldy     #$01                            ; F261 A0 01                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F263 20 D3 F2                  ..
        bcs     LF274                           ; F266 B0 0C                    ..
        lda     TEMP_NEXT_X_LO                           ; F268 A5 0E                    ..
        beq     LF273                           ; F26A F0 07                    ..
        ldy     #$0D                            ; F26C A0 0D                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F26E 20 D3 F2                  ..
        bcs     LF274                           ; F271 B0 01                    ..
LF273:
        clc                                     ; F273 18                       .
LF274:
        rts                                     ; F274 60                       `

; ----------------------------------------------------------------------------
; boss terrain detection - set carry if any part of boss hits a solid tile
CHECK_BOSS_HIT_SOLID_TILE:
		; check the 2 upper left tiles
		; then 2 more columns of 2 moving right
        lda     TEMP_NEXT_X_HI                             ; F275 A5 0F                    ..
        sta     PLAYER_MAP_TILE_LO                           ; F277 85 0C                    ..
        lda     TEMP_NEXT_Y                             ; F279 A5 0A                    ..
        sta     PLAYER_MAP_TILE_HI                             ; F27B 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; F27D 20 54 CA                  T.
        ldy     #$00                            ; F280 A0 00                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F282 20 D3 F2                  ..
        bcs     LF2D2                           ; F285 B0 4B                    .K
        ldy     #$01                            ; F287 A0 01                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F289 20 D3 F2                  ..
        bcs     LF2D2                           ; F28C B0 44                    .D
        ldy     #$0C                            ; F28E A0 0C                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F290 20 D3 F2                  ..
        bcs     LF2D2                           ; F293 B0 3D                    .=
        ldy     #$0D                            ; F295 A0 0D                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F297 20 D3 F2                  ..
        bcs     LF2D2                           ; F29A B0 36                    .6
        lda     TEMP_NEXT_X_LO                           ; F29C A5 0E                    ..
        beq     LF2AE                           ; F29E F0 0E                    ..
        ldy     #$18                            ; F2A0 A0 18                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F2A2 20 D3 F2                  ..
        bcs     LF2D2                           ; F2A5 B0 2B                    .+
        ldy     #$19                            ; F2A7 A0 19                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F2A9 20 D3 F2                  ..
        bcs     LF2D2                           ; F2AC B0 24                    .$
LF2AE:
        ; no solid tile if at bottom or top of screen
		lda     TEMP_NEXT_Y                             ; F2AE A5 0A                    ..
        cmp     #$B0                            ; F2B0 C9 B0                    ..
        bcs     LF2D1                           ; F2B2 B0 1D                    ..
        and     #$0F                            ; F2B4 29 0F                    ).
        beq     LF2D1                           ; F2B6 F0 19                    ..
        
		; now check the feet
		ldy     #$02                            ; F2B8 A0 02                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F2BA 20 D3 F2                  ..
        bcs     LF2D2                           ; F2BD B0 13                    ..
        ldy     #$0E                            ; F2BF A0 0E                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F2C1 20 D3 F2                  ..
        bcs     LF2D2                           ; F2C4 B0 0C                    ..
       
        ; only check 3rd row if not aligned to x block
 	    lda     TEMP_NEXT_X_LO                           ; F2C6 A5 0E                    ..
        beq     LF2D1                           ; F2C8 F0 07                    ..
        ldy     #$1A                            ; F2CA A0 1A                    ..
        jsr     CHECK_Y_TILE_SOLID                           ; F2CC 20 D3 F2                  ..
        bcs     LF2D2                           ; F2CF B0 01                    ..
LF2D1:
        clc                                     ; F2D1 18                       .

; jump here with carry set if solid tile found
LF2D2:
        rts                                     ; F2D2 60                       `

; ----------------------------------------------------------------------------
; sets carry if tile solid (lower 6 bits >= x30), else clear it
; x40 = not solid
; xb7 = solid
; xe5 = not solid
; xf0 = solid
CHECK_Y_TILE_SOLID:
        lda     (PLAYER_MAP_TILE_PTR),y                       ; F2D3 B1 0C                    ..
        and     #$3F                            ; F2D5 29 3F                    )?
        cmp     #$30                            ; F2D7 C9 30                    .0
        rts                                     ; F2D9 60                       `


; ----------------------------------------------------------------------------
; check the player-dir bits set in f4 and respond to player location
; used by ai 4 and ENEMY_BIG_JUMP
ENEMY_AI_TRACK_PLAYER:
		; clear f6
        lda     #$00                            ; F2DA A9 00                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; F2DC 85 F6                    ..
        
		; branch if not moving horizontally
		ldx     CUR_OBJ_DX                             ; F2DE A6 F5                    ..
        beq     LF30F                           ; F2E0 F0 2D                    .-
        
		; stop horizontal movement and branch (set carry, rts) if on y block boundary
		sta     CUR_OBJ_DX                             ; F2E2 85 F5                    ..
        lda     CUR_OBJ_NEXT_Y                             ; F2E4 A5 FB                    ..
        and     #$0F                            ; F2E6 29 0F                    ).
        beq     LF347                           ; F2E8 F0 5D                    .]
        
		; branch if near top of block
		cmp     #$06                            ; F2EA C9 06                    ..
        bcc     LF302                           ; F2EC 90 14                    ..
        
		; branch if near bottom of block
		cmp     #$0B                            ; F2EE C9 0B                    ..
        bcs     LF2F5                           ; F2F0 B0 03                    ..
        
		; near middle of block
		jmp     LF347                           ; F2F2 4C 47 F3                 LG.

; ----------------------------------------------------------------------------
LF2F5:
		; branch (set carry, rts) if f4 bit 3 set
        lda     CUR_OBJ_DIR                             ; F2F5 A5 F4                    ..
        and     #$08                            ; F2F7 29 08                    ).
        bne     LF347                           ; F2F9 D0 4C                    .L
        
		; else we're moving right
		lda     #$01                            ; F2FB A9 01                    ..
        sta     CUR_OBJ_DY                             ; F2FD 85 F7                    ..
        jmp     LF343                           ; F2FF 4C 43 F3                 LC.

; ----------------------------------------------------------------------------
LF302:
		; branch (set carry, rts) if f4 bit 2 set
        lda     CUR_OBJ_DIR                             ; F302 A5 F4                    ..
        and     #$04                            ; F304 29 04                    ).
        bne     LF347                           ; F306 D0 3F                    .?
        
		; else we're moving left
		lda     #$FF                            ; F308 A9 FF                    ..
        sta     CUR_OBJ_DY                             ; F30A 85 F7                    ..
        jmp     LF343                           ; F30C 4C 43 F3                 LC.

; ----------------------------------------------------------------------------
LF30F:
        ; branch if not moving vertically
		ldx     CUR_OBJ_DY                             ; F30F A6 F7                    ..
        beq     LF347                           ; F311 F0 34                    .4
        
		; else stop moving vertically and branch (set carry, rts) if not moving horizontally
		sta     CUR_OBJ_DY                             ; F313 85 F7                    ..
        lda     CUR_OBJ_NEXT_X                             ; F315 A5 F9                    ..
        beq     LF347                           ; F317 F0 2E                    ..
        
		; branch if at left edge of block
		cmp     #$06                            ; F319 C9 06                    ..
        bcc     LF335                           ; F31B 90 18                    ..
        
		; branch if at right edge
		cmp     #$0B                            ; F31D C9 0B                    ..
        bcs     LF324                           ; F31F B0 03                    ..
        
		; near the middle (set carry, rts)
		jmp     LF347                           ; F321 4C 47 F3                 LG.

; ----------------------------------------------------------------------------
LF324:
        ; branch (set carry, rts) if f4 bit 1 set
        lda     CUR_OBJ_DIR                             ; F324 A5 F4                    ..
        and     #$02                            ; F326 29 02                    ).
        bne     LF347                           ; F328 D0 1D                    ..
        
		; otherwise, dx=1 and we clear f6 (moving right?)
		lda     #$01                            ; F32A A9 01                    ..
        sta     CUR_OBJ_DX                             ; F32C 85 F5                    ..
        lda     #$00                            ; F32E A9 00                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; F330 85 F6                    ..
        jmp     LF343                           ; F332 4C 43 F3                 LC.

; ----------------------------------------------------------------------------
LF335:
        ; branch (set carry, rts) if f4 bit 0 set
        lda     CUR_OBJ_DIR                             ; F335 A5 F4                    ..
        and     #$01                            ; F337 29 01                    ).
        bne     LF347                           ; F339 D0 0C                    ..
        
		; otherwise dx=x0F (!) and f6=xFF (moving left?)
		lda     #$0F                            ; F33B A9 0F                    ..
        sta     CUR_OBJ_DX                             ; F33D 85 F5                    ..
        lda     #$FF                            ; F33F A9 FF                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; F341 85 F6                    ..
LF343:
        jsr     OBJECT_CHECK_Y_MOVEMENT                           ; F343 20 E1 F0                  ..
        rts                                     ; F346 60                       `

; ----------------------------------------------------------------------------
LF347:
        sec                                     ; F347 38                       8
        rts                                     ; F348 60                       `

; ----------------------------------------------------------------------------
; load the boss's initial position and pattern table, meta data and life bar
INIT_BOSS:
        ; set pattern table
		lda     #$3D                            ; F349 A9 3D                    .=
        sta     CHR_BANK_SPRITES_02                             ; F34B 85 2E                    ..
        
		; set initial location
		ldy     #ENEMY_Y1                            ; F34D A0 03                    ..
        lda     (MAP_META_PTR_LO),y                         ; F34F B1 E7                    ..
        sta     TEMP_NEXT_Y                             ; F351 85 0A                    ..
        
		; advance to x location
		dey                                     ; F353 88                       .
        lda     (MAP_META_PTR_LO),y                         ; F354 B1 E7                    ..
        sta     TEMP_NEXT_X_HI                             ; F356 85 0F                    ..
        lda     #$00                            ; F358 A9 00                    ..
        sta     TEMP_NEXT_X_LO                           ; F35A 85 0E                    ..
        sta     SCRATCH_0B                             ; F35C 85 0B                    ..
        
		; finish init - technically only if boss not hitting solid tile
		; but not sure if that ever happens? it would seem to stop boss being placed if so?
		jsr     CHECK_BOSS_HIT_SOLID_TILE                           ; F35E 20 75 F2                  u.
        bcc     FINISH_BOSS_INIT                           ; F361 90 01                    ..
        rts                                     ; F363 60                       `

; ----------------------------------------------------------------------------
FINISH_BOSS_INIT:
        ; set location
		lda     TEMP_NEXT_X_LO                           ; F364 A5 0E                    ..
        sta     CUR_OBJ_NEXT_X                             ; F366 85 F9                    ..
        lda     TEMP_NEXT_X_HI                             ; F368 A5 0F                    ..
        sta     CUR_OBJ_NEXT_X_HI                             ; F36A 85 FA                    ..
        lda     TEMP_NEXT_Y                             ; F36C A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; F36E 85 FB                    ..
        
		; clear some utility values
		lda     #$00                            ; F370 A9 00                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; F372 85 F1                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; F374 85 F0                    ..
        sta     CUR_OBJ_DIR                             ; F376 85 F4                    ..
        
		; we're an enemy
		lda     #$01                            ; F378 A9 01                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; F37A 85 EE                    ..
        lda     #$81                            ; F37C A9 81                    ..
        sta     CUR_OBJ_SPRITE                             ; F37E 85 ED                    ..
        lda     #$02                            ; F380 A9 02                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F382 85 EF                    ..
        
		; set damage output
		ldy     #ENEMY_ATTACK_DAMAGE                            ; F384 A0 05                    ..
        lda     (MAP_META_PTR_LO),y                         ; F386 B1 E7                    ..
        sta     CUR_OBJ_DAMAGE                             ; F388 85 F8                    ..
        
		; all 4 boss objects get the same # of hp
		ldy     #ENEMY_HP                            ; F38A A0 04                    ..
        lda     (MAP_META_PTR_LO),y                         ; F38C B1 E7                    ..
        sta     CUR_OBJ_HP                             ; F38E 85 F2                    ..
        sta     $0415                           ; F390 8D 15 04                 ...
        sta     $0425                           ; F393 8D 25 04                 .%.
        sta     $0435                           ; F396 8D 35 04                 .5.
        
		; jump $a7e1 / INIT_CROWN_BOSS_LIFE_BAR 
		lda     #$E1                            ; F399 A9 E1                    ..
        sta     JMP_DEST_0E_LO                           ; F39B 85 0E                    ..
        lda     #$A7                            ; F39D A9 A7                    ..
        sta     JMP_DEST_0F_HI                             ; F39F 85 0F                    ..
        jsr     USE_PRG_CD                           ; F3A1 20 9C CC                  ..
        
		; jump $cb53 / DRAW_CROWN_BOSS_LIFE_BAR
		lda     #$53                            ; F3A4 A9 53                    .S
        sta     JMP_DEST_0E_LO                           ; F3A6 85 0E                    ..
        lda     #$CB                            ; F3A8 A9 CB                    ..
        sta     JMP_DEST_0F_HI                             ; F3AA 85 0F                    ..
        jsr     USE_PRG_CD                           ; F3AC 20 9C CC                  ..
        rts                                     ; F3AF 60                       `

; ----------------------------------------------------------------------------
; AI for the crown bosses; nothing special here
; boss moves either toward or away from the player but can change directions
; based on timer or when it gets obstructed. There's no RNG use.
AI_BOSS:
		; boss uses bit 7 (+/-) - clear any of that here and just keep the dpad direction
        lda     CUR_OBJ_DIR                             ; F3B0 A5 F4                    ..
        and     #$0F                            ; F3B2 29 0F                    ).
        sta     CUR_OBJ_DIR                             ; F3B4 85 F4                    ..
        
		; branch if moving
		lda     CUR_OBJ_DX                             ; F3B6 A5 F5                    ..
        ora     CUR_OBJ_DY                             ; F3B8 05 F7                    ..
        bne     LF3E8                           ; F3BA D0 2C                    .,
        
		; not moving; branch if dir is up or down
		lda     CUR_OBJ_DIR                             ; F3BC A5 F4                    ..
        and     #$03                            ; F3BE 29 03                    ).
        bne     LF3C6                           ; F3C0 D0 04                    ..
        
		; dir is not up/down - set it to right
		lda     #BTN_RIGHT                            ; F3C2 A9 01                    ..
        sta     CUR_OBJ_DIR                             ; F3C4 85 F4                    ..
LF3C6:
        ; clear the counter; branch if it wasn't 1
		ldx     CUR_OBJ_MISC_CTR                             ; F3C6 A6 F3                    ..
        lda     #$00                            ; F3C8 A9 00                    ..
        sta     CUR_OBJ_MISC_CTR                             ; F3CA 85 F3                    ..
        dex                                     ; F3CC CA                       .
        bne     LF3DC                           ; F3CD D0 0D                    ..
        
		; counter was 1; branch if dir is vertical
		lda     CUR_OBJ_DIR                             ; F3CF A5 F4                    ..
        and     #$03                            ; F3D1 29 03                    ).
        beq     LF3EE                           ; F3D3 F0 19                    ..
        
		; otherwise, reverse right/left and store
		eor     #$03                            ; F3D5 49 03                    I.
        sta     CUR_OBJ_DIR                             ; F3D7 85 F4                    ..
        jmp     LF3F5                           ; F3D9 4C F5 F3                 L..

; ----------------------------------------------------------------------------
LF3DC:
        ; move away from player?
		jsr     ENEMY_RESPOND_TO_PLAYER_LOC                           ; F3DC 20 19 EE                  ..
        
		; set dir bit 7 - may trigger BOSS_BIG_JUMP below
		; note: CUR_OBJ_DIR is usually only the lower nibble
		lda     #$80                            ; F3DF A9 80                    ..
        ora     CUR_OBJ_DIR                             ; F3E1 05 F4                    ..
        sta     CUR_OBJ_DIR                             ; F3E3 85 F4                    ..
        jmp     LF3F5                           ; F3E5 4C F5 F3                 L..

; ----------------------------------------------------------------------------
LF3E8:
		; branch (don't reset ctr and respond to player) if ctr < x32
        lda     CUR_OBJ_MISC_CTR                             ; F3E8 A5 F3                    ..
        cmp     #$32                            ; F3EA C9 32                    .2
        bcc     LF3F5                           ; F3EC 90 07                    ..
LF3EE:
		; reset ctr, react to player
        lda     #$00                            ; F3EE A9 00                    ..
        sta     CUR_OBJ_MISC_CTR                             ; F3F0 85 F3                    ..
        jsr     ENEMY_RESPOND_TO_PLAYER_LOC                           ; F3F2 20 19 EE                  ..
LF3F5:
        ; get our move vector, speed=2
		lda     CUR_OBJ_DIR                             ; F3F5 A5 F4                    ..
        ldy     #$02                            ; F3F7 A0 02                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; F3F9 20 70 CD                  p.
        
		; branch if falling
		lda     CUR_OBJ_FALL_SPEED                             ; F3FC A5 F0                    ..
        bne     LF41C                           ; F3FE D0 1C                    ..
        
		; branch if rising
		lda     CUR_OBJ_RISE_SPEED                             ; F400 A5 F1                    ..
        bne     LF408                           ; F402 D0 04                    ..
        
		; branch if bit 7 on dir clear (set above via LF3DC branch)
		lda     CUR_OBJ_DIR                             ; F404 A5 F4                    ..
        bpl     LF40D                           ; F406 10 05                    ..
LF408:
		; bit 7 set - use movement_2 routine and branch if unobstructed
        jsr     BOSS_BIG_JUMP                           ; F408 20 E3 F4                  ..
        bcc     LF421                           ; F40B 90 14                    ..
LF40D:
        ; if obstructed, try again without rising
		lda     #$00                            ; F40D A9 00                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; F40F 85 F1                    ..
        jsr     BOSS_MOVE_AND_CHECK_INTERACTIONS                           ; F411 20 06 F5                  ..
        bcc     LF421                           ; F414 90 0B                    ..
        
		; if still obstructed, freeze and finish
		jsr     FREEZE_ENEMY                           ; F416 20 11 EF                  ..
        jmp     LF424                           ; F419 4C 24 F4                 L$.

; ----------------------------------------------------------------------------
LF41C:
        ; plot a move and branch if obstructed; else move and finish
		jsr     BOSS_SET_MOVEMENT                           ; F41C 20 C3 F4                  ..
        bcs     LF424                           ; F41F B0 03                    ..
LF421:
        jsr     APPLY_CALC_POS_TO_CUR_OBJ                           ; F421 20 04 EF                  ..
LF424:
        jsr     BOSS_CHECK_MOVEMENT                           ; F424 20 E4 F1                  ..
        jsr     BOSS_CHECK_HORIZONTAL_FLIP                           ; F427 20 3B F5                  ;.
        jsr     BOSS_ANIMATE_SPRITE                           ; F42A 20 52 F5                  R.
        jmp     RTS_LEFF0                           ; F42D 4C F0 EF                 L..

; ----------------------------------------------------------------------------
; see UPDATE_DYING_ENEMY for the non-boss version
KILL_BOSS_ENEMY:
        ; branch if any of lower 7 bits set - will be the case on 2nd call 
		lda     CUR_OBJ_GEN_TYPE                             ; F430 A5 EE                    ..
        and     #$7F                            ; F432 29 7F                    ).
        bne     LF473                           ; F434 D0 3D                    .=
        
		; first time through - cross/flash
		lda     #SOUND_CROSS                            ; F436 A9 18                    ..
        sta     NEXT_SOUND_EFFECT                             ; F438 85 8F                    ..
        lda     #$FF                            ; F43A A9 FF                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; F43C 85 90                    ..
        ldx     #$03                            ; F43E A2 03                    ..
        jsr     FLASH_EFFECT_C540                           ; F440 20 40 C5                  @.
        lda     #$02                            ; F443 A9 02                    ..
        sta     NMI_WAIT_CTR                             ; F445 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; F447 20 35 C1                  5.
        ldx     #$03                            ; F44A A2 03                    ..
        jsr     FLASH_EFFECT_C540                           ; F44C 20 40 C5                  @.
        lda     #$05                            ; F44F A9 05                    ..
        sta     NMI_WAIT_CTR                             ; F451 85 36                    .6
        jsr     NMI_CLEAR_FLAGS_AND_WAIT                           ; F453 20 35 C1                  5.
        ldx     #$03                            ; F456 A2 03                    ..
        jsr     FLASH_EFFECT_C540                           ; F458 20 40 C5                  @.
        inc     a:CUR_OBJ_GEN_TYPE                           ; F45B EE EE 00                 ...
        lda     #SOUND_02                            ; F45E A9 02                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; F460 8D 8F 00                 ...
        
		; bounce dying boss up
		lda     #$0F                            ; F463 A9 0F                    ..
        sta     CUR_OBJ_RISE_SPEED                             ; F465 85 F1                    ..
        
		; clean-up
		lda     #$00                            ; F467 A9 00                    ..
        sta     CUR_OBJ_DX                             ; F469 85 F5                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; F46B 85 F6                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; F46D 85 F0                    ..
        lda     CUR_OBJ_NEXT_Y                             ; F46F A5 FB                    ..
        sta     CUR_OBJ_PROJECTILE_WIGGLE                             ; F471 85 FC                    ..
LF473:
        ; branch if already falling
		lda     CUR_OBJ_FALL_SPEED                             ; F473 A5 F0                    ..
        bne     BOSS_UPDATE_DESCENT                           ; F475 D0 27                    .'
        
		; not falling; decelerate upward movement and branch if 0
		dec     CUR_OBJ_RISE_SPEED                             ; F477 C6 F1                    ..
        beq     BOSS_START_DESCENT                           ; F479 F0 18                    ..
        
		; handle movement
		lda     CUR_OBJ_RISE_SPEED                             ; F47B A5 F1                    ..
        lsr     a                               ; F47D 4A                       J
        lsr     a                               ; F47E 4A                       J
        eor     #$FF                            ; F47F 49 FF                    I.
        clc                                     ; F481 18                       .
        adc     #$01                            ; F482 69 01                    i.
        sta     CUR_OBJ_DY                             ; F484 85 F7                    ..
        jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; F486 20 F1 EF                  ..
        
		; force descent if rising offscreen
		jsr     CHECK_OBJECT_OFFSCREEN                           ; F489 20 08 CF                  ..
        bcs     BOSS_START_DESCENT                           ; F48C B0 05                    ..
        
		; otherwise, accept y movement
		lda     TEMP_NEXT_Y                             ; F48E A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; F490 85 FB                    ..
        rts                                     ; F492 60                       `

; ----------------------------------------------------------------------------
; start the boss falling
BOSS_START_DESCENT:
		; flip upside down and set CUR_OBJ_FALL_SPEED
        lda     CUR_OBJ_SPRITE_FLAGS                             ; F493 A5 EF                    ..
        ora     #$80                            ; F495 09 80                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F497 85 EF                    ..
        lda     #$01                            ; F499 A9 01                    ..
        sta     CUR_OBJ_FALL_SPEED                             ; F49B 85 F0                    ..
        rts                                     ; F49D 60                       `

; ----------------------------------------------------------------------------
; accelerate downward and end the boss fight when offscreen
BOSS_UPDATE_DESCENT:
        inc     CUR_OBJ_FALL_SPEED                             ; F49E E6 F0                    ..
        lda     CUR_OBJ_FALL_SPEED                             ; F4A0 A5 F0                    ..
        lsr     a                               ; F4A2 4A                       J
        lsr     a                               ; F4A3 4A                       J
        clc                                     ; F4A4 18                       .
        adc     #$01                            ; F4A5 69 01                    i.
        sta     CUR_OBJ_DY                             ; F4A7 85 F7                    ..
        jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; F4A9 20 F1 EF                  ..
        
		; branch if offscreen - boss fight over
		jsr     CHECK_OBJECT_OFFSCREEN                           ; F4AC 20 08 CF                  ..
		bcs     BOSS_FIGHT_OVER                           ; F4AF B0 05                    ..
        
		; otherwise, apply new y pos
		lda     TEMP_NEXT_Y                             ; F4B1 A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; F4B3 85 FB                    ..
        rts                                     ; F4B5 60                       `

; ----------------------------------------------------------------------------
; cleanup the boss object and set BOSS_FIGHT_OVER_FLAG
BOSS_FIGHT_OVER:
        lda     #$00                            ; F4B6 A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; F4B8 85 EE                    ..
        lda     #$F0                            ; F4BA A9 F0                    ..
        sta     CUR_OBJ_MISC_CTR                             ; F4BC 85 F3                    ..
        
		; set BOSS_FIGHT_OVER_FLAG
		lda     #$01                            ; F4BE A9 01                    ..
        sta     BOSS_FIGHT_OVER_FLAG                             ; F4C0 85 EB                    ..
        rts                                     ; F4C2 60                       `

; ----------------------------------------------------------------------------
; apply gravity, check any interactions
BOSS_SET_MOVEMENT:
        lda     CUR_OBJ_FALL_SPEED                             ; F4C3 A5 F0                    ..
        lsr     a                               ; F4C5 4A                       J
        lsr     a                               ; F4C6 4A                       J
        clc                                     ; F4C7 18                       .
        adc     #$01                            ; F4C8 69 01                    i.
        sta     CUR_OBJ_DY                             ; F4CA 85 F7                    ..
        
		; check interactions and branch if obstructed
		jsr     BOSS_MOVE_AND_CHECK_INTERACTIONS                           ; F4CC 20 06 F5                  ..
        bcs     LF4D2                           ; F4CF B0 01                    ..
        rts                                     ; F4D1 60                       `

; ----------------------------------------------------------------------------
LF4D2:
        ; original movement obstructed - clear horizontal movement and try just vertical
		lda     #$00                            ; F4D2 A9 00                    ..
        sta     CUR_OBJ_DX                             ; F4D4 85 F5                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; F4D6 85 F6                    ..
        
		; branch if obstructed in y
		jsr     OBJECT_CHECK_Y_MOVEMENT                           ; F4D8 20 E1 F0                  ..
        bcs     LF4DE                           ; F4DB B0 01                    ..
        rts                                     ; F4DD 60                       `

; ----------------------------------------------------------------------------
LF4DE:
        ; still obstructed; clear dy as well
		lda     #$00                            ; F4DE A9 00                    ..
        sta     CUR_OBJ_DY                             ; F4E0 85 F7                    ..
        rts                                     ; F4E2 60                       `

; ----------------------------------------------------------------------------
; boss takes a big jump - triggered above when bit 7 set on dir
BOSS_BIG_JUMP:
        ; branch if rising
		ldx     CUR_OBJ_RISE_SPEED                             ; F4E3 A6 F1                    ..
        bne     LF4E9                           ; F4E5 D0 02                    ..
        
		; big jump!
		ldx     #$19                            ; F4E7 A2 19                    ..
LF4E9:
        dex                                     ; F4E9 CA                       .
        stx     CUR_OBJ_RISE_SPEED                             ; F4EA 86 F1                    ..
        txa                                     ; F4EC 8A                       .
        lsr     a                               ; F4ED 4A                       J
        lsr     a                               ; F4EE 4A                       J
        eor     #$FF                            ; F4EF 49 FF                    I.
        clc                                     ; F4F1 18                       .
        adc     #$01                            ; F4F2 69 01                    i.
        sta     CUR_OBJ_DY                             ; F4F4 85 F7                    ..
        
		; check interactions and branch if obstructed
		jsr     BOSS_MOVE_AND_CHECK_INTERACTIONS                           ; F4F6 20 06 F5                  ..
        bcs     LF4FC                           ; F4F9 B0 01                    ..
        rts                                     ; F4FB 60                       `

; ----------------------------------------------------------------------------
LF4FC:
		; clear dx and try with just y movement
        lda     #$00                            ; F4FC A9 00                    ..
        sta     CUR_OBJ_DX                             ; F4FE 85 F5                    ..
        sta     CUR_OBJ_HORIZ_DIR                             ; F500 85 F6                    ..
        jsr     BOSS_MOVE_AND_CHECK_INTERACTIONS                           ; F502 20 06 F5                  ..
        rts                                     ; F505 60                       `

; ----------------------------------------------------------------------------
; calculate the boss's movement and check for interactions - OOB, hit player/projectile/solid tiles
BOSS_MOVE_AND_CHECK_INTERACTIONS:
        ; store original dy
		lda     CUR_OBJ_DY                             ; F506 A5 F7                    ..
        pha                                     ; F508 48                       H
LF509:
        ; branch if going offscreen
		jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; F509 20 F1 EF                  ..
        jsr     CHECK_OBJECT_OFFSCREEN                           ; F50C 20 08 CF                  ..
        bcs     LF52E                           ; F50F B0 1D                    ..
        
		; branch if not hitting player
		jsr     CHECK_BOSS_PLAYER_PROXIMITY                           ; F511 20 C7 CE                  ..
        bcc     LF519                           ; F514 90 03                    ..
        
		; handle hitting player
		jsr     ENEMY_OR_PROJECTILE_HIT_PLAYER                           ; F516 20 36 F1                  6.
LF519:
        ; branch if not hitting solid tile
		jsr     CHECK_BOSS_HIT_SOLID_TILE                           ; F519 20 75 F2                  u.
        bcc     LF537                           ; F51C 90 19                    ..
        
		; brancch if dy=0
		ldx     CUR_OBJ_DY                             ; F51E A6 F7                    ..
        beq     LF536                           ; F520 F0 14                    ..
        
		; branch if dy=negative
		bmi     LF526                           ; F522 30 02                    0.
        
		; adjust dy to try to avoid obstruction
		dex                                     ; F524 CA                       .
        dex                                     ; F525 CA                       .
LF526:
        inx                                     ; F526 E8                       .
        stx     CUR_OBJ_DY                             ; F527 86 F7                    ..
        bne     LF509                           ; F529 D0 DE                    ..
        
		; dy=0 and still obstructed; set carry and rts
		jmp     LF536                           ; F52B 4C 36 F5                 L6.

; ----------------------------------------------------------------------------
LF52E:
        ; Moved OOB - clear object, set respawn ctr - should never happen for boss?
		lda     #OBJ_GEN_TYPE_BLANK                            ; F52E A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; F530 85 EE                    ..
        lda     #$F0                            ; F532 A9 F0                    ..
        sta     CUR_OBJ_MISC_CTR                             ; F534 85 F3                    ..
LF536:
        sec                                     ; F536 38                       8
LF537:
        pla                                     ; F537 68                       h
        sta     CUR_OBJ_DY                             ; F538 85 F7                    ..
        rts                                     ; F53A 60                       `

; ----------------------------------------------------------------------------
; set horizontal flip if needed for the current (boss) object
BOSS_CHECK_HORIZONTAL_FLIP:
        ; default - no horizontal flip
		ldy     #$00                            ; F53B A0 00                    ..
        
		; branch (no horizontal flip) if moving left 
		lda     CUR_OBJ_HORIZ_DIR                             ; F53D A5 F6                    ..
        bmi     LF547                           ; F53F 30 06                    0.
        
		; otherwise, set horizontal flip if CUR_OBJ_DX <> 0
		lda     CUR_OBJ_DX                             ; F541 A5 F5                    ..
        beq     LF551                           ; F543 F0 0C                    ..
        ldy     #$40                            ; F545 A0 40                    .@
LF547:
        sty     SCRATCH_08                             ; F547 84 08                    ..
        lda     CUR_OBJ_SPRITE_FLAGS                             ; F549 A5 EF                    ..
        and     #$3F                            ; F54B 29 3F                    )?
        ora     SCRATCH_08                             ; F54D 05 08                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F54F 85 EF                    ..
LF551:
        rts                                     ; F551 60                       `

; ----------------------------------------------------------------------------
BOSS_ANIMATE_SPRITE:
        inc     CUR_OBJ_MISC_CTR                             ; F552 E6 F3                    ..
        
		; bits 2-3 of misc ctr * 2 are added to x41 to animate the boss sprite
		; options are therefore: x41, x49, x51, x59
		lda     CUR_OBJ_MISC_CTR                             ; F554 A5 F3                    ..
        and     #$0C                            ; F556 29 0C                    ).
        asl     a                               ; F558 0A                       .
        ora     #$41                            ; F559 09 41                    .A
        sta     CUR_OBJ_SPRITE                             ; F55B 85 ED                    ..
        rts                                     ; F55D 60                       `

; ----------------------------------------------------------------------------
; for boss - save to the extra 3 rows in the objects array
SAVE_CUR_OBJ_EXTRA_BOSS_PARTS:
        ; if the top/left boss part wiggles being hit by projectile, the whole boss wiggles!
		lda     CUR_OBJ_PROJECTILE_WIGGLE                             ; F55E A5 FC                    ..
        sta     OBJ_PROJECTILE_WIGGLE+$10                           ; F560 8D 1F 04                 ...
        sta     OBJ_PROJECTILE_WIGGLE+$20                           ; F563 8D 2F 04                 ./.
        sta     OBJ_PROJECTILE_WIGGLE+$30                           ; F566 8D 3F 04                 .?.
        
		; bottom 2 parts have y plus x10
		lda     CUR_OBJ_NEXT_Y                             ; F569 A5 FB                    ..
        sta     OBJ_Y+$10                           ; F56B 8D 1E 04                 ...
        clc                                     ; F56E 18                       .
        adc     #$10                            ; F56F 69 10                    i.
        sta     OBJ_Y+$20                           ; F571 8D 2E 04                 ...
        sta     OBJ_Y+$30                           ; F574 8D 3E 04                 .>.
        
		; x pos - right parts have x hi + 1
		lda     CUR_OBJ_NEXT_X                             ; F577 A5 F9                    ..
        sta     OBJ_1_X_LO                           ; F579 8D 1C 04                 ...
        sta     OBJ_2_X_LO                           ; F57C 8D 2C 04                 .,.
        sta     OBJ_3_X_LO                           ; F57F 8D 3C 04                 .<.
        ldx     CUR_OBJ_NEXT_X_HI                             ; F582 A6 FA                    ..
        stx     OBJ_2_X_HI                           ; F584 8E 2D 04                 .-.
        inx                                     ; F587 E8                       .
        stx     OBJ_1_X_HI                           ; F588 8E 1D 04                 ...
        stx     OBJ_3_X_HI                           ; F58B 8E 3D 04                 .=.
        
		; branch if negative lifecycle
		ldx     CUR_OBJ_GEN_TYPE                             ; F58E A6 EE                    ..
        bmi     LF59F                           ; F590 30 0D                    0.
        
		; first boss part is alive; branch if all other boss parts also still alive
		lda     OBJ_1_GEN_TYPE                           ; F592 AD 11 04                 ...
        ora     OBJ_2_GEN_TYPE                           ; F595 0D 21 04                 .!.
        ora     OBJ_3_GEN_TYPE                           ; F598 0D 31 04                 .1.
        bpl     LF59F                           ; F59B 10 02                    ..
        
		; one boss part is dead; kill the rest, too!
		ldx     #OBJ_GEN_TYPE_ENEMY_JUST_KILLED                            ; F59D A2 80                    ..
LF59F:
        stx     OBJ_GENERAL_TYPE                           ; F59F 8E 01 04                 ...
        stx     OBJ_1_GEN_TYPE                           ; F5A2 8E 11 04                 ...
        stx     OBJ_2_GEN_TYPE                           ; F5A5 8E 21 04                 .!.
        stx     OBJ_3_GEN_TYPE                           ; F5A8 8E 31 04                 .1.
        
		; here, we compare each part's hp and will store the lowest to OBJ_HP (part 0's)
		lda     CUR_OBJ_HP                             ; F5AB A5 F2                    ..
        cmp     OBJ_HP+$10                           ; F5AD CD 15 04                 ...
        bcc     LF5B5                           ; F5B0 90 03                    ..
        lda     OBJ_HP+$10                           ; F5B2 AD 15 04                 ...
LF5B5:
        cmp     OBJ_HP+$20                           ; F5B5 CD 25 04                 .%.
        bcc     LF5BD                           ; F5B8 90 03                    ..
        lda     OBJ_HP+$20                           ; F5BA AD 25 04                 .%.
LF5BD:
        cmp     OBJ_HP+$30                           ; F5BD CD 35 04                 .5.
        bcc     LF5C5                           ; F5C0 90 03                    ..
        lda     OBJ_HP+$30                           ; F5C2 AD 35 04                 .5.
LF5C5:
        sta     OBJ_HP                           ; F5C5 8D 05 04                 ...
        
		; coordinate sprite animations
		lda     CUR_OBJ_SPRITE                             ; F5C8 A5 ED                    ..
        ora     #$04                            ; F5CA 09 04                    ..
        sta     OBJ_1_SPRITE                           ; F5CC 8D 10 04                 ...
        ora     #$20                            ; F5CF 09 20                    . 
        sta     OBJ_3_SPRITE                           ; F5D1 8D 30 04                 .0.
        and     #$FB                            ; F5D4 29 FB                    ).
        sta     OBJ_2_SPRITE                           ; F5D6 8D 20 04                 . .
        
		; copy sprite flags
		lda     CUR_OBJ_SPRITE_FLAGS                             ; F5D9 A5 EF                    ..
        sta     OBJ_1_SPRITE_FLAGS                           ; F5DB 8D 12 04                 ...
        sta     OBJ_2_SPRITE_FLAGS                           ; F5DE 8D 22 04                 .".
        sta     OBJ_3_SPRITE_FLAGS                           ; F5E1 8D 32 04                 .2.
        
		; branch if not horizontally flipped
		and     #$40                            ; F5E4 29 40                    )@
        beq     LF600                           ; F5E6 F0 18                    ..
        
		; horizontally flipped
		lda     OBJ_SPRITE                           ; F5E8 AD 00 04                 ...
        ldx     OBJ_1_SPRITE                           ; F5EB AE 10 04                 ...
        sta     OBJ_1_SPRITE                           ; F5EE 8D 10 04                 ...
        stx     OBJ_SPRITE                           ; F5F1 8E 00 04                 ...
        lda     OBJ_2_SPRITE                           ; F5F4 AD 20 04                 . .
        ldx     OBJ_3_SPRITE                           ; F5F7 AE 30 04                 .0.
        sta     OBJ_3_SPRITE                           ; F5FA 8D 30 04                 .0.
        stx     OBJ_2_SPRITE                           ; F5FD 8E 20 04                 . .
LF600:
		; branch if not vertically flipped
        lda     CUR_OBJ_SPRITE_FLAGS                             ; F600 A5 EF                    ..
        bpl     LF61C                           ; F602 10 18                    ..
        
		; vertically flipped
		lda     OBJ_SPRITE                           ; F604 AD 00 04                 ...
        ldx     OBJ_2_SPRITE                           ; F607 AE 20 04                 . .
        sta     OBJ_2_SPRITE                           ; F60A 8D 20 04                 . .
        stx     OBJ_SPRITE                           ; F60D 8E 00 04                 ...
        lda     OBJ_1_SPRITE                           ; F610 AD 10 04                 ...
        ldx     OBJ_3_SPRITE                           ; F613 AE 30 04                 .0.
        sta     OBJ_3_SPRITE                           ; F616 8D 30 04                 .0.
        stx     OBJ_1_SPRITE                           ; F619 8E 10 04                 ...
LF61C:
        ; $cb53 / DRAW_CROWN_BOSS_LIFE_BAR
		lda     #$53                            ; F61C A9 53                    .S
        sta     JMP_DEST_0E_LO                           ; F61E 85 0E                    ..
        lda     #$CB                            ; F620 A9 CB                    ..
        sta     JMP_DEST_0F_HI                             ; F622 85 0F                    ..
        jsr     USE_PRG_CD                           ; F624 20 9C CC                  ..
        rts                                     ; F627 60                       `

; ----------------------------------------------------------------------------
; check if the player fires a projectile
HANDLE_PLAYER_FIRING:
        lda     #$0B                            ; F628 A9 0B                    ..
        sta     CUR_OBJ_SLOT_NUM                             ; F62A 85 E3                    ..
        
		; cur object: $04B0
		lda     #$B0                            ; F62C A9 B0                    ..
        sta     CUR_OBJ_PTR_LO                             ; F62E 85 E5                    ..
        lda     #$04                            ; F630 A9 04                    ..
        sta     CUR_OBJ_PTR_HI                             ; F632 85 E6                    ..
LF634:
		; branch if slot is not blank (checking OBJ_GEN_TYPE)
        ldy     #$01                            ; F634 A0 01                    ..
        lda     (CUR_OBJ_PTR_LO),y                         ; F636 B1 E5                    ..
		bne     LF648                           ; F638 D0 0E                    ..
        
		; slot is blank
		; branch if B not pressed (bit 6 --> overflow)
		bit     JOYPAD_INPUT                             ; F63A 24 20                    $ 
        bvc     LF64B                           ; F63C 50 0D                    P.
        
		; b pressed
		; branch (no fire) if B was also pressed in the reference copy of input
		bit     JOYPAD_INPUT_REFERENCE                             ; F63E 24 FD                    $.
        bvs     LF64B                           ; F640 70 09                    p.
        
		; b has been newly pressed; we can fire
		jsr     CREATE_PLAYER_PROJECTILE                           ; F642 20 64 F6                  d.
        jmp     LF64B                           ; F645 4C 4B F6                 LK.

; ----------------------------------------------------------------------------
LF648:
        jsr     PLAYER_UPDATE_PROJECTILE                           ; F648 20 BB F6                  ..
LF64B:
		; advance slot, limited by player config PLAYER_MAX_SHOTS
        inc     CUR_OBJ_SLOT_NUM                             ; F64B E6 E3                    ..
        clc                                     ; F64D 18                       .
        lda     #$10                            ; F64E A9 10                    ..
        adc     CUR_OBJ_PTR_LO                             ; F650 65 E5                    e.
        sta     CUR_OBJ_PTR_LO                             ; F652 85 E5                    ..
        lda     #$00                            ; F654 A9 00                    ..
        adc     CUR_OBJ_PTR_HI                             ; F656 65 E6                    e.
        sta     CUR_OBJ_PTR_HI                             ; F658 85 E6                    ..
        
		; loop (try again) if CUR_OBJ_SLOT_NUM - x0B < PLAYER_MAX_SHOTS
		lda     CUR_OBJ_SLOT_NUM                             ; F65A A5 E3                    ..
        sec                                     ; F65C 38                       8
        sbc     #$0B                            ; F65D E9 0B                    ..
        cmp     PLAYER_MAX_SHOTS                             ; F65F C5 5E                    .^
        bcc     LF634                           ; F661 90 D1                    ..
        rts                                     ; F663 60                       `

; ----------------------------------------------------------------------------
; creates a player projectile and plays the appropriate sound
CREATE_PLAYER_PROJECTILE:
		; load a working object
        jsr     LOAD_CUR_OBJ                           ; F664 20 8F E9                  ..
        
		; if B currently pressed, save it to the reference copy
		lda     JOYPAD_INPUT                             ; F667 A5 20                    . 
        and     #BTN_B                            ; F669 29 40                    )@
        ora     JOYPAD_INPUT_REFERENCE                             ; F66B 05 FD                    ..
        sta     JOYPAD_INPUT_REFERENCE                             ; F66D 85 FD                    ..
        ldy     #$02                            ; F66F A0 02                    ..
        
		; branch if no speed scroll active (projectile speed=2)
		lda     CTR_SPEED_SCROLL_1                             ; F671 A5 88                    ..
        beq     LF677                           ; F673 F0 02                    ..
        
		; if any # of scrolls are active, projectile speed=4
		ldy     #$04                            ; F675 A0 04                    ..
LF677:
		; dir is based on most recent dpad input
        lda     JOYPAD_INPUT_REFERENCE                             ; F677 A5 FD                    ..
        jsr     CALC_CUR_OBJ_MOVE_VECTOR                           ; F679 20 70 CD                  p.
        jsr     PLAYER_PROJECTILE_INITIAL_LOC                           ; F67C 20 40 F7                  @.
        
		; don't fire if going offscreen
		jsr     CHECK_OBJECT_OFFSCREEN                           ; F67F 20 08 CF                  ..
        bcs     LF6B8                           ; F682 B0 34                    .4
        
		; otherwise, use magic - branch if empty
		jsr     DECREMENT_PLAYER_MAGIC                           ; F684 20 F0 E7                  ..
		bcs     LF6B8                           ; F687 B0 2F                    ./
        
		; we had magic
		lda     TEMP_NEXT_X_LO                           ; F689 A5 0E                    ..
        sta     CUR_OBJ_NEXT_X                             ; F68B 85 F9                    ..
        lda     TEMP_NEXT_X_HI                             ; F68D A5 0F                    ..
        sta     CUR_OBJ_NEXT_X_HI                             ; F68F 85 FA                    ..
        lda     TEMP_NEXT_Y                             ; F691 A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; F693 85 FB                    ..
        
		; branch if no extra magic used for rod
		; interestingly - the shot length is saved for each projectile to CUR_OBJ_GEN_TYPE
		; PLAYER_UPDATE_PROJECTILE then decrements that each frame
		jsr     CALC_PLAYER_SHOT_LENGTH                           ; F695 20 67 D0                  g.
        sta     CUR_OBJ_GEN_TYPE                             ; F698 85 EE                    ..
        bcs     LF69F                           ; F69A B0 03                    ..
        
		; extra magic for rod use
		jsr     DECREMENT_PLAYER_MAGIC                           ; F69C 20 F0 E7                  ..
LF69F:
		; branch if no extra magic used for knuckle
        jsr     CALC_PLAYER_SHOT_POWER                           ; F69F 20 51 D0                  Q.
        sta     CUR_OBJ_DAMAGE                             ; F6A2 85 F8                    ..
        bcs     LF6A9                           ; F6A4 B0 03                    ..
        
		; extra magic for knuckle
		jsr     DECREMENT_PLAYER_MAGIC                           ; F6A6 20 F0 E7                  ..
LF6A9:
		; prep appearance
        lda     #$00                            ; F6A9 A9 00                    ..
        sta     CUR_OBJ_SPRITE_FLAGS                             ; F6AB 85 EF                    ..
        lda     #$21                            ; F6AD A9 21                    .!
        sta     CUR_OBJ_SPRITE                             ; F6AF 85 ED                    ..
        
		; shot sound effect for player
		lda     #SOUND_DAD_SHOT                            ; F6B1 A9 22                    ."
        clc                                     ; F6B3 18                       .
        adc     PLAYER_ID                             ; F6B4 65 40                    e@
        sta     NEXT_SOUND_EFFECT                             ; F6B6 85 8F                    ..
LF6B8:
        jmp     LF735                           ; F6B8 4C 35 F7                 L5.

; ----------------------------------------------------------------------------
PLAYER_UPDATE_PROJECTILE:
        ; load projectile's data and branch if shot is finished
		; CUR_OBJ_GEN_TYPE is used as a shot length counter; we don't need the type
		; b/c projectiles only live in slots b-d
		jsr     LOAD_CUR_OBJ                           ; F6BB 20 8F E9                  ..
        dec     CUR_OBJ_GEN_TYPE                             ; F6BE C6 EE                    ..
        beq     LF735                           ; F6C0 F0 73                    .s
        
		; shot still going...branch if offscreen (end shot)
		jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; F6C2 20 F1 EF                  ..
        jsr     CHECK_OBJECT_OFFSCREEN                           ; F6C5 20 08 CF                  ..
        bcs     LF722                           ; F6C8 B0 58                    .X
        
		; branch if we didn't hit something
		jsr     CHECK_TEMP_POS_HIT_OBJECT                           ; F6CA 20 B2 CD                  ..
        bcc     LF729                           ; F6CD 90 5A                    .Z
        
		; we did
		; SCRATCH_08 = slot #, SCRATCH_09 = offset to enemy (slot*16)
		; branch if not boss
		lda     CHR_BANK_ENEMY_SPRITES                             ; F6CF A5 2D                    .-
        cmp     #SPRITE_PT_TARATUNES                          ; F6D1 C9 30                    .0
        bcc     LF6ED                           ; F6D3 90 18                    ..
        
		; branch if slot < 4 - we hit the boss
		lda     SCRATCH_08                             ; F6D5 A5 08                    ..
        cmp     #$04                            ; F6D7 C9 04                    ..
        bcc     LF6ED                           ; F6D9 90 12                    ..
        
		; slot >= 4 hit - boss projectile: kill it and play sound
		ldx     SCRATCH_09                             ; F6DB A6 09                    ..
        lda     #OBJ_GEN_TYPE_ENEMY_JUST_KILLED                            ; F6DD A9 80                    ..
        sta     OBJ_GENERAL_TYPE,x                         ; F6DF 9D 01 04                 ...
        
		lda     #$01                            ; F6E2 A9 01                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; F6E4 85 EE                    ..
        lda     #SOUND_EQUIP_SELECT_TICK                            ; F6E6 A9 0C                    ..
        sta     NEXT_SOUND_EFFECT                             ; F6E8 85 8F                    ..
        jmp     LF71F                           ; F6EA 4C 1F F7                 L..

; ----------------------------------------------------------------------------
LF6ED:
        ; branch if object we hit is not an enemy
		ldy     OBJ_GENERAL_TYPE,x                         ; F6ED BC 01 04                 ...
        dey                                     ; F6F0 88                       .
        bne     LF729                           ; F6F1 D0 36                    .6
        
		; x = enemy slot we hit
		ldx     SCRATCH_09                             ; F6F3 A6 09                    ..
        
		; branch (y=xFE or -2) if cur obj gen type is an even value
		lda     CUR_OBJ_GEN_TYPE                             ; F6F5 A5 EE                    ..
        ldy     #$FE                            ; F6F7 A0 FE                    ..
        and     #$01                            ; F6F9 29 01                    ).
        beq     LF6FF                           ; F6FB F0 02                    ..
        
		; odd value (y=2); this makes it wiggle left/right while being hit
		ldy     #$02                            ; F6FD A0 02                    ..
LF6FF:
        tya                                     ; F6FF 98                       .
        sta     OBJ_PROJECTILE_WIGGLE,x                         ; F700 9D 0F 04                 ...
        
		; apply damage
		lda     OBJ_HP,x                         ; F703 BD 05 04                 ...
        sec                                     ; F706 38                       8
        sbc     CUR_OBJ_DAMAGE                             ; F707 E5 F8                    ..
        sta     OBJ_HP,x                         ; F709 9D 05 04                 ...
        
		; branch (play sound) if object still has hp
		bcs     LF71B                           ; F70C B0 0D                    ..
        
		; otherwise kill it
		lda     #OBJ_GEN_TYPE_ENEMY_JUST_KILLED                            ; F70E A9 80                    ..
        sta     OBJ_GENERAL_TYPE,x                         ; F710 9D 01 04                 ...
        lda     #$00                            ; F713 A9 00                    ..
        sta     OBJ_HP,x                         ; F715 9D 05 04                 ...
        jmp     LF71F                           ; F718 4C 1F F7                 L..

; ----------------------------------------------------------------------------
LF71B:
		; play sound - enemy damaged but not killed
        lda     #SOUND_OPEN_DOOR                         ; F71B A9 06                    ..
        sta     NEXT_SOUND_EFFECT                             ; F71D 85 8F                    ..
LF71F:
        jmp     LF729                           ; F71F 4C 29 F7                 L).

; ----------------------------------------------------------------------------
LF722:
		; we went offscreen; erase
        lda     #$00                            ; F722 A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; F724 85 EE                    ..
        jmp     LF735                           ; F726 4C 35 F7                 L5.

; ----------------------------------------------------------------------------
LF729:
        ; move
		lda     TEMP_NEXT_X_LO                           ; F729 A5 0E                    ..
        sta     CUR_OBJ_NEXT_X                             ; F72B 85 F9                    ..
        lda     TEMP_NEXT_X_HI                             ; F72D A5 0F                    ..
        sta     CUR_OBJ_NEXT_X_HI                             ; F72F 85 FA                    ..
        lda     TEMP_NEXT_Y                             ; F731 A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; F733 85 FB                    ..
LF735:
        ; branch if shot is done with
		lda     CUR_OBJ_GEN_TYPE                             ; F735 A5 EE                    ..
        beq     LF73C                           ; F737 F0 03                    ..
        
		; else animate
		jsr     ANIMATE_PLAYER_PROJECTILE                           ; F739 20 73 F7                  s.
LF73C:
        jsr     SAVE_CUR_OBJ                           ; F73C 20 9A E9                  ..
        rts                                     ; F73F 60                       `

; ----------------------------------------------------------------------------
; sets the initial location for player projectile, 1 movement in the last direction
; player pointed with the dpad
PLAYER_PROJECTILE_INITIAL_LOC:
        lda     PX_LO                             ; F740 A5 43                    .C
        sta     TEMP_NEXT_X_LO                           ; F742 85 0E                    ..
        lda     PX_HI                             ; F744 A5 44                    .D
        sta     TEMP_NEXT_X_HI                             ; F746 85 0F                    ..
        lda     PY                             ; F748 A5 45                    .E
        sta     TEMP_NEXT_Y                             ; F74A 85 0A                    ..
        lda     CUR_OBJ_DY                             ; F74C A5 F7                    ..
        beq     LF757                           ; F74E F0 07                    ..
        asl     a                               ; F750 0A                       .
        asl     a                               ; F751 0A                       .
        clc                                     ; F752 18                       .
        adc     TEMP_NEXT_Y                             ; F753 65 0A                    e.
        sta     TEMP_NEXT_Y                             ; F755 85 0A                    ..
LF757:
        lda     CUR_OBJ_DX                             ; F757 A5 F5                    ..
        beq     LF772                           ; F759 F0 17                    ..
        asl     a                               ; F75B 0A                       .
        asl     a                               ; F75C 0A                       .
        and     #$0F                            ; F75D 29 0F                    ).
        clc                                     ; F75F 18                       .
        adc     TEMP_NEXT_X_LO                           ; F760 65 0E                    e.
        pha                                     ; F762 48                       H
        and     #$0F                            ; F763 29 0F                    ).
        sta     TEMP_NEXT_X_LO                           ; F765 85 0E                    ..
        pla                                     ; F767 68                       h
        asl     a                               ; F768 0A                       .
        asl     a                               ; F769 0A                       .
        asl     a                               ; F76A 0A                       .
        asl     a                               ; F76B 0A                       .
        lda     TEMP_NEXT_X_HI                             ; F76C A5 0F                    ..
        adc     CUR_OBJ_HORIZ_DIR                             ; F76E 65 F6                    e.
        sta     TEMP_NEXT_X_HI                             ; F770 85 0F                    ..
LF772:
        rts                                     ; F772 60                       `

; ----------------------------------------------------------------------------
ANIMATE_PLAYER_PROJECTILE:
		; ensure sprite's bits 2-3 match those of its gen type (used as shot length counter)
        lda     CUR_OBJ_GEN_TYPE                             ; F773 A5 EE                    ..
        and     #$0C                            ; F775 29 0C                    ).
        sta     SCRATCH_08                             ; F777 85 08                    ..
        lda     CUR_OBJ_SPRITE                             ; F779 A5 ED                    ..
        and     #$F3                            ; F77B 29 F3                    ).
        ora     SCRATCH_08                             ; F77D 05 08                    ..
        sta     CUR_OBJ_SPRITE                             ; F77F 85 ED                    ..
        rts                                     ; F781 60                       `

; ----------------------------------------------------------------------------
; handle any temp object animations
HANDLE_BLOCK_ANIMATIONS:
        ; branch if flag set; else rts
		lda     BLOCK_ANIMATION_FLAG                           ; F782 AD 91 04                 ...
        bne     LF788                           ; F785 D0 01                    ..
        rts                                     ; F787 60                       `

; ----------------------------------------------------------------------------
LF788:
        ; slot 9
		lda     #$90                            ; F788 A9 90                    ..
        sta     CUR_OBJ_PTR_LO                             ; F78A 85 E5                    ..
        lda     #$04                            ; F78C A9 04                    ..
        sta     CUR_OBJ_PTR_HI                             ; F78E 85 E6                    ..
        
		; load it, update ctr and branch if <> 0
		jsr     LOAD_CUR_OBJ                           ; F790 20 8F E9                  ..
        dec     CUR_OBJ_MISC_CTR                             ; F793 C6 F3                    ..
        bne     UPDATE_TEMP_OBJECT                           ; F795 D0 60                    .`
        
		; ctr = 0; branch (erase) if sprite ID is odd
		lda     CUR_OBJ_SPRITE                             ; F797 A5 ED                    ..
        and     #$01                            ; F799 29 01                    ).
        bne     ERASE_TEMP_OBJECT                           ; F79B D0 0D                    ..
        
		; branch (erase) if aligned to block boundaries
		lda     CUR_OBJ_NEXT_Y                             ; F79D A5 FB                    ..
        and     #$0F                            ; F79F 29 0F                    ).
        ora     CUR_OBJ_NEXT_X                             ; F7A1 05 F9                    ..
        beq     ERASE_TEMP_OBJECT                           ; F7A3 F0 05                    ..
        
		; else inc the counter to keep it moving
		inc     CUR_OBJ_MISC_CTR                             ; F7A5 E6 F3                    ..
        jmp     UPDATE_TEMP_OBJECT                           ; F7A7 4C F7 F7                 L..

; ----------------------------------------------------------------------------
; we're done with a temp object; erase it and, if needed, restore the original tile (needed for glove/crossbow)
ERASE_TEMP_OBJECT:
		; erase temp obj
        lda     #$00                            ; F7AA A9 00                    ..
        sta     CUR_OBJ_GEN_TYPE                             ; F7AC 85 EE                    ..
        
		; branch if CUR_OBJ_FALL_SPEED <> 0 - this is the original tile ID we replaced
		lda     CUR_OBJ_FALL_SPEED                             ; F7AE A5 F0                    ..
        bne     LF7B5                           ; F7B0 D0 03                    ..
        jmp     TEMP_OBJ_SAVE_AND_RTS                           ; F7B2 4C 96 F8                 L..

; ----------------------------------------------------------------------------
LF7B5:
		; set position vars to access tile loc
        lda     CUR_OBJ_NEXT_X_HI                             ; F7B5 A5 FA                    ..
        sta     PLAYER_MAP_TILE_LO                           ; F7B7 85 0C                    ..
        lda     CUR_OBJ_NEXT_Y                             ; F7B9 A5 FB                    ..
        sta     PLAYER_MAP_TILE_HI                             ; F7BB 85 0D                    ..
        jsr     UPDATE_MAP_TILE_PTRS                           ; F7BD 20 54 CA                  T.
        
		; restore the original tile
		lda     CUR_OBJ_FALL_SPEED                             ; F7C0 A5 F0                    ..
        ldy     #$00                            ; F7C2 A0 00                    ..
        sta     (PLAYER_MAP_TILE_PTR),y                       ; F7C4 91 0C                    ..
        
		; branch if not off right edge of screen
		lda     CUR_OBJ_NEXT_X_HI                             ; F7C6 A5 FA                    ..
        sec                                     ; F7C8 38                       8
        sbc     SCROLL_X_HI                             ; F7C9 E5 7C                    .|
        cmp     #$11                            ; F7CB C9 11                    ..
        bcc     LF7D3                           ; F7CD 90 04                    ..
        
		; branch if off left edge of screen
		cmp     #$FE                            ; F7CF C9 FE                    ..
        bcc     LF7F4                           ; F7D1 90 21                    .!
LF7D3:
		; object is onscreen - so update PPU to reflect tile update
		; if offscreen there's no need - update will occur when we scroll over there
		
		; calc offsets for PPU update
        lda     CUR_OBJ_NEXT_X_HI                             ; F7D3 A5 FA                    ..
        sta     PLAYER_MAP_TILE_LO                           ; F7D5 85 0C                    ..
        asl     a                               ; F7D7 0A                       .
        and     #$1F                            ; F7D8 29 1F                    ).
        sta     PPU_WRITE_LO                             ; F7DA 85 16                    ..
        lda     CUR_OBJ_NEXT_X_HI                             ; F7DC A5 FA                    ..
        and     #$10                            ; F7DE 29 10                    ).
        lsr     a                               ; F7E0 4A                       J
        lsr     a                               ; F7E1 4A                       J
        sta     PPU_WRITE_HI                             ; F7E2 85 17                    ..
        
		; add offsets above to $2000 (nametable 0)
		clc                                     ; F7E4 18                       .
        lda     #$00                            ; F7E5 A9 00                    ..
        adc     PPU_WRITE_LO                             ; F7E7 65 16                    e.
        sta     PPU_WRITE_LO                             ; F7E9 85 16                    ..
        lda     #$20                            ; F7EB A9 20                    . 
        adc     PPU_WRITE_HI                             ; F7ED 65 17                    e.
        sta     PPU_WRITE_HI                             ; F7EF 85 17                    ..
        jsr     UPDATE_MAP_DATA_FROM_SCROLL                           ; F7F1 20 33 C8                  3.
LF7F4:
        jmp     TEMP_OBJ_SAVE_AND_RTS                           ; F7F4 4C 96 F8                 L..

; ----------------------------------------------------------------------------
UPDATE_TEMP_OBJECT:
        ; branch if current sprite ID even
		lda     CUR_OBJ_SPRITE                             ; F7F7 A5 ED                    ..
        and     #$01                            ; F7F9 29 01                    ).
        beq     LF80C                           ; F7FB F0 0F                    ..
        
		; otherwise, check counter
		lda     CUR_OBJ_MISC_CTR                             ; F7FD A5 F3                    ..
        and     #$03                            ; F7FF 29 03                    ).
        bne     LF809                           ; F801 D0 06                    ..
        lda     CUR_OBJ_SPRITE                             ; F803 A5 ED                    ..
        eor     #$04                            ; F805 49 04                    I.
        sta     CUR_OBJ_SPRITE                             ; F807 85 ED                    ..
LF809:
        jmp     TEMP_OBJ_SAVE_AND_RTS                           ; F809 4C 96 F8                 L..

; ----------------------------------------------------------------------------
LF80C:
		; force slot 9, temp object
        lda     #OBJ_SLOT_TEMP_OBJECT                            ; F80C A9 09                    ..
        sta     CUR_OBJ_SLOT_NUM                             ; F80E 85 E3                    ..
        jsr     CALC_NEXT_POS_FROM_TEMP_VARS                           ; F810 20 F1 EF                  ..
        
		; branch (can't move) if it's trying to move oob
		jsr     CHECK_BLOCK_MOVING_OOB                           ; F813 20 1C CF                  ..
        bcs     TEMP_OBJECT_REVERSE_DIR                           ; F816 B0 42                    .B
        
		; in bounds; branch (can't move) if blocked by solid tile
		jsr     CHECK_TEMP_NEXT_POS_HIT_SOLID_TILE                           ; F818 20 3A F2                  :.
        bcs     TEMP_OBJECT_REVERSE_DIR                           ; F81B B0 3D                    .=
        
		; branch if colliding with player
		jsr     CHECK_OBJ_COLLIDE_WITH_PLAYER                           ; F81D 20 7C CE                  |.
        bcs     TEMP_OBJECT_HIT_PLAYER                           ; F820 B0 24                    .$
        
		; branch if no collision
		jsr     CHECK_TEMP_POS_HIT_OBJECT                           ; F822 20 B2 CD                  ..
        bcc     LF82E                           ; F825 90 07                    ..
        
		; cool, temp object (e.g. moving block) kills an enemy
		; collision - access the enemy slot and kill it
		; SCRATCH_09 = slot of collision
		ldx     SCRATCH_09                             ; F827 A6 09                    ..
        lda     #OBJ_GEN_TYPE_ENEMY_JUST_KILLED                            ; F829 A9 80                    ..
        sta     OBJ_GENERAL_TYPE,x                         ; F82B 9D 01 04                 ...
LF82E:
        lda     TEMP_NEXT_X_LO                           ; F82E A5 0E                    ..
        sta     CUR_OBJ_NEXT_X                             ; F830 85 F9                    ..
        lda     TEMP_NEXT_X_HI                             ; F832 A5 0F                    ..
        sta     CUR_OBJ_NEXT_X_HI                             ; F834 85 FA                    ..
        lda     TEMP_NEXT_Y                             ; F836 A5 0A                    ..
        sta     CUR_OBJ_NEXT_Y                             ; F838 85 FB                    ..
        
		; clear flag
		lda     #$00                            ; F83A A9 00                    ..
        sta     TEMP_OBJ_HIT_FLAG                             ; F83C 85 F4                    ..
        jmp     TEMP_OBJ_SAVE_AND_RTS                           ; F83E 4C 96 F8                 L..

; ----------------------------------------------------------------------------
        ; $f841 - unused snippet?
		inc     CUR_OBJ_MISC_CTR                             ; F841 E6 F3                    ..
        jmp     TEMP_OBJ_SAVE_AND_RTS                           ; F843 4C 96 F8                 L..

; ----------------------------------------------------------------------------

; a moveable block is hitting the player!
TEMP_OBJECT_HIT_PLAYER:
		; branch if TEMP_OBJ_HIT_FLAG <> 0 - prevents multiple hits
        lda     TEMP_OBJ_HIT_FLAG                             ; F846 A5 F4                    ..
        bne     LF886                           ; F848 D0 3C                    .<
        
		; branch (no player dmg) if invulnerable
		lda     INVULN_CTR                             ; F84A A5 85                    ..
        bne     TEMP_OBJECT_REVERSE_DIR                           ; F84C D0 0C                    ..
        
		; damage player, give 2 seconds of invulnerability
		jsr     DECREMENT_PLAYER_LIFE                           ; F84E 20 CE E7                  ..
        lda     #SOUND_HARD_LANDING                            ; F851 A9 0A                    ..
        sta     a:NEXT_SOUND_EFFECT                           ; F853 8D 8F 00                 ...
        lda     #$02                            ; F856 A9 02                    ..
        sta     INVULN_CTR                             ; F858 85 85                    ..
TEMP_OBJECT_REVERSE_DIR:
		; branch if TEMP_OBJ_HIT_FLAG <> 0 - prevents multiple reversals
        lda     TEMP_OBJ_HIT_FLAG                             ; F85A A5 F4                    ..
        bne     LF886                           ; F85C D0 28                    .(
        
		; TEMP_OBJ_HIT_FLAG = 0; increment it
		inc     TEMP_OBJ_HIT_FLAG                             ; F85E E6 F4                    ..
        
		; branch if not moving horizontally
		lda     CUR_OBJ_DX                             ; F860 A5 F5                    ..
		beq     LF873                           ; F862 F0 0F                    ..
        
		; otherwise this appears to set CUR_OBJ_DX=-dx, limited 0-15
		eor     #$FF                            ; F864 49 FF                    I.
        clc                                     ; F866 18                       .
        adc     #$01                            ; F867 69 01                    i.
        and     #$0F                            ; F869 29 0F                    ).
        sta     CUR_OBJ_DX                             ; F86B 85 F5                    ..
        
		; CUR_OBJ_HORIZ_DIR, CUR_OBJ_DY also inverted
		lda     CUR_OBJ_HORIZ_DIR                             ; F86D A5 F6                    ..
        eor     #$FF                            ; F86F 49 FF                    I.
        sta     CUR_OBJ_HORIZ_DIR                             ; F871 85 F6                    ..
LF873:
        lda     CUR_OBJ_DY                             ; F873 A5 F7                    ..
        eor     #$FF                            ; F875 49 FF                    I.
        tax                                     ; F877 AA                       .
        inx                                     ; F878 E8                       .
        stx     CUR_OBJ_DY                             ; F879 86 F7                    ..
        
		; play sound if nothing already playing
		lda     NEXT_SOUND_EFFECT                             ; F87B A5 8F                    ..
        bne     LF883                           ; F87D D0 04                    ..
        lda     #SOUND_OPEN_DOOR                            ; F87F A9 06                    ..
        sta     NEXT_SOUND_EFFECT                             ; F881 85 8F                    ..
LF883:
        jmp     TEMP_OBJ_SAVE_AND_RTS                           ; F883 4C 96 F8                 L..

; ----------------------------------------------------------------------------
LF886:
        ; branch if aligned to block boundaries
		lda     CUR_OBJ_NEXT_Y                             ; F886 A5 FB                    ..
        and     #$0F                            ; F888 29 0F                    ).
        ora     CUR_OBJ_NEXT_X                             ; F88A 05 F9                    ..
        beq     LF893                           ; F88C F0 05                    ..
        
		; else, keep it moving
		inc     CUR_OBJ_MISC_CTR                             ; F88E E6 F3                    ..
        jmp     TEMP_OBJ_SAVE_AND_RTS                           ; F890 4C 96 F8                 L..

; ----------------------------------------------------------------------------
LF893:
        jmp     ERASE_TEMP_OBJECT                           ; F893 4C AA F7                 L..

; ----------------------------------------------------------------------------
TEMP_OBJ_SAVE_AND_RTS:
        jsr     SAVE_CUR_OBJ                           ; F896 20 9A E9                  ..
        rts                                     ; F899 60                       `

; ----------------------------------------------------------------------------
; nmi calls this to update the sound!
SOUND_MAIN:
        ; swap to AB bank, with sound data
		jsr     USE_PRG_AB                           ; F89A 20 74 FD                  t.
        
		; offset to the D channel (DMC/sound effects)
		lda     #SND_CHAN_DMC                            ; F89D A9 40                    .@
        sta     CUR_SND_CHANNEL                             ; F89F 85 02                    ..
        
		jsr     SND_UPDATE_DMC                           ; F8A1 20 60 FA                  `.
        lda     FLAG_START_SCREEN_OPEN                             ; F8A4 A5 8D                    ..
        
		; branch if FLAG_START_SCREEN_OPEN=0
		beq     SND_UPDATE_NON_DMC_CHANNELS                           ; F8A6 F0 25                    .%
        
		; FLAG_START_SCREEN_OPEN is non-zero
		; branch (don't write to SQ2 vol) if SND_CTRL_DMC negative
		lda     #$00                            ; F8A8 A9 00                    ..
        bit     SND_CTRL_DMC                             ; F8AA 24 D4                    $.
        bmi     LF8B7                           ; F8AC 30 09                    0.
        
		; SND_CTRL_DMC is positive; write SQ2 vol to APU
		lda     SND_SQ2_VOL                             ; F8AE A5 A9                    ..
        and     #$C0                            ; F8B0 29 C0                    ).
        ora     #$30                            ; F8B2 09 30                    .0
        sta     APU_SQ2_VOL                           ; F8B4 8D 04 40                 ..@
LF8B7:
        ; write SQ1 vol to APU
		lda     SND_CHAN_VOL                             ; F8B7 A5 99                    ..
        and     #$C0                            ; F8B9 29 C0                    ).
        ora     #$30                            ; F8BB 09 30                    .0
        sta     APU_SQ1_VOL                           ; F8BD 8D 00 40                 ..@
        
		; kill triangle
		lda     #$00                            ; F8C0 A9 00                    ..
        sta     APU_TRI_LIN                           ; F8C2 8D 08 40                 ..@
        
		; halt noise channel
		lda     #$30                            ; F8C5 A9 30                    .0
        sta     APU_NOISE_LEN                           ; F8C7 8D 0C 40                 ..@
        jmp     LF8EC                           ; F8CA 4C EC F8                 L..

; ----------------------------------------------------------------------------
; FLAG_START_SCREEN_OPEN was zero
; update the SQ1, SQ2, triangle and noise sound channels
; CUR_SND_CHANNEL is the offset to a given channel; each has 16 bytes
SND_UPDATE_NON_DMC_CHANNELS:
        jsr     USE_NEXT_PRG                           ; F8CD 20 87 FD                  ..
        lda     #SND_CHAN_SQ1                            ; F8D0 A9 00                    ..
        sta     CUR_SND_CHANNEL                             ; F8D2 85 02                    ..
        jsr     SND_UPDATE_SQ1                           ; F8D4 20 F0 F8                  ..
        lda     #SND_CHAN_SQ2                            ; F8D7 A9 10                    ..
        sta     CUR_SND_CHANNEL                             ; F8D9 85 02                    ..
        jsr     SND_UPDATE_SQ2                           ; F8DB 20 6E F9                  n.
        lda     #SND_CHAN_TRIANGLE                            ; F8DE A9 20                    . 
        sta     CUR_SND_CHANNEL                             ; F8E0 85 02                    ..
        jsr     SND_UPDATE_TRIANGLE                           ; F8E2 20 09 FA                  ..
        lda     #SND_CHAN_NOISE                            ; F8E5 A9 30                    .0
        sta     CUR_SND_CHANNEL                             ; F8E7 85 02                    ..
        jsr     SND_UPDATE_NOISE                           ; F8E9 20 1F FB                  ..
LF8EC:
        jsr     REVERT_PRG                           ; F8EC 20 9C FD                  ..
        rts                                     ; F8EF 60                       `

; ----------------------------------------------------------------------------
SND_UPDATE_SQ1:
        ; branch if SND_CHAN_CTRL negative
		bit     SND_CHAN_CTRL                             ; F8F0 24 94                    $.
        bmi     LF8F7                           ; F8F2 30 03                    0.
        
		; SND_CHAN_CTRL positive
		jmp     SND_DISABLE_SQ1                           ; F8F4 4C 5E F9                 L^.

; ----------------------------------------------------------------------------
LF8F7:
		; dec SND_CHAN_NOTE_TIMER and branch if 0
        dec     SND_CHAN_NOTE_TIMER                             ; F8F7 C6 93                    ..
        beq     LF8FE                           ; F8F9 F0 03                    ..
        
		; SND_CHAN_NOTE_TIMER not 0
		jmp     LF948                           ; F8FB 4C 48 F9                 LH.

; ----------------------------------------------------------------------------
LF8FE:
		; read some sound data from (SND_CHAN_PTR_LO),y
		; branch if we get 0
        ldy     #$00                            ; F8FE A0 00                    ..
        lda     (SND_CHAN_PTR_LO),y                         ; F900 B1 95                    ..
        beq     LF910                           ; F902 F0 0C                    ..
        
		; preserve processor and branch if we don't get xFF
		php                                     ; F904 08                       .
        cmp     #$FF                            ; F905 C9 FF                    ..
        bne     SND_HANDLE_SQ1_DATA_BYTE                           ; F907 D0 0D                    ..
        
		; data byte was xFF
		plp                                     ; F909 28                       (
        jsr     RUN_SOUND_ROUTINE                           ; F90A 20 8E FB                  ..
        jmp     LF8FE                           ; F90D 4C FE F8                 L..

; ----------------------------------------------------------------------------
LF910:
		; load the new note
        jsr     SND_CHAN_NEXT_VERSE                           ; F910 20 F9 FC                  ..
        
		; kill the channel
		jmp     SND_DISABLE_SQ1                           ; F913 4C 5E F9                 L^.

; ----------------------------------------------------------------------------
; input: a = channel data byte
SND_HANDLE_SQ1_DATA_BYTE:
		; data byte above was not 0 or xFF
		; lower 7 bits saved to SND_CHAN_NOTE_TIMER
        jsr     SND_CHAN_INC_DATA_PTR                           ; F916 20 6B FD                  k.
        and     #$7F                            ; F919 29 7F                    ).
        sta     SND_CHAN_NOTE_TIMER                             ; F91B 85 93                    ..
        plp                                     ; F91D 28                       (
        bmi     LF942                           ; F91E 30 22                    0"
        jsr     SND_LOAD_NEXT_NOTE                           ; F920 20 81 FC                  ..
        
		; enable SQ1 channel
		lda     SOUND_APU_STAT_FLAGS                             ; F923 A5 27                    .'
        ora     #$01                            ; F925 09 01                    ..
        sta     SOUND_APU_STAT_FLAGS                             ; F927 85 27                    .'
        lda     SND_CHAN_SWEEP                             ; F929 A5 9A                    ..
        sta     APU_SQ1_SWP                           ; F92B 8D 01 40                 ..@
        lda     SND_SCRATCH_04                             ; F92E A5 04                    ..
        sta     APU_SQ1_LO                           ; F930 8D 02 40                 ..@
        lda     SND_SCRATCH_05                             ; F933 A5 05                    ..
        and     #$07                            ; F935 29 07                    ).
        ora     #$18                            ; F937 09 18                    ..
        sta     APU_SQ1_HI                           ; F939 8D 03 40                 ..@
        jsr     SND_CHAN_LOAD_CONFIG_FULL                           ; F93C 20 C4 FC                  ..
        jmp     LF948                           ; F93F 4C 48 F9                 LH.

; ----------------------------------------------------------------------------
LF942:
        jsr     SND_CHAN_LOAD_CONFIG_NO_VOL                           ; F942 20 DF FC                  ..
        jmp     LF948                           ; F945 4C 48 F9                 LH.

; ----------------------------------------------------------------------------
LF948:
        ; branch if SQ1 channel enabled
		lda     SOUND_APU_STAT_FLAGS                             ; F948 A5 27                    .'
        lsr     a                               ; F94A 4A                       J
        bcs     LF94E                           ; F94B B0 01                    ..
        
		; otherwise, rts
		rts                                     ; F94D 60                       `

; ----------------------------------------------------------------------------
LF94E:
        ; dec SND_CHAN_VOL_CHANGE_CTR and branch if >0
		dec     SND_CHAN_VOL_CHANGE_CTR                             ; F94E C6 9D                    ..
        bne     LF958                           ; F950 D0 06                    ..
        
		; SND_CHAN_VOL_CHANGE_CTR = 0
		jsr     SND_NEXT_VOL_LEVEL                           ; F952 20 11 FD                  ..
        sta     APU_SQ1_VOL                           ; F955 8D 00 40                 ..@
LF958:
		; advance config; if it's the last one, branch (disable channel); else rts
        jsr     LOAD_NEXT_CHAN_CONFIG                           ; F958 20 45 FD                  E.
        bcs     SND_DISABLE_SQ1                           ; F95B B0 01                    ..
        rts                                     ; F95D 60                       `

; ----------------------------------------------------------------------------
SND_DISABLE_SQ1:
        ; set SQ1 volume, limited x30-xC0
		lda     SND_CHAN_VOL                             ; F95E A5 99                    ..
        and     #$C0                            ; F960 29 C0                    ).
        ora     #$30                            ; F962 09 30                    .0
        sta     APU_SQ1_VOL                           ; F964 8D 00 40                 ..@
        
		; disable SQ1 channel
		lda     SOUND_APU_STAT_FLAGS                             ; F967 A5 27                    .'
        and     #$FE                            ; F969 29 FE                    ).
        sta     SOUND_APU_STAT_FLAGS                             ; F96B 85 27                    .'
        rts                                     ; F96D 60                       `

; ----------------------------------------------------------------------------
SND_UPDATE_SQ2:
        ; branch if SND_CTRL_SQ2 negative
		bit     SND_CTRL_SQ2                             ; F96E 24 A4                    $.
        bmi     LF978                           ; F970 30 06                    0.
        
		; or rts if bit 6 set
		bvs     LF977                           ; F972 70 03                    p.
        
		; otherwise, jump
		jmp     LF9F9                           ; F974 4C F9 F9                 L..

; ----------------------------------------------------------------------------
LF977:
        rts                                     ; F977 60                       `

; ----------------------------------------------------------------------------
LF978:
        dec     SND_SQ2_NOTE_TIMER                             ; F978 C6 A3                    ..
        beq     LF97F                           ; F97A F0 03                    ..
        jmp     LF9DD                           ; F97C 4C DD F9                 L..

; ----------------------------------------------------------------------------
LF97F:
        ldy     #$00                            ; F97F A0 00                    ..
        lda     (SND_SQ2_PTR_LO),y                         ; F981 B1 A5                    ..
        beq     LF991                           ; F983 F0 0C                    ..
        php                                     ; F985 08                       .
        cmp     #$FF                            ; F986 C9 FF                    ..
        bne     LF997                           ; F988 D0 0D                    ..
        plp                                     ; F98A 28                       (
        jsr     RUN_SOUND_ROUTINE                           ; F98B 20 8E FB                  ..
        jmp     LF97F                           ; F98E 4C 7F F9                 L..

; ----------------------------------------------------------------------------
LF991:
        jsr     SND_CHAN_NEXT_VERSE                           ; F991 20 F9 FC                  ..
        jmp     LF9F9                           ; F994 4C F9 F9                 L..

; ----------------------------------------------------------------------------
LF997:
        ; access the next byte and save lower 7 bits to SND_SQ2_NOTE_TIMER
		jsr     SND_CHAN_INC_DATA_PTR                           ; F997 20 6B FD                  k.
        and     #$7F                            ; F99A 29 7F                    ).
        sta     SND_SQ2_NOTE_TIMER                             ; F99C 85 A3                    ..
        plp                                     ; F99E 28                       (
        bmi     LF9D2                           ; F99F 30 31                    01
        
		; branch if bit 6 clear - write to sound registers
		bit     SND_CTRL_SQ2                             ; F9A1 24 A4                    $.
        bvc     LF9AB                           ; F9A3 50 06                    P.
        
		; bit 6 is set; advance ptr and rts
		jsr     SND_CHAN_INC_DATA_PTR                           ; F9A5 20 6B FD                  k.
        jmp     LF9D6                           ; F9A8 4C D6 F9                 L..

; ----------------------------------------------------------------------------
LF9AB: ; come here if control bit 6 clear; writes to the sound registers
        jsr     SND_LOAD_NEXT_NOTE                           ; F9AB 20 81 FC                  ..
        
		; enable SQ2 channel
		lda     SOUND_APU_STAT_FLAGS                             ; F9AE A5 27                    .'
        ora     #$02                            ; F9B0 09 02                    ..
        sta     SOUND_APU_STAT_FLAGS                             ; F9B2 85 27                    .'
        
		lda     SND_SQ2_VOL                             ; F9B4 A5 A9                    ..
        sta     APU_SQ2_VOL                           ; F9B6 8D 04 40                 ..@
        
		lda     SND_SQ2_SWEEP                             ; F9B9 A5 AA                    ..
        sta     APU_SQ2_SWP                           ; F9BB 8D 05 40                 ..@
        
		; set lower 8 bits of 11-bit timer (sets frequency/pitch)
		lda     SND_SCRATCH_04                             ; F9BE A5 04                    ..
        sta     APU_SQ2_LO                           ; F9C0 8D 06 40                 ..@
        
		; lower 3 bits of the _HI register set the pitch. the upper 5 bits are the length counter,
		; which are looked up from a table - here ora x18 sets length bits --> 3, which in the 
		; table has a value of 2
		; see https://www.nesdev.org/wiki/APU_Length_Counter
		lda     SND_SCRATCH_05                             ; F9C3 A5 05                    ..
        and     #$07                            ; F9C5 29 07                    ).
        ora     #$18                            ; F9C7 09 18                    ..
        sta     APU_SQ2_HI                           ; F9C9 8D 07 40                 ..@
        
		jsr     SND_CHAN_LOAD_CONFIG_FULL                           ; F9CC 20 C4 FC                  ..
        jmp     LF9DD                           ; F9CF 4C DD F9                 L..

; ----------------------------------------------------------------------------
LF9D2:
		; branch if bit 6 clear, else rts
        bit     SND_CTRL_SQ2                             ; F9D2 24 A4                    $.
        bvc     LF9D7                           ; F9D4 50 01                    P.
LF9D6:
        rts                                     ; F9D6 60                       `

; ----------------------------------------------------------------------------
LF9D7:
		; here if bit 6 clear - load another noted
        jsr     SND_CHAN_LOAD_CONFIG_NO_VOL                           ; F9D7 20 DF FC                  ..
        jmp     LF9DD                           ; F9DA 4C DD F9                 L..

; ----------------------------------------------------------------------------
LF9DD:
		; branch if bit 6 clear; else rts
        bit     SND_CTRL_SQ2                             ; F9DD 24 A4                    $.
        bvc     LF9E2                           ; F9DF 50 01                    P.
        rts                                     ; F9E1 60                       `

; ----------------------------------------------------------------------------
LF9E2:
		; branch if SQ2 enabled; else rts
        lda     SOUND_APU_STAT_FLAGS                             ; F9E2 A5 27                    .'
        and     #$02                            ; F9E4 29 02                    ).
        bne     LF9E9                           ; F9E6 D0 01                    ..
        
		; otherwise rts
		rts                                     ; F9E8 60                       `

; ----------------------------------------------------------------------------
LF9E9:
        ; dec SND_SQ2_VOL_CHANGE_CTR and branch if <> 0
		dec     SND_SQ2_VOL_CHANGE_CTR                             ; F9E9 C6 AD                    ..
        bne     LF9F3                           ; F9EB D0 06                    ..
        
		; SND_SQ2_VOL_CHANGE_CTR = 0; load next note
		jsr     SND_NEXT_VOL_LEVEL                           ; F9ED 20 11 FD                  ..
        sta     APU_SQ2_VOL                           ; F9F0 8D 04 40                 ..@
LF9F3:
		; advance config; if it's the last one, branch (disable channel); else rts
        jsr     LOAD_NEXT_CHAN_CONFIG                           ; F9F3 20 45 FD                  E.
        bcs     LF9F9                           ; F9F6 B0 01                    ..
        rts                                     ; F9F8 60                       `

; ----------------------------------------------------------------------------
LF9F9:
		; here if LOAD_NEXT_CHAN_CONFIG carry set; constraint SQ2 volume and disable SQ2
        ; set SQ2 volume limited to x30-xC0
		lda     SND_SQ2_VOL                             ; F9F9 A5 A9                    ..
        and     #$C0                            ; F9FB 29 C0                    ).
        ora     #$30                            ; F9FD 09 30                    .0
        sta     APU_SQ2_VOL                           ; F9FF 8D 04 40                 ..@
        
		; disable SQ2
		lda     SOUND_APU_STAT_FLAGS                             ; FA02 A5 27                    .'
        and     #$FD                            ; FA04 29 FD                    ).
        sta     SOUND_APU_STAT_FLAGS                             ; FA06 85 27                    .'
        rts                                     ; FA08 60                       `

; ----------------------------------------------------------------------------
SND_UPDATE_TRIANGLE:
        ; branch if SND_CTRL_TRIANGLE negative
		lda     SND_CTRL_TRIANGLE                             ; FA09 A5 B4                    ..
        bmi     LFA10                           ; FA0B 30 03                    0.
        
		; else jump; SND_CTRL_TRIANGLE >= 0
		jmp     SND_KILL_TRIANGLE                           ; FA0D 4C 54 FA                 LT.

; ----------------------------------------------------------------------------
LFA10:
		; dec SND_CONTROL_B3 and branch if 0, else rts
        dec     SND_CONTROL_B3                             ; FA10 C6 B3                    ..
        beq     SND_PROCESS_BYTE_TRIANGLE                           ; FA12 F0 01                    ..
        rts                                     ; FA14 60                       `

; ----------------------------------------------------------------------------
; process a byte of sound data from (SND_TRIANGLE_PTR_LO),y and apply it to the triangle channel
SND_PROCESS_BYTE_TRIANGLE:
		; process a sound byte from (SND_TRIANGLE_PTR_LO),y
		; branch if stop byte
        ldy     #$00                            ; FA15 A0 00                    ..
        lda     (SND_TRIANGLE_PTR_LO),y                         ; FA17 B1 B5                    ..
        beq     LFA27                           ; FA19 F0 0C                    ..

		; branch if not a special routine
        php                                     ; FA1B 08                       .
        cmp     #$FF                            ; FA1C C9 FF                    ..
        bne     LFA2D                           ; FA1E D0 0D                    ..

		; special routine and loop
        plp                                     ; FA20 28                       (
        jsr     RUN_SOUND_ROUTINE                           ; FA21 20 8E FB                  ..
        jmp     SND_PROCESS_BYTE_TRIANGLE                           ; FA24 4C 15 FA                 L..

; ----------------------------------------------------------------------------
LFA27:
        jsr     SND_CHAN_NEXT_VERSE                           ; FA27 20 F9 FC                  ..
        jmp     SND_KILL_TRIANGLE                           ; FA2A 4C 54 FA                 LT.

; ----------------------------------------------------------------------------
LFA2D:
        jsr     SND_CHAN_INC_DATA_PTR                           ; FA2D 20 6B FD                  k.
        and     #$7F                            ; FA30 29 7F                    ).
        sta     SND_CONTROL_B3                             ; FA32 85 B3                    ..
        plp                                     ; FA34 28                       (
        bmi     SND_KILL_TRIANGLE                           ; FA35 30 1D                    0.
        jsr     SND_LOAD_NEXT_NOTE                           ; FA37 20 81 FC                  ..
        
		; enable triangle channel
		lda     SOUND_APU_STAT_FLAGS                             ; FA3A A5 27                    .'
        ora     #$04                            ; FA3C 09 04                    ..
        sta     SOUND_APU_STAT_FLAGS                             ; FA3E 85 27                    .'
        
		lda     SND_TRI_SWEEP                             ; FA40 A5 BA                    ..
        sta     APU_TRI_LIN                           ; FA42 8D 08 40                 ..@
        
		lda     SND_SCRATCH_04                             ; FA45 A5 04                    ..
        sta     APU_TRI_HI                           ; FA47 8D 0A 40                 ..@
        
		lda     SND_SCRATCH_05                             ; FA4A A5 05                    ..
        and     #$07                            ; FA4C 29 07                    ).
        ora     #$F8                            ; FA4E 09 F8                    ..
        sta     APU_NOISE_TIMER                           ; FA50 8D 0B 40                 ..@
        rts                                     ; FA53 60                       `

; ----------------------------------------------------------------------------
SND_KILL_TRIANGLE:
        lda     #$00                            ; FA54 A9 00                    ..
        sta     APU_TRI_LIN                           ; FA56 8D 08 40                 ..@
        
		; disable triangle channel
		lda     SOUND_APU_STAT_FLAGS                             ; FA59 A5 27                    .'
        and     #$FB                            ; FA5B 29 FB                    ).
        sta     SOUND_APU_STAT_FLAGS                             ; FA5D 85 27                    .'
        rts                                     ; FA5F 60                       `

; ----------------------------------------------------------------------------
SND_UPDATE_DMC:
		; branch if no next sound requested
        lda     NEXT_SOUND_EFFECT                             ; FA60 A5 8F                    ..
        beq     LFA74                           ; FA62 F0 10                    ..
        
		; sound requested; branch if SND_CTRL_DMC positive
		lda     SND_CTRL_DMC                             ; FA64 A5 D4                    ..
        bpl     LFA79                           ; FA66 10 11                    ..
        
		; SND_CTRL_DMC negative; branch if next effect takes priority over anything currently playing
		lda     NEXT_SND_EFFECT_PRIORITY                             ; FA68 A5 90                    ..
        cmp     CUR_SND_EFFECT_PRIORITY                             ; FA6A C5 91                    ..
        bcs     LFA79                           ; FA6C B0 0B                    ..
        
		; requested effect does not have priority; clear it and cancel next sound effect
		lda     #$00                            ; FA6E A9 00                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; FA70 85 90                    ..
        sta     NEXT_SOUND_EFFECT                             ; FA72 85 8F                    ..
LFA74:
		; branch if SND_CTRL_DMC negative
        lda     SND_CTRL_DMC                             ; FA74 A5 D4                    ..
        bmi     LFA9E                           ; FA76 30 26                    0&
        rts                                     ; FA78 60                       `

; ----------------------------------------------------------------------------
LFA79:
		; requested effect has priority over anything currently playing; use its priority and play the new sound
        lda     NEXT_SND_EFFECT_PRIORITY                             ; FA79 A5 90                    ..
        sta     CUR_SND_EFFECT_PRIORITY                             ; FA7B 85 91                    ..
        
		; sound id*2 is an x index for values read from table
		lda     NEXT_SOUND_EFFECT                             ; FA7D A5 8F                    ..
        asl     a                               ; FA7F 0A                       .
        tax                                     ; FA80 AA                       .
        lda     TBL_SND_EFFECT_ADDR,x                         ; FA81 BD 14 80                 ...
        sta     SND_DMC_PTR_LO                             ; FA84 85 D5                    ..
        lda     TBL_SND_EFFECT_ADDR+1,x                         ; FA86 BD 15 80                 ...
        sta     SND_EFFECT_PTR_HI                             ; FA89 85 D6                    ..
        
		; SND_CTRL_DMC --> x80, SND_CTRL_SQ2 bit 6 set, clear NEXT_SOUND_EFFECT AND NEXT_SND_EFFECT_PRIORITY
		lda     #$80                            ; FA8B A9 80                    ..
        sta     SND_CTRL_DMC                             ; FA8D 85 D4                    ..
        
		; set bit 6 on SQ2 control (pause channel)
		lda     SND_CTRL_SQ2                             ; FA8F A5 A4                    ..
        ora     #$40                            ; FA91 09 40                    .@
        sta     SND_CTRL_SQ2                             ; FA93 85 A4                    ..
        
		; clear the original request and priority
		lda     #$00                            ; FA95 A9 00                    ..
        sta     NEXT_SOUND_EFFECT                             ; FA97 85 8F                    ..
        sta     NEXT_SND_EFFECT_PRIORITY                             ; FA99 85 90                    ..
        jmp     SND_PROCESS_BYTE_DMC                           ; FA9B 4C A5 FA                 L..

; ----------------------------------------------------------------------------
LFA9E:
        dec     SND_DMC_NOTE_TIMER                             ; FA9E C6 D3                    ..
        beq     SND_PROCESS_BYTE_DMC                           ; FAA0 F0 03                    ..
        jmp     LFAF8                           ; FAA2 4C F8 FA                 L..

; ----------------------------------------------------------------------------
; process a byte on the D channel
; 0 - stop byte
; FF - routine (and then loops to grab the next byte)
; other - note        
SND_PROCESS_BYTE_DMC:
		; load byte and branch if stop byte encountered
		ldy     #$00                            ; FAA5 A0 00                    ..
        lda     (SND_DMC_PTR_LO),y                         ; FAA7 B1 D5                    ..
        beq     SND_EFFECT_STOP_BYTE                           ; FAA9 F0 0C                    ..
        
		; branch if normal byte
		php                                     ; FAAB 08                       .
        cmp     #$FF                            ; FAAC C9 FF                    ..
        bne     SND_EFFECT_NORMAL_BYTE                           ; FAAE D0 16                    ..
        
		; routine
		plp                                     ; FAB0 28                       (
        jsr     RUN_SOUND_ROUTINE                           ; FAB1 20 8E FB                  ..
        
		; loop
		jmp     SND_PROCESS_BYTE_DMC                           ; FAB4 4C A5 FA                 L..

; ----------------------------------------------------------------------------
SND_EFFECT_STOP_BYTE: ; 0 byte in sound effect data
        ; switch DMC channel off, clear the current sound's priority as it's finished
		lda     #$00                            ; FAB7 A9 00                    ..
        sta     SND_CTRL_DMC                             ; FAB9 85 D4                    ..
        sta     CUR_SND_EFFECT_PRIORITY                             ; FABB 85 91                    ..
        
		; release hold on SQ2
		lda     SND_CTRL_SQ2                             ; FABD A5 A4                    ..
        and     #$BF                            ; FABF 29 BF                    ).
        sta     SND_CTRL_SQ2                             ; FAC1 85 A4                    ..
        jmp     SET_VOL_DISABLE_SQ2                           ; FAC3 4C 0F FB                 L..

; ----------------------------------------------------------------------------
SND_EFFECT_NORMAL_BYTE:	; default case/no special byte
        jsr     SND_CHAN_INC_DATA_PTR                           ; FAC6 20 6B FD                  k.
        and     #$7F                            ; FAC9 29 7F                    ).
        sta     SND_DMC_NOTE_TIMER                             ; FACB 85 D3                    ..
        plp                                     ; FACD 28                       (
        bmi     LFAF2                           ; FACE 30 22                    0"
        jsr     SND_LOAD_NEXT_NOTE                           ; FAD0 20 81 FC                  ..
        
		; enable SQ2
		lda     #$02                            ; FAD3 A9 02                    ..
        ora     SOUND_APU_STAT_FLAGS                             ; FAD5 05 27                    .'
        sta     SOUND_APU_STAT_FLAGS                             ; FAD7 85 27                    .'
        
		lda     SND_SQ2_SWEEP_DA                             ; FAD9 A5 DA                    ..
        sta     APU_SQ2_SWP                           ; FADB 8D 05 40                 ..@
        lda     SND_SCRATCH_04                             ; FADE A5 04                    ..
        sta     APU_SQ2_LO                           ; FAE0 8D 06 40                 ..@
        lda     SND_SCRATCH_05                             ; FAE3 A5 05                    ..
        and     #$07                            ; FAE5 29 07                    ).
        ora     #$C0                            ; FAE7 09 C0                    ..
        sta     APU_SQ2_HI                           ; FAE9 8D 07 40                 ..@
        jsr     SND_CHAN_LOAD_CONFIG_FULL                           ; FAEC 20 C4 FC                  ..
        jmp     LFAF8                           ; FAEF 4C F8 FA                 L..

; ----------------------------------------------------------------------------
LFAF2:
        jsr     SND_CHAN_LOAD_CONFIG_NO_VOL                           ; FAF2 20 DF FC                  ..
        jmp     LFAF8                           ; FAF5 4C F8 FA                 L..

; ----------------------------------------------------------------------------
LFAF8:
        ; branch if SQ2 enabled
		lda     SOUND_APU_STAT_FLAGS                             ; FAF8 A5 27                    .'
        and     #$02                            ; FAFA 29 02                    ).
        bne     LFAFF                           ; FAFC D0 01                    ..
        rts                                     ; FAFE 60                       `

; ----------------------------------------------------------------------------
LFAFF:
		; branch if note ctr <> 0
        dec     SND_DMC_VOL_CHANGE_CTR                             ; FAFF C6 DD                    ..
        bne     LFB09                           ; FB01 D0 06                    ..
        
		; otherwise, get next length and write volume
		jsr     SND_NEXT_VOL_LEVEL                           ; FB03 20 11 FD                  ..
        sta     APU_SQ2_VOL                           ; FB06 8D 04 40                 ..@
LFB09:
       ; advance config; if it's the last one, branch (disable channel); else rts
        jsr     LOAD_NEXT_CHAN_CONFIG                           ; FB09 20 45 FD                  E.
        bcs     SET_VOL_DISABLE_SQ2                           ; FB0C B0 01                    ..
        rts                                     ; FB0E 60                       `

; ----------------------------------------------------------------------------
; called when the stop byte for a sound effect is encountered
SET_VOL_DISABLE_SQ2:
        ; set volume, boounded
		lda     $D9                             ; FB0F A5 D9                    ..
        and     #$C0                            ; FB11 29 C0                    ).
        ora     #$30                            ; FB13 09 30                    .0
        sta     APU_SQ2_VOL                           ; FB15 8D 04 40                 ..@
        
		; disable SQ2
		lda     SOUND_APU_STAT_FLAGS                             ; FB18 A5 27                    .'
        and     #$FD                            ; FB1A 29 FD                    ).
        sta     SOUND_APU_STAT_FLAGS                             ; FB1C 85 27                    .'
        rts                                     ; FB1E 60                       `

; ----------------------------------------------------------------------------
SND_UPDATE_NOISE:
        bit     SND_CTRL_NOISE                             ; FB1F 24 C4                    $.
        bmi     LFB26                           ; FB21 30 03                    0.
        jmp     LFB82                           ; FB23 4C 82 FB                 L..

; ----------------------------------------------------------------------------
LFB26:
        dec     SND_NOISE_NOTE_TIMER                             ; FB26 C6 C3                    ..
        beq     SND_PROCESS_BYTE_C_CHANNEL                           ; FB28 F0 03                    ..
        jmp     LFB6B                           ; FB2A 4C 6B FB                 Lk.

; ----------------------------------------------------------------------------

; process a byte on the D channel
; 0 - stop byte
; FF - routine (and then loops to grab the next byte)
; other - note        
SND_PROCESS_BYTE_C_CHANNEL:
		; branch if stop byte
        ldy     #$00                            ; FB2D A0 00                    ..
        lda     (SND_NOISE_PTR_LO),y                         ; FB2F B1 C5                    ..
        beq     LFB3F                           ; FB31 F0 0C                    ..
        
		; branch if normal byte
		php                                     ; FB33 08                       .
        cmp     #$FF                            ; FB34 C9 FF                    ..
        bne     SND_NOISE_NORMAL_BYTE                           ; FB36 D0 0D                    ..
        
		; routine and loop
		plp                                     ; FB38 28                       (
        jsr     RUN_SOUND_ROUTINE                           ; FB39 20 8E FB                  ..
        jmp     SND_PROCESS_BYTE_C_CHANNEL                           ; FB3C 4C 2D FB                 L-.

; ----------------------------------------------------------------------------
LFB3F:
        jsr     SND_CHAN_NEXT_VERSE                           ; FB3F 20 F9 FC                  ..
        jmp     LFB82                           ; FB42 4C 82 FB                 L..

; ----------------------------------------------------------------------------
; a = byte from the channel data
SND_NOISE_NORMAL_BYTE:
        ; advance, write lower 7 bits SND_NOISE_NOTE_TIMER
		jsr     SND_CHAN_INC_DATA_PTR                           ; FB45 20 6B FD                  k.
        and     #$7F                            ; FB48 29 7F                    ).
        sta     SND_NOISE_NOTE_TIMER                             ; FB4A 85 C3                    ..
        plp                                     ; FB4C 28                       (
        bmi     LFB65                           ; FB4D 30 16                    0.
        
		; enable noise channel
		lda     #$08                            ; FB4F A9 08                    ..
        ora     SOUND_APU_STAT_FLAGS                             ; FB51 05 27                    .'
        sta     SOUND_APU_STAT_FLAGS                             ; FB53 85 27                    .'
        
		; write the noise registers and load configuration
		lda     SND_NOISE_LFSR                             ; FB55 A5 CA                    ..
        sta     APU_NOISE_LFSR                           ; FB57 8D 0E 40                 ..@
        lda     #$80                            ; FB5A A9 80                    ..
        sta     APU_NOISE_LEN_LOAD                           ; FB5C 8D 0F 40                 ..@
        jsr     SND_CHAN_LOAD_CONFIG_FULL                           ; FB5F 20 C4 FC                  ..
        jmp     LFB6B                           ; FB62 4C 6B FB                 Lk.

; ----------------------------------------------------------------------------
LFB65:
        jsr     SND_CHAN_LOAD_CONFIG_NO_VOL                           ; FB65 20 DF FC                  ..
        jmp     LFB6B                           ; FB68 4C 6B FB                 Lk.

; ----------------------------------------------------------------------------
LFB6B:
        ; branch if noise channel enabled
		lda     SOUND_APU_STAT_FLAGS                             ; FB6B A5 27                    .'
        and     #$08                            ; FB6D 29 08                    ).
        bne     LFB72                           ; FB6F D0 01                    ..
        rts                                     ; FB71 60                       `

; ----------------------------------------------------------------------------
LFB72:
        ; branch if ctr <> 0
		dec     SND_NOISE_VOL_CHANGE_CTR                             ; FB72 C6 CD                    ..
        bne     LFB7C                           ; FB74 D0 06                    ..
        
		; ctr=0, advance to next volume level
		jsr     SND_NEXT_VOL_LEVEL                           ; FB76 20 11 FD                  ..
        sta     APU_NOISE_LEN                           ; FB79 8D 0C 40                 ..@
LFB7C:
		; advance config; if it's the last one, branch (disable channel); else rts
        jsr     LOAD_NEXT_CHAN_CONFIG                           ; FB7C 20 45 FD                  E.
        bcs     LFB82                           ; FB7F B0 01                    ..
        rts                                     ; FB81 60                       `

; ----------------------------------------------------------------------------
LFB82:
        lda     #$30                            ; FB82 A9 30                    .0
        sta     APU_NOISE_LEN                           ; FB84 8D 0C 40                 ..@
        
		; disable noise channel
		lda     SOUND_APU_STAT_FLAGS                             ; FB87 A5 27                    .'
        and     #$F7                            ; FB89 29 F7                    ).
        sta     SOUND_APU_STAT_FLAGS                             ; FB8B 85 27                    .'
        rts                                     ; FB8D 60                       `

; ----------------------------------------------------------------------------
; run one of the routines in JMP_TABLE_SOUND_ROUTINES
; input: CUR_SND_CHANNEL - loaded as x and used as an index to SND_CHAN_PTR_LO,x; a pair of bytes is read to SCRATCH_04 and SCRATCH_05
; SCRATCH_04 is the routine to run (0-4) and SCRATCH_05 is an input to the routine (as a)
RUN_SOUND_ROUTINE:
        ldx     CUR_SND_CHANNEL                             ; FB8E A6 02                    ..
        jsr     SND_CHAN_INC_DATA_PTR                           ; FB90 20 6B FD                  k.
        
		; read next sound routine and input
		lda     (SND_CHAN_PTR_LO,x)                         ; FB93 A1 95                    ..
        sta     SND_SCRATCH_04                             ; FB95 85 04                    ..
        jsr     SND_CHAN_INC_DATA_PTR                           ; FB97 20 6B FD                  k.
        lda     (SND_CHAN_PTR_LO,x)                         ; FB9A A1 95                    ..
        sta     SND_SCRATCH_05                             ; FB9C 85 05                    ..
        jsr     SND_CHAN_INC_DATA_PTR                           ; FB9E 20 6B FD                  k.
        
		; run a sound routine, if requested (0-4)
		lda     SND_SCRATCH_04                             ; FBA1 A5 04                    ..
        cmp     #$05                            ; FBA3 C9 05                    ..
        bcc     JMP_TO_SND_ROUTINE                           ; FBA5 90 01                    ..
        rts                                     ; FBA7 60                       `

; ----------------------------------------------------------------------------
; use the jump table below to one of the special sound routines
; input: a = index in jump table
; SND_SCRATCH_05 - loaded as a when jump is made
; CUR_SND_CHANNEL - loaded as x when jump is made
JMP_TO_SND_ROUTINE:
        asl     a                               ; FBA8 0A                       .
        tax                                     ; FBA9 AA                       .
        lda     JMP_TABLE_SOUND_ROUTINES,x                         ; FBAA BD BB FB                 ...
        sta     JMP_LO_06                           ; FBAD 85 06                    ..
        lda     JMP_TABLE_SOUND_ROUTINES+1,x                       ; FBAF BD BC FB                 ...
        sta     JMP_HI_07                             ; FBB2 85 07                    ..
        lda     SND_SCRATCH_05                             ; FBB4 A5 05                    ..
        ldx     CUR_SND_CHANNEL                             ; FBB6 A6 02                    ..
        jmp     (JMP_LO_06)                         ; FBB8 6C 06 00                 l..

; ----------------------------------------------------------------------------
JMP_TABLE_SOUND_ROUTINES:
        .addr   SND_ROUTINE_CONFIG_CHANNEL ; 00                           ; FBBB C5 FB                    ..
        .addr   SND_ROUTINE_SET_VOL_MULT            ; 01               ; FBBD E2 FB                    ..
        .addr   SND_ROUTINE_SET_VOL_BASE            ; 02               ; FBBF FF FB                    ..
        .addr   SND_ROUTINE_SET_FREQUENCY_ADJUST            ; 03               ; FBC1 02 FC                    ..
        .addr   SND_ROUTINE_SET_SWEEP            ; 04               ; FBC3 05 FC                    ..
; ----------------------------------------------------------------------------

; does a volume adjustment, does a calc for SND_CHAN_CONFIG_IDX,x which is also used to look up a table value for SND_CHAN_SWEEP,x
; common inputs for the SOUND_ROUTINE's:
; x = CUR_SND_CHANNEL, offset to channel
; a = SND_SCRATCH_05 (routine parameter)
; Parameter bits: xxvv iiii
; i - lower nibble * 16 sets channel config (index to TBL_SND_CHAN_CONFIG stored in SND_CHAN_CONFIG_IDX) and sweep (index to TBL_SND_SWEEP)
; v - bits 4-5 used to set volume (as bits 6-7 of SND_CHAN_VOL,x)
; x - upper 2 bits not used
; 

; *16 is stored to SND_CHAN_CONFIG_IDX,x then used as index into TBL_SND_SWEEP for data stored to SND_CHAN_SWEEP,x
SND_ROUTINE_CONFIG_CHANNEL:
        ; save a on stack; nuke lower nibble, move bits 4-5 to bits 6-7 and --> SND_VOL_SCRATCH_00
        pha                                     ; FBC5 48                       H
        and     #$F0                            ; FBC6 29 F0                    ).
        asl     a                               ; FBC8 0A                       .
        asl     a                               ; FBC9 0A                       .
        sta     SND_VOL_SCRATCH_00                             ; FBCA 85 00                    ..
        
		; replace SND_CHAN_VOL,x bits 6-7 with those from SND_VOL_SCRATCH_00
		lda     SND_CHAN_VOL,x                           ; FBCC B5 99                    ..
        and     #$3F                            ; FBCE 29 3F                    )?
        ora     SND_VOL_SCRATCH_00                             ; FBD0 05 00                    ..
        sta     SND_CHAN_VOL,x                           ; FBD2 95 99                    ..
        
		; restore a, save a*16 to SND_CHAN_CONFIG_IDX,x
		pla                                     ; FBD4 68                       h
        asl     a                               ; FBD5 0A                       .
        asl     a                               ; FBD6 0A                       .
        asl     a                               ; FBD7 0A                       .
        asl     a                               ; FBD8 0A                       .
        sta     SND_CHAN_CONFIG_IDX,x                           ; FBD9 95 A2                    ..
        
		; used as an index for a table lookup, saved to SND_CHAN_SWEEP,x
		tay                                     ; FBDB A8                       .
        lda     TBL_SND_SWEEP,y                         ; FBDC B9 D2 FD                 ...
        sta     SND_CHAN_SWEEP,x                           ; FBDF 95 9A                    ..
        rts                                     ; FBE1 60                       `

; ----------------------------------------------------------------------------
; if CUR_SND_CHANNEL = x40 (dmc channel offset) or SND_FADE_OUT_FLAG clear does a volume
; fade re-calc. Otherwise rts.
; common inputs for the SOUND_ROUTINE's:
; x, CUR_SND_CHANNEL = channel offset
; SND_SCRATCH_05 = routine parameter
SND_ROUTINE_SET_VOL_MULT:
		; branch if on DMC channel
        lda     CUR_SND_CHANNEL                             ; FBE2 A5 02                    ..
        cmp     #SND_CHAN_DMC                            ; FBE4 C9 40                    .@
        beq     LFBEC                           ; FBE6 F0 04                    ..
        
		; else branch (rts) if SND_FADE_OUT_FLAG set
		lda     SND_FADE_OUT_FLAG                             ; FBE8 A5 92                    ..
        bne     LFBFE                           ; FBEA D0 12                    ..
LFBEC:
		; SND_FADE_OUT_FLAG = 0 or on DMC channel
		; add x0f and SND_SCRATCH_05, then subtract 8 and branch if a>=0 (carry set)
		; basically sets a to 0 if SND_SCRATCH_05 is xF1-F8
        lda     #$0F                            ; FBEC A9 0F                    ..
        clc                                     ; FBEE 18                       .
        adc     SND_SCRATCH_05                             ; FBEF 65 05                    e.
        sec                                     ; FBF1 38                       8
        sbc     #$08                            ; FBF2 E9 08                    ..
        bcs     LFBF8                           ; FBF4 B0 02                    ..
        
		; otherwise a set to 0
		lda     #$00                            ; FBF6 A9 00                    ..
LFBF8:
		; 2*a + 1 --> SND_CHAN_VOL_MULTIPLIER,x
        asl     a                               ; FBF8 0A                       .
        clc                                     ; FBF9 18                       .
        adc     #$01                            ; FBFA 69 01                    i.
        sta     SND_CHAN_VOL_MULTIPLIER,x                           ; FBFC 95 A0                    ..
LFBFE:
        rts                                     ; FBFE 60                       `

; ----------------------------------------------------------------------------
; directly sets the volume for a channel
; common inputs for the SOUND_ROUTINE's:
; x = CUR_SND_CHANNEL
; a = SND_SCRATCH_05
SND_ROUTINE_SET_VOL_BASE:
        sta     SND_CHAN_VOL,x                           ; FBFF 95 99                    ..
        rts                                     ; FC01 60                       `

; ----------------------------------------------------------------------------
; sets a frequency adjust for a channel - adjust channel timer down (makes note sharper)
; sets the SND_CHAN_FREQUENCY_ADJUST_SHARP,x byte for a channel
; common inputs for the SOUND_ROUTINE's:
; x = CUR_SND_CHANNEL
; a = SND_SCRATCH_05
SND_ROUTINE_SET_FREQUENCY_ADJUST:
        sta     SND_CHAN_FREQUENCY_ADJUST_SHARP,x                           ; FC02 95 A1                    ..
        rts                                     ; FC04 60                       `

; ----------------------------------------------------------------------------
; sets the SND_CHAN_SWEEP,x byte for a channel
; common inputs for the SOUND_ROUTINE's:
; x = CUR_SND_CHANNEL
; a = SND_SCRATCH_05
SND_ROUTINE_SET_SWEEP:
        sta     SND_CHAN_SWEEP,x                           ; FC05 95 9A                    ..
        rts                                     ; FC07 60                       `

; ----------------------------------------------------------------------------
LOAD_MUSIC_DATA:
		; default is banks a-b
        ldx     #$0A                            ; FC08 A2 0A                    ..
        lda     MUSIC_ID                             ; FC0A A5 8E                    ..
        cmp     #MUSIC_CREDITS                            ; FC0C C9 0A                    ..
        
		; branch if MUSIC_ID < x0A
		bcc     LFC12                           ; FC0E 90 02                    ..
        
		; MUSIC_ID >= x0A; use banks c-d
		ldx     #$0C                            ; FC10 A2 0C                    ..
LFC12:
        ; set correct bank for song
		stx     NEXT_PRG_8000                             ; FC12 86 34                    .4
        inx                                     ; FC14 E8                       .
        stx     NEXT_PRG_A000                             ; FC15 86 35                    .5
        jsr     USE_NEXT_PRG                           ; FC17 20 87 FD                  ..
        lda     #$00                            ; FC1A A9 00                    ..
        sta     SND_FADE_OUT_FLAG                             ; FC1C 85 92                    ..
        lda     #$00                            ; FC1E A9 00                    ..
        sta     NEXT_SOUND_EFFECT                             ; FC20 85 8F                    ..
        
		; subtract 0xA from the MUSIC_ID if on bank c-d
		lda     MUSIC_ID                             ; FC22 A5 8E                    ..
        cmp     #MUSIC_CREDITS                            ; FC24 C9 0A                    ..
        bcc     LFC2B                           ; FC26 90 03                    ..
        sec                                     ; FC28 38                       8
        sbc     #$0A                            ; FC29 E9 0A                    ..
LFC2B:
		; 2*a gets converted to an index in x
		asl     a                               ; FC2B 0A                       .
        tax                                     ; FC2C AA                       .
        
		; pointer to correct song data read from table and into $e-f
		lda     TBL_MUSIC_HEADER_PTRS,x                         ; FC2D BD 00 80                 ...
        sta     JMP_DEST_0E_LO                           ; FC30 85 0E                    ..
        lda     TBL_MUSIC_HEADER_PTRS+1,x                         ; FC32 BD 01 80                 ...
        sta     JMP_DEST_0F_HI                             ; FC35 85 0F                    ..
        
		; setup indirect write to $0093
		lda     #$93                            ; FC37 A9 93                    ..
        sta     SND_WRITE_BUFFER_LO                           ; FC39 85 0C                    ..
        lda     #$00                            ; FC3B A9 00                    ..
        sta     SND_WRITE_BUFFER_HI                            ; FC3D 85 0D                    ..
        ldx     #$04                            ; FC3F A2 04                    ..
LFC41:
		; buffer the song's header information
		; we alternate writing 8 bytes of header data with 8 bytes of x00's 
		; to the write buffer; 4 loops for 32 bytes total data (and 32 bytes blank)
        ldy     #$07                            ; FC41 A0 07                    ..
LFC43:
        lda     (SND_READ_BUFFER_LO),y                       ; FC43 B1 0E                    ..
        
		; writing to $0093,y 
		sta     (SND_WRITE_BUFFER_LO),y                       ; FC45 91 0C                    ..
        dey                                     ; FC47 88                       .
        
		; loop to write 8 bytes to $0093,y - song header
		bpl     LFC43                           ; FC48 10 F9                    ..
        
		; advance the write buffer only
		clc                                     ; FC4A 18                       .
        lda     #$08                            ; FC4B A9 08                    ..
        adc     SND_WRITE_BUFFER_LO                           ; FC4D 65 0C                    e.
        sta     SND_WRITE_BUFFER_LO                           ; FC4F 85 0C                    ..
        lda     #$00                            ; FC51 A9 00                    ..
        adc     SND_WRITE_BUFFER_HI                             ; FC53 65 0D                    e.
        sta     SND_WRITE_BUFFER_HI                             ; FC55 85 0D                    ..

		; loop to write 8 bytes of x00 to the write buffer
        ldy     #$07                            ; FC57 A0 07                    ..
        lda     #$00                            ; FC59 A9 00                    ..
LFC5B:
        sta     (SND_WRITE_BUFFER_LO),y                       ; FC5B 91 0C                    ..
        dey                                     ; FC5D 88                       .
        bpl     LFC5B                           ; FC5E 10 FB                    ..

		; advance both the write and read buffers
        clc                                     ; FC60 18                       .
        lda     #$08                            ; FC61 A9 08                    ..
        adc     SND_WRITE_BUFFER_LO                           ; FC63 65 0C                    e.
        sta     SND_WRITE_BUFFER_LO                           ; FC65 85 0C                    ..
        lda     #$00                            ; FC67 A9 00                    ..
        adc     SND_WRITE_BUFFER_HI                             ; FC69 65 0D                    e.
        sta     SND_WRITE_BUFFER_HI                             ; FC6B 85 0D                    ..
        clc                                     ; FC6D 18                       .
        lda     #$08                            ; FC6E A9 08                    ..
        adc     SND_READ_BUFFER_LO                           ; FC70 65 0E                    e.
        sta     SND_READ_BUFFER_LO                           ; FC72 85 0E                    ..
        lda     #$00                            ; FC74 A9 00                    ..
        adc     SND_READ_BUFFER_HI                             ; FC76 65 0F                    e.
        sta     SND_READ_BUFFER_HI                             ; FC78 85 0F                    ..

		; loop while x<>0 (4 loops)
        dex                                     ; FC7A CA                       .
        bne     LFC41                           ; FC7B D0 C4                    ..
        jsr     MMC_SET_ALL_BANKS                           ; FC7D 20 1D D4                  ..
        rts                                     ; FC80 60                       `

; ----------------------------------------------------------------------------
; input - CUR_SND_CHANNEL = channel offset
; output - SCRATCH_04 = lower 8 bits of note frequency/pitch
;          SCRATCH_05 = upper byte of frequency (lower 3 used for pitch)
SND_LOAD_NEXT_NOTE:
        ldx     CUR_SND_CHANNEL                             ; FC81 A6 02                    ..
        lda     (SND_CHAN_PTR_LO,x)                         ; FC83 A1 95                    ..
        jsr     SND_CHAN_INC_DATA_PTR                           ; FC85 20 6B FD                  k.
        
		; 2*lower nibble --> index into note table
		tay                                     ; FC88 A8                       .
        and     #$0F                            ; FC89 29 0F                    ).
        asl     a                               ; FC8B 0A                       .
        tax                                     ; FC8C AA                       .
        lda     TBL_SND_CHANS,x                         ; FC8D BD B1 FD                 ...
        sta     SND_SCRATCH_04                             ; FC90 85 04                    ..
        lda     TBL_SND_CHANS+1,x                         ; FC92 BD B2 FD                 ...
        sta     SND_SCRATCH_05                             ; FC95 85 05                    ..
        
		; subtract SND_CHAN_FREQUENCY_ADJUST_SHARP from scratch_04		
		ldx     CUR_SND_CHANNEL                             ; FC97 A6 02                    ..
		lda     SND_SCRATCH_04                             ; FC99 A5 04                    ..
        sec                                     ; FC9B 38                       8
        sbc     SND_CHAN_FREQUENCY_ADJUST_SHARP,x                           ; FC9C F5 A1                    ..
        sta     SND_SCRATCH_04                             ; FC9E 85 04                    ..
        
		; if scratch_04 still positive, branch; else dec scratch_05
		bcs     LFCA4                           ; FCA0 B0 02                    ..
        dec     SND_SCRATCH_05                             ; FCA2 C6 05                    ..
LFCA4:
		; branch (rts) if y/16 == 0
        tya                                     ; FCA4 98                       .
        lsr     a                               ; FCA5 4A                       J
        lsr     a                               ; FCA6 4A                       J
        lsr     a                               ; FCA7 4A                       J
        lsr     a                               ; FCA8 4A                       J
        beq     LFCB3                           ; FCA9 F0 08                    ..
        
		; y/16 --> y
		tay                                     ; FCAB A8                       .
LFCAC:
		; loop and move low bits from scratch_05 to high bits scratch_04
        lsr     SND_SCRATCH_05                             ; FCAC 46 05                    F.
        ror     SND_SCRATCH_04                             ; FCAE 66 04                    f.
        dey                                     ; FCB0 88                       .
        bne     LFCAC                           ; FCB1 D0 F9                    ..
LFCB3:
        rts                                     ; FCB3 60                       `

; ----------------------------------------------------------------------------
; input: y=# of loops
; SND_VOL_SCRATCH_00 = added each loop
; result is y*SCRATCH_00/16 and is saved to SND_VOL_SCRATCH_00
CALC_MIN_VOLUME:
        lda     #$00                            ; FCB4 A9 00                    ..
        iny                                     ; FCB6 C8                       .
LFCB7:
        clc                                     ; FCB7 18                       .
        adc     SND_VOL_SCRATCH_00                             ; FCB8 65 00                    e.
        dey                                     ; FCBA 88                       .
        bne     LFCB7                           ; FCBB D0 FA                    ..
        
		; now divide by 16 and save SND_VOL_SCRATCH_00
		lsr     a                               ; FCBD 4A                       J
        lsr     a                               ; FCBE 4A                       J
        lsr     a                               ; FCBF 4A                       J
        lsr     a                               ; FCC0 4A                       J
        sta     SND_VOL_SCRATCH_00                             ; FCC1 85 00                    ..
        rts                                     ; FCC3 60                       `

; ----------------------------------------------------------------------------
; loads note config for a channel from the table
; input - CUR_SND_CHANNEL = offset to channel
SND_CHAN_LOAD_CONFIG_FULL:
        ; look up the config index for this channel
		ldx     CUR_SND_CHANNEL                             ; FCC4 A6 02                    ..
        ldy     SND_CHAN_CONFIG_IDX,x                           ; FCC6 B4 A2                    ..
        sty     SND_CHAN_CONFIG_IDX_2,x                           ; FCC8 94 9B                    ..
        lda     TBL_SND_CHAN_CONFIG,y                         ; FCCA B9 CB FD                 ...
        sta     SND_CHAN_VOL_BASE,x                           ; FCCD 95 9C                    ..
        lda     TBL_SND_CHAN_CONFIG+1,y                         ; FCCF B9 CC FD                 ...
        sta     SND_CHAN_VOL_CHANGE_CTR,x                           ; FCD2 95 9D                    ..
        lda     TBL_SND_CHAN_CONFIG+2,y                         ; FCD4 B9 CD FD                 ...
        sta     SND_CHAN_BAR_NOTES_REMAINING,x                           ; FCD7 95 9E                    ..
        lda     TBL_SND_CHAN_CONFIG+3,y                         ; FCD9 B9 CE FD                 ...
        sta     SND_CHAN_VOL_2,x                           ; FCDC 95 9F                    ..
        rts                                     ; FCDE 60                       `

; ----------------------------------------------------------------------------
; loads a note adding x0C to the y offset and not updating volume
; input - CUR_SND_CHANNEL = offset to channel
SND_CHAN_LOAD_CONFIG_NO_VOL:
        ; look up the config index for this channel
		ldx     CUR_SND_CHANNEL                             ; FCDF A6 02                    ..
        lda     SND_CHAN_CONFIG_IDX,x                           ; FCE1 B5 A2                    ..
        clc                                     ; FCE3 18                       .
        adc     #$0C                            ; FCE4 69 0C                    i.
        tay                                     ; FCE6 A8                       .
        sty     SND_CHAN_CONFIG_IDX_2,x                           ; FCE7 94 9B                    ..
        lda     TBL_SND_CHAN_CONFIG,y                         ; FCE9 B9 CB FD                 ...
        sta     SND_CHAN_VOL_BASE,x                           ; FCEC 95 9C                    ..
        lda     TBL_SND_CHAN_CONFIG+1,y                         ; FCEE B9 CC FD                 ...
        sta     SND_CHAN_VOL_CHANGE_CTR,x                           ; FCF1 95 9D                    ..
        lda     TBL_SND_CHAN_CONFIG+2,y                         ; FCF3 B9 CD FD                 ...
        sta     SND_CHAN_BAR_NOTES_REMAINING,x                           ; FCF6 95 9E                    ..
        rts                                     ; FCF8 60                       `

; ----------------------------------------------------------------------------
; advance to the next song part on a channel
; input - CUR_SND_CHANNEL - offset to channel of interest
SND_CHAN_NEXT_VERSE:
		; copy the next byte pair forward to the current position
		; branch if next byte also a stop byte
        ldx     CUR_SND_CHANNEL                             ; FCF9 A6 02                    ..
        lda     SND_CHAN_NEXT_VERSE_LO,x                           ; FCFB B5 97                    ..
        sta     SND_CHAN_PTR_LO,x                           ; FCFD 95 95                    ..
        lda     SND_CHAN_NEXT_VERSE_HI,x                           ; FCFF B5 98                    ..
        sta     SND_CHAN_DATA_PTR_HI,x                           ; FD01 95 96                    ..
        
		; branch if SND_CHAN_NEXT_VERSE_HI,x = 0 
		beq     LFD0A                           ; FD03 F0 05                    ..
        
		; otherwise set SND_CHAN_NOTE_TIMER to 1 - this will trigger the first byte to 
		; be loaded next time the channel is processed
		lda     #$01                            ; FD05 A9 01                    ..
        sta     SND_CHAN_NOTE_TIMER,x                           ; FD07 95 93                    ..
        rts                                     ; FD09 60                       `

; ----------------------------------------------------------------------------
; clear everything but bit 6 for SND_CHAN_CTRL,x
LFD0A:
        lda     SND_CHAN_CTRL,x                           ; FD0A B5 94                    ..
        and     #$40                            ; FD0C 29 40                    )@
        sta     SND_CHAN_CTRL,x                           ; FD0E 95 94                    ..
        rts                                     ; FD10 60                       `

; ----------------------------------------------------------------------------
; called when SND_CHAN_VOL_CHANGE_CTR is 0
; figures out what the next channel volume should be and for how long
; return a - used to set channel volume
SND_NEXT_VOL_LEVEL:
        ; look up an offset in y for the table
		ldx     CUR_SND_CHANNEL                             ; FD11 A6 02                    ..
        ldy     SND_CHAN_CONFIG_IDX_2,x                           ; FD13 B4 9B                    ..
        
		; new counter is written for the channel
		lda     TBL_SND_CHAN_CONFIG+1,y                         ; FD15 B9 CC FD                 ...
        sta     SND_CHAN_VOL_CHANGE_CTR,x                           ; FD18 95 9D                    ..
        
		; branch  (use vol 0 if total > 0x10) if the channel's SND_CHAN_VOL_BASE,x is negative
		; looking at TBL_SND_CHAN_CONFIG, it doesn't seem it's ever negative?
		lda     SND_CHAN_VOL_BASE,x                           ; FD1A B5 9C                    ..
        bmi     LFD2A                           ; FD1C 30 0C                    0.
        
		; it's positive; we'll use volume x0F if total > 0x10
		; add SND_CHAN_VOL_2,x and branch if result <x10
		clc                                     ; FD1E 18                       .
        adc     SND_CHAN_VOL_2,x                           ; FD1F 75 9F                    u.
        cmp     #$10                            ; FD21 C9 10                    ..
        bcc     LFD33                           ; FD23 90 0E                    ..
        
		; result >= x10
		lda     #$0F                            ; FD25 A9 0F                    ..
        jmp     LFD33                           ; FD27 4C 33 FD                 L3.

; ----------------------------------------------------------------------------
LFD2A:
		; SND_CHAN_VOL_BASE,x was negative; add SND_CHAN_VOL_2,x and branch if <x10
		; else use 0
        clc                                     ; FD2A 18                       .
        adc     SND_CHAN_VOL_2,x                           ; FD2B 75 9F                    u.
        cmp     #$10                            ; FD2D C9 10                    ..
        bcc     LFD33                           ; FD2F 90 02                    ..
        lda     #$00                            ; FD31 A9 00                    ..

LFD33:
        ; save to SND_CHAN_VOL_2 and a copy of that to SND_VOL_SCRATCH_00
		sta     SND_CHAN_VOL_2,x                           ; FD33 95 9F                    ..
        sta     SND_VOL_SCRATCH_00                             ; FD35 85 00                    ..
        
		; does calc SND_VOL_SCRATCH_00*y / 16
		ldy     SND_CHAN_VOL_MULTIPLIER,x                           ; FD37 B4 A0                    ..
        jsr     CALC_MIN_VOLUME                           ; FD39 20 B4 FC                  ..
        
		; set the channel volume, with SND_VOL_SCRATCH_00 enforcing a minimum
		lda     SND_CHAN_VOL,x                           ; FD3C B5 99                    ..
        and     #$C0                            ; FD3E 29 C0                    ).
        ora     SND_VOL_SCRATCH_00                             ; FD40 05 00                    ..
        ora     #$30                            ; FD42 09 30                    .0
        rts                                     ; FD44 60                       `

; ----------------------------------------------------------------------------
; loads a note
; if SND_CHAN_BAR_NOTES_REMAINING,x = 0 checks SND_CHAN_CONFIG_IDX_2,x and if lower nibble >= x0c carry is set
; return: carry - set means disable channel
LOAD_NEXT_CHAN_CONFIG:
        ; CUR_SND_CHANNEL = offset to channel --> x
		; y used as index to table in TBL_SND_CHAN_CONFIG
		; 
		ldx     CUR_SND_CHANNEL                             ; FD45 A6 02                    ..
        
		; dec channel SND_CHAN_BAR_NOTES_REMAINING and branch (return carry clear) if <> 0
		dec     SND_CHAN_BAR_NOTES_REMAINING,x                           ; FD47 D6 9E                    ..
        bne     LFD69                           ; FD49 D0 1E                    ..
        
		; value = 0; branch (return carry set) if lower nibble of b value >= x0c
		lda     SND_CHAN_CONFIG_IDX_2,x                           ; FD4B B5 9B                    ..
        and     #$0F                            ; FD4D 29 0F                    ).
        cmp     #$0C                            ; FD4F C9 0C                    ..
        bcs     LFD6A                           ; FD51 B0 17                    ..
        
		; lower nibble SND_CHAN_CONFIG_IDX_2 value < x0c
		; advance to the next set of 4 bytes
		lda     SND_CHAN_CONFIG_IDX_2,x                           ; FD53 B5 9B                    ..
        adc     #$04                            ; FD55 69 04                    i.
        tay                                     ; FD57 A8                       .
        sty     SND_CHAN_CONFIG_IDX_2,x                           ; FD58 94 9B                    ..
        
		; copy 3 table bytes to cde values and return carry clear
		lda     TBL_SND_CHAN_CONFIG,y                         ; FD5A B9 CB FD                 ...
        sta     SND_CHAN_VOL_BASE,x                           ; FD5D 95 9C                    ..
		lda     TBL_SND_CHAN_CONFIG+1,y                         ; FD5F B9 CC FD                 ...
        sta     SND_CHAN_VOL_CHANGE_CTR,x                           ; FD62 95 9D                    ..
        lda     TBL_SND_CHAN_CONFIG+2,y                         ; FD64 B9 CD FD                 ...
        sta     SND_CHAN_BAR_NOTES_REMAINING,x                           ; FD67 95 9E                    ..
LFD69:
        clc                                     ; FD69 18                       .
LFD6A:
        rts                                     ; FD6A 60                       `

; ----------------------------------------------------------------------------
; input: CUR_SND_CHANNEL - offset to channel to increment
; increase SND_CHAN_PTR_LO,x and SND_CHAN_DATA_PTR_HI,x
; note: does not affect value of a
SND_CHAN_INC_DATA_PTR:
        ldx     CUR_SND_CHANNEL                             ; FD6B A6 02                    ..
        
		; SND_CHAN_PTR_LO-6,x incremented as a 16-bit #; only increment SND_CHAN_DATA_PTR_HI if SND_CHAN_PTR_LO rolled over
		inc     SND_CHAN_PTR_LO,x                           ; FD6D F6 95                    ..
        bne     LFD73                           ; FD6F D0 02                    ..
        inc     SND_CHAN_DATA_PTR_HI,x                           ; FD71 F6 96                    ..
LFD73:
        rts                                     ; FD73 60                       `

; ----------------------------------------------------------------------------
; swap to PRG A-B (bank 5)
USE_PRG_AB:
        ldx     #BANK_SELECT_PRG_8000                            ; FD74 A2 06                    ..
        ldy     #$0A                            ; FD76 A0 0A                    ..
        stx     MAPPER_BANK_SELECT                           ; FD78 8E 00 80                 ...
        sty     MAPPER_BANK_VALUE                           ; FD7B 8C 01 80                 ...
        inx                                     ; FD7E E8                       .
        iny                                     ; FD7F C8                       .
        stx     MAPPER_BANK_SELECT                           ; FD80 8E 00 80                 ...
        sty     MAPPER_BANK_VALUE                           ; FD83 8C 01 80                 ...
        rts                                     ; FD86 60                       `

; ----------------------------------------------------------------------------

; use PRG specified in NEXT_PRG_8000 and NEXT_PRG_A000
USE_NEXT_PRG:
        lda     #BANK_SELECT_PRG_8000                            ; FD87 A9 06                    ..
        sta     MAPPER_BANK_SELECT                           ; FD89 8D 00 80                 ...
        lda     NEXT_PRG_8000                             ; FD8C A5 34                    .4
        sta     MAPPER_BANK_VALUE                           ; FD8E 8D 01 80                 ...
        lda     #BANK_SELECT_PRG_A000                            ; FD91 A9 07                    ..
        sta     MAPPER_BANK_SELECT                           ; FD93 8D 00 80                 ...
        lda     NEXT_PRG_A000                             ; FD96 A5 35                    .5
        sta     MAPPER_BANK_VALUE                           ; FD98 8D 01 80                 ...
        rts                                     ; FD9B 60                       `

; ----------------------------------------------------------------------------
; revert PRG banks to LAST_BANK_VALUE's
REVERT_PRG:
        lda     #BANK_SELECT_PRG_8000                            ; FD9C A9 06                    ..
        sta     MAPPER_BANK_SELECT                           ; FD9E 8D 00 80                 ...
        lda     PRG_BANK_8000                             ; FDA1 A5 30                    .0
        sta     MAPPER_BANK_VALUE                           ; FDA3 8D 01 80                 ...
        lda     #BANK_SELECT_PRG_A000                            ; FDA6 A9 07                    ..
        sta     MAPPER_BANK_SELECT                           ; FDA8 8D 00 80                 ...
        lda     PRG_BANK_A000                             ; FDAB A5 31                    .1
        sta     MAPPER_BANK_VALUE                           ; FDAD 8D 01 80                 ...
        rts                                     ; FDB0 60                       `

.include "include\banke-f-misc-data.asm"

; ----------------------------------------------------------------------------
RESET_VECTOR:
        ; disable IRQ and config the mapper
		sei                                     ; FFE0 78                       x
        lda     #BANK_SELECT_BG_0                            ; FFE1 A9 00                    ..
        sta     MAPPER_BANK_SELECT                           ; FFE3 8D 00 80                 ...
        sta     MAPPER_NAMETABLE_PRG_RAM_PROTECT                           ; FFE6 8D 01 A0                 ...
        sta     MAPPER_IRQ_DISABLE                        ; FFE9 8D 00 E0                 ...
        jmp     RESET_C000                           ; FFEC 4C 00 C0                 L..

; ----------------------------------------------------------------------------
		; filler
		.byte   $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00 ; $ffef
		
; ----------------------------------------------------------------------------
		; NMI $d1fe
		.addr   NMI_VECTOR                           ; FFFA FE D1                    ..

		; Reset $ffe0
		.addr   RESET_VECTOR                           ; FFFC E0 FF                    ..

		; Interrupt $d1fe
		.addr   NMI_VECTOR                           ; FFFE FE D1                    ..		

; Include the CHR
.segment "CHR"

.incbin ".\include\chr\chr-all.chr"